<!DOCTYPE html>
<!-- Built with spec-md https://spec-md.com -->
<html>
<head><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1"><title>GROQ</title>
<style>/** * prism.js default theme for JavaScript, CSS and HTML * Based on dabblet (http://dabblet.com) * @author Lea Verou */ code[class*="language-"], pre[class*="language-"] { 	color: black; 	background: none; 	text-shadow: 0 1px white; 	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; 	font-size: 1em; 	text-align: left; 	white-space: pre; 	word-spacing: normal; 	word-break: normal; 	word-wrap: normal; 	line-height: 1.5; 	-moz-tab-size: 4; 	-o-tab-size: 4; 	tab-size: 4; 	-webkit-hyphens: none; 	-moz-hyphens: none; 	-ms-hyphens: none; 	hyphens: none; } pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection, code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection { 	text-shadow: none; 	background: #b3d4fc; } pre[class*="language-"]::selection, pre[class*="language-"] ::selection, code[class*="language-"]::selection, code[class*="language-"] ::selection { 	text-shadow: none; 	background: #b3d4fc; } @media print { 	code[class*="language-"], 	pre[class*="language-"] { 		text-shadow: none; 	} } /* Code blocks */ pre[class*="language-"] { 	padding: 1em; 	margin: .5em 0; 	overflow: auto; } :not(pre) > code[class*="language-"], pre[class*="language-"] { 	background: #f5f2f0; } /* Inline code */ :not(pre) > code[class*="language-"] { 	padding: .1em; 	border-radius: .3em; 	white-space: normal; } .token.comment, .token.prolog, .token.doctype, .token.cdata { 	color: slategray; } .token.punctuation { 	color: #999; } .token.namespace { 	opacity: .7; } .token.property, .token.tag, .token.boolean, .token.number, .token.constant, .token.symbol, .token.deleted { 	color: #905; } .token.selector, .token.attr-name, .token.string, .token.char, .token.builtin, .token.inserted { 	color: #690; } .token.operator, .token.entity, .token.url, .language-css .token.string, .style .token.string { 	color: #9a6e3a; 	/* This background color was intended by the author of this theme. */ 	background: hsla(0, 0%, 100%, .5); } .token.atrule, .token.attr-value, .token.keyword { 	color: #07a; } .token.function, .token.class-name { 	color: #DD4A68; } .token.regex, .token.important, .token.variable { 	color: #e90; } .token.important, .token.bold { 	font-weight: bold; } .token.italic { 	font-style: italic; } .token.entity { 	cursor: help; }</style>
<style>:root{color:#333;font-family:Cambria,"Palatino Linotype",Palatino,"Liberation Serif",serif;font-size:15px;line-height:1.5;--mono-font-size: 13px;--indent: 1rem;--list-indent: 1.5rem;--dfn-indent: 0rem}@media (min-width: 720px){:root{font-size:17px;--mono-font-size: 15px;--indent: 2rem;--list-indent: 2rem;--dfn-indent: 2rem}}body{margin:3rem 0 3rem}article{margin:0 1rem}@media (min-width: 720px){body{margin:6rem auto 3rem;max-width:800px;padding-left:75px;padding-right:clamp(0px,calc((100vw - 800px) * .25),75px)}}.source-link{display:none}@media screen and (min-width: 720px){.source-link{display:block;position:absolute;width:18px;fill:#ccc;opacity:.3}.source-link:hover{opacity:1}}.outdated-selection-link,.selection-link{position:absolute;display:block;color:#fff;--selection-background-color: #cacee0;background:var(--selection-background-color);border-radius:4px;font-size:36px;height:23px;line-height:48px;text-align:center;text-decoration:none;width:25px;user-select:none;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none}.outdated-selection-link:hover,.selection-link:hover{text-decoration:none}.outdated-selection-link:before,.selection-link:before{border:5px solid transparent;content:"";height:0;margin-top:-5px;margin-right:-5px;position:absolute;right:1px;top:50%;width:0}@media (max-width: 719px){.outdated-selection-link:before,.selection-link:before{border-bottom-color:var(--selection-background-color);border-top:0;right:50%;top:1px}}@media (min-width: 720px){.outdated-selection-link:before,.selection-link:before{border-left-color:var(--selection-background-color);border-right:0;right:1px;top:50%}}.selection-link:hover{--selection-background-color: #3b5998}.outdated-selection-link{--selection-background-color: #f0babe;font-size:21px;font-weight:800;line-height:27px}.outdated-selection-link:hover:after{content:"This selection content has changed since this link was created.";font:9pt/11pt Cambria,"Palatino Linotype",Palatino,"Liberation Serif",serif;position:absolute;display:block;white-space:nowrap;padding:2px 5px 1px;top:-20px;background:black;color:#fff}a{color:#3b5998;text-decoration:none}a:hover{text-decoration:underline}img{max-width:100%}dl{margin:1rem 0 1rem var(--dfn-indent)}dd{margin:.25em 0 .5em var(--indent)}dd+dd{margin-top:1rem}dfn,.spec-ref{font-style:italic}dfn>a,.spec-ref>a{color:inherit}h1,h2,h3,h4,h5,h6{font-weight:bold;margin:3em 0 1em;position:relative}@media (min-width: 720px){header>h1{margin:6em 0 3em}}h1{font-size:1.5em;margin-top:5em}h2,h3{font-size:1.25em}h4,h5,h6{font-size:1em}section{padding-top:1rem;margin-top:-1rem}section.subsec>h6{margin-top:2em}section.subsec>h6>a{color:#333}section .spec-secid{margin-right:1ex}@media (min-width: 720px){section .spec-secid{position:absolute;right:100%;text-align:right;white-space:nowrap}}footer{font-size:75%;opacity:.5;text-align:center;margin-top:12rem}.spec-toc{margin:1rem 0 3rem}.spec-toc .title{content:"Contents";display:block;font-weight:bold;margin:5em 0 1em}.spec-toc .spec-secid{margin-right:1ex}.spec-toc ol{list-style:none;padding-left:0;margin-top:0;margin-bottom:0}.spec-toc ol ol{list-style:none;padding-left:2ex;margin-bottom:.25em}.spec-toc li{position:relative;padding:5px 0 0 30px;margin:-5px 0 0 -30px}.spec-toc a{color:#333}.spec-toc a:hover{text-decoration:none}.spec-toc a .spec-secid{color:#3b5998}.spec-toc a:hover .spec-secid{text-decoration:underline}.spec-toc .toggle{display:none}.spec-toc .toggle+label{cursor:pointer;left:6px;opacity:1;padding:5px 6px 5px 7px;position:absolute;top:6px;transform:rotate(0deg);transition:all .18s ease-in-out}.spec-toc .toggle+label:after{border-color:transparent transparent transparent #bbc;border-style:solid;border-width:6px 0 6px 7px;content:" ";display:block;height:0;width:0}@media (pointer: fine){.spec-toc .toggle+label{left:10px;padding:3px 5px 3px 6px;top:8px}}.spec-toc .toggle:checked+label{transform:rotate(90deg)}@media (hover: hover){.spec-toc li:not(:hover)>.toggle:checked+label{opacity:0}}.spec-toc .toggle:not(:checked)~ol{max-height:0;overflow:hidden;margin:0}.spec-sidebar-toggle{display:none}.spec-sidebar-toggle+label>.spec-sidebar-button{position:fixed;right:0;top:0;padding:10px 15px;font-size:30px;color:#000000b3;z-index:2;cursor:pointer;user-select:none;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none}.spec-sidebar-toggle:checked+label:after{content:"";position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:0}.spec-sidebar{display:none;position:fixed;right:0;top:0;width:min(320px,calc(100vw - 48px));font-size:14px;line-height:1.75;overflow-y:scroll;height:100%;padding:0 0 5rem 30px;box-sizing:border-box;background:#f0f0f0;box-shadow:inset 1px 0 rgba(0,0,0,.05),-4px 0 8px -2px rgba(0,0,0,.04);overscroll-behavior:contain}.spec-sidebar{user-select:none;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none}.spec-sidebar-toggle:checked~.spec-sidebar{display:block}.spec-sidebar .viewing>a:after{color:#8b9;content:"\2022";margin-left:1ex}@media (min-width: 1220px){.spec-sidebar-toggle+label{display:none}.spec-sidebar{display:block;box-shadow:inset 1px 0 rgba(0,0,0,.05),inset 4px 0 8px -2px rgba(0,0,0,.08)!important}body{padding-right:345px}}.spec-note{background:#FEFEF3;border-left:solid 4px #F4E925;margin:1rem -1rem;min-width:70vw;padding:8px 1rem 12px calc(1rem - 4px);width:-moz-fit-content;width:-webkit-fit-content;width:fit-content}@media (min-width: 720px){.spec-note{min-width:416px}}.spec-note>a:first-child{color:#6c6613;display:block;font:italic 11pt/18pt Cambria,"Palatino Linotype",Palatino,"Liberation Serif",serif;opacity:.6;user-select:none}.spec-todo{color:#666;margin:1em 0 1em 5em;min-height:1em}.spec-todo::before{content:"todo";display:block;float:left;margin-left:-5em;text-transform:uppercase}.spec-index ol{list-style-type:none;margin:0 0 0 var(--indent);padding:0;column-width:210px;column-gap:var(--indent)}.spec-index ol li{width:min-content;white-space:nowrap}pre,code{font-family:Consolas,Monaco,"Andale Mono","Ubuntu Mono",monospace;font-size:var(--mono-font-size);font-weight:inherit}code{background:rgba(0,0,0,.03);margin:-2px -1px;padding:3px 3px;white-space:pre-wrap}pre>code{background:none;font-weight:inherit;margin:0;padding:0;white-space:pre}pre{background:#FAFAFA;border-left:solid 4px #E9E9E9;margin:1rem -1rem;min-width:70vw;padding:12px 1rem 12px calc(1rem - 4px);width:-moz-fit-content;width:-webkit-fit-content;width:fit-content;max-width:calc(100vw - 2rem);overflow-y:scroll}@media (min-width: 720px){pre{min-width:40ch}}.spec-example{background:#FAFAFF;border-left:solid 4px #BBBBFF;padding-top:8px}.spec-counter-example{background:#FFFAFA;border-left:solid 4px #FFBBBB;padding-top:8px}.spec-example>a,.spec-counter-example>a{display:block;font:italic 11pt/18pt Cambria,"Palatino Linotype",Palatino,"Liberation Serif",serif;opacity:.6;user-select:none}.spec-counter-example>a{color:#98593b}table{border-collapse:collapse}th{background-color:#f9f9f9}td,th{border:1px solid #D0D0D0;padding:.4em;vertical-align:baseline}ol,ul{padding-left:var(--list-indent)}li>ol,li>ul{margin-top:.25em;margin-bottom:.5em}li+li{margin-top:.25em}li.task{list-style-type:none;position:relative}li.task>input:first-child{margin-left:0;position:absolute;transform:translateX(calc(-100% - 1ch))}ins{background-color:#00c81e14;text-decoration:none}del{background-color:#c8000014}.spec-added,.spec-removed{border-left:4px solid;margin-left:-18px;padding-left:14px}.spec-added{border-color:#396}.spec-removed{border-color:#933;text-decoration:line-through}.spec-keyword{font-weight:bold}.spec-string{font-family:Consolas,Monaco,monospace;font-size:85%;white-space:pre}var{font-style:italic}*[data-name]{transition:.15s background ease-out;border-radius:2px;padding:0 3px;margin:0 -3px}.spec-semantic,.spec-algo{margin:1rem 0 1rem var(--dfn-indent)}.spec-semantic>.spec-nt::after,.spec-algo>.spec-call:first-child::after{content:":";font-style:normal;font-weight:bold;margin-left:1ex}.spec-semantic ol,.spec-semantic ol ol ol ol,.spec-algo ol,.spec-algo ol ol ol ol{list-style-type:decimal}.spec-semantic ol ol,.spec-semantic ol ol ol ol ol,.spec-algo ol ol,.spec-algo ol ol ol ol ol{list-style-type:lower-alpha}.spec-semantic ol ol ol,.spec-semantic ol ol ol ol ol ol,.spec-algo ol ol ol,.spec-algo ol ol ol ol ol ol{list-style-type:lower-roman}.spec-call>a{color:inherit}.spec-production{margin:1rem 0 1rem var(--dfn-indent)}.spec-production>.spec-nt::after{content:":";font-style:normal;font-weight:bold;margin:0 1ex}.spec-semantic.d2>.spec-nt::after,.spec-production.d2>.spec-nt::after{content:"::"}.spec-semantic.d3>.spec-nt::after,.spec-production.d3>.spec-nt::after{content:":::"}.spec-production>.spec-rhs{line-height:1.1;margin:.25em 0 .5em calc(2 * var(--indent));text-indent:calc(-1 * var(--indent))}.spec-semantic>.spec-rhs{display:inline-block;text-indent:calc(-1 * var(--indent));margin-left:calc(1ex + var(--indent))}.spec-rhs>*{text-indent:0}.spec-oneof{display:inline}.spec-oneof::before{content:"one of";font-style:normal;font-weight:bold}.spec-oneof-grid{max-width:calc(100vw - 2rem);overflow:scroll;margin:-1ex -1rem;padding:1ex 1rem}.spec-oneof-grid>table{margin-left:var(--indent)}.spec-oneof .spec-rhs{border:none;margin:0;padding:0 0 0 1rem;vertical-align:baseline;white-space:pre}.spec-oneof .spec-rhs:first-child{padding:0}.spec-rhs .spec-constrained:not(:first-child),.spec-rhs .spec-quantified:not(:first-child),.spec-rhs .spec-nt:not(:first-child),.spec-rhs .spec-t:not(:first-child),.spec-rhs .spec-rx:not(:first-child),.spec-rhs .spec-prose:not(:first-child),.spec-rhs .spec-empty:not(:first-child),.spec-rhs .spec-lookahead:not(:first-child){margin-left:1ex;display:inline-block}.spec-condition{font-size:85%}.spec-condition::before{content:"[if "}.spec-condition.not::before{content:"[if not "}.spec-condition::after{content:"]"}.spec-empty,.spec-prose{color:#666}.spec-nt{font-style:italic}.spec-nt>a{color:inherit}.spec-quantifiers,.spec-params{font-size:65%;font-style:normal;vertical-align:sub}.spec-quantifier.list{color:#3348d3}.spec-quantifier.optional{color:#83238e}.spec-params,.spec-condition{color:#1c7758}.spec-params::before{content:"["}.spec-params::after{content:"]"}.spec-quantifier:not(:last-child)::after,.spec-param:not(:last-child)::after{color:#666;content:", "}.spec-param.conditional::before{content:"?"}.spec-param.negated::before{content:"!"}.spec-t,.spec-rx{color:#333;font-family:monospace;font-weight:bold}.spec-butnot::before{color:#666;content:"but not";font-family:Cambria,"Palatino Linotype",Palatino,"Liberation Serif",serif;font-weight:normal;margin-right:1ex}.spec-butnot>*:not(:first-child)::before{color:#666;content:"or";font-family:Cambria,"Palatino Linotype",Palatino,"Liberation Serif",serif;font-weight:normal;margin-right:1ex}.spec-rhs .spec-oneof::before,.spec-rhs .spec-butnot::before{margin-left:1ex}.spec-lookahead>*{margin:0!important}.spec-lookahead>*:not(:first-child)::before{color:#666;content:", ";font-family:Cambria,"Palatino Linotype",Palatino,"Liberation Serif",serif;font-style:normal;font-weight:normal}.spec-lookahead::before{color:#666;content:"[lookahead = ";font-family:Cambria,"Palatino Linotype",Palatino,"Liberation Serif",serif;font-style:normal;font-weight:normal}.spec-lookahead.not::before{content:"[lookahead \2260  "}.spec-lookahead.set::before{content:"[lookahead \2208  {";margin-right:0}.spec-lookahead.set.not::before{content:"[lookahead \2209  {"}.spec-lookahead.ntset::before{content:"[lookahead \2208  ";margin-right:0}.spec-lookahead.ntset.not::before{content:"[lookahead \2209  "}.spec-lookahead::after{color:#666;content:"]"}.spec-lookahead.set::after{content:"}]"}.token.atrule,.token.attr-value,.token.keyword,.token.property,.token.selector,.token.attr-name,.token.builtin,.token.entity,.token.url,.token.inserted{color:#1b1994b0;background:none}.token.tag,.token.boolean,.token.number,.token.string,.token.char,.token.constant,.token.symbol,.token.regex,.token.important,.token.variable,.token.function,.token.class-name,.token.deleted{color:#a20764bd}.token.comment,.token.prolog,.token.doctype,.token.cdata,.token.description{color:inherit;opacity:.3}.token.punctuation{color:inherit;opacity:.5}.token.operator,.token.namespace{color:inherit;opacity:.7}</style>
<script>(function(){var r,a=[];document.addEventListener("readystatechange",function(){document.readyState==="interactive"&&u()});function u(){var n=document.querySelector('label[for="spec-sidebar-toggle"]');n.addEventListener("scroll",o),n.addEventListener("touchmove",o);function o(d){d.preventDefault()}for(var t=document.getElementsByTagName("section"),e=0;e<t.length;e++)t[e].getAttribute("secid")&&a.push(t[e]);var i=window.scrollY,c=!1;window.addEventListener("scroll",function(d){i=window.scrollY,c||(c=!0,window.requestAnimationFrame(function(){s(i),c=!1}))})}function s(n){for(var o=n+document.documentElement.clientHeight/4,t,e=a.length-1;e>=0;e--)if(a[e].offsetTop<o){t=a[e];break}var i=t&&t.getAttribute("secid");i!==r&&(r&&l(r,!1),i&&l(i,!0),r=i)}function l(n,o){document.getElementById("_sidebar_"+n).className=o?"viewing":"";for(var t=n.split(".");t.length;){var e=document.getElementById("_toggle_"+t.join("."));e&&(e.checked=o),t.pop()}}s(window.scrollY);})();</script>
<script>(function(){var n=document.getElementsByTagName("style")[0].sheet,e;function u(){e&&(n.deleteRule(e),e=void 0)}function d(t){u(),e=n.insertRule('*[data-name="'+t+'"] { background: rgba(230,215,0,0.12); }',n.cssRules.length)}document.documentElement.addEventListener("mouseover",function(t){var a=t.target.attributes["data-name"];a&&d(a.value)});document.documentElement.addEventListener("mouseout",u);})();</script>
<script>(function(){var R="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",o,p,r,g;document.addEventListener("selectionchange",E);window.addEventListener("resize",C);window.addEventListener("hashchange",x);window.addEventListener("load",x);function S(n){y(new URL(n.target.href))}function x(){y(window.location)}function y(n){var e=n.hash.match(/^#sel-([A-Za-z0-9-_]+)$/);if(!!e){g=e[1],r=k(g);var t=r.getBoundingClientRect(),d=Math.max(20,Math.floor((window.innerHeight-t.height)*.4));window.scrollTo(0,window.scrollY+t.y-d);var c=document.getSelection();c.empty(),c.addRange(r),C()}}function E(n){var e=document.getSelection();if(e.isCollapsed)o&&(o.parentNode.removeChild(o),o=null);else{var t=e.getRangeAt(0);(!r||t.compareBoundaryPoints(Range.START_TO_START,r)!==0||t.compareBoundaryPoints(Range.END_TO_END,r)!==0)&&(r=t,g=B(r),C())}}function C(){if(!!r){p||(p=document.getElementsByTagName("article")[0]),o||(o=document.createElement("a"),document.body.appendChild(o)),o.href="#sel-"+g,o.onclick=S,o.className=r.isOutdated?"outdated-selection-link":"selection-link",o.innerText=r.isOutdated?"!":"\u201F";var n=window.innerWidth<720,e=r.getBoundingClientRect();if(n)o.style.left=Math.floor(e.x+e.width/2+window.scrollX-13)+"px",o.style.top=Math.floor(e.bottom+window.scrollY+10)+"px";else{var t=p.getBoundingClientRect().x;o.style.left=Math.floor(t+window.scrollX-37)+"px",o.style.top=Math.floor(e.y+window.scrollY-3)+"px"}}}function B(n){var e="",t=N(n.startContainer),d=N(n.endContainer),c=M(t,d);return l(c),l(t.slice(c.length).concat(n.startOffset)),l(d.slice(c.length).concat(n.endOffset)),i(L(n.toString())),e;function i(a){do e+=R[a&31|(a>31?32:0)],a>>=5;while(a>0)}function l(a){i(a.length);for(var h=0;h<a.length;h++)i(a[h])}}function k(n){for(var e=new Array(64),t=0;t<64;t++)e[R.charCodeAt(t)]=t;var d=0,c=m(),i=m(),l=m(),a=w(),h=i.pop(),P=O(c.concat(i)),T=l.pop(),A=O(c.concat(l)),u=document.createRange();return u.setStart(P,h),u.setEnd(A,T),u.isOutdated=a!==void 0&&a!==L(u.toString()),u;function w(){for(var s=0,v=0;d<n.length;){var f=e[n.charCodeAt(d++)];if(s|=(f&31)<<v,v+=5,f<32)return s}}function m(){var s=w();if(s!=null){for(var v=new Array(s),f=0;f<s;f++)v[f]=w();return v}}}function N(n){for(var e=[];n!=document.body;){var t=n.parentNode;e.push(Array.prototype.indexOf.call(t.childNodes,n)),n=t}return e.reverse()}function O(n){for(var e=document.body,t=0;t<n.length&&e;t++)e=e.childNodes[n[t]];return e}function M(n,e){for(var t=0;t<n.length&&t<e.length&&n[t]===e[t];)t++;return n.slice(0,t)}function L(n){for(var e=2166136261,t=0;t<n.length;++t)e^=n.charCodeAt(t),e+=(e<<1)+(e<<4)+(e<<7)+(e<<8)+(e<<24);return(e>>15^e)&32767}})();</script>
</head>
<body><article>
<header>
<h1>GROQ</h1>
<section id="intro">
<p><em>Current Working Draft</em></p>
<p>This is the specification for GROQ (<strong>G</strong>raph-<strong>R</strong>elational <strong>O</strong>bject <strong>Q</strong>ueries), a query language and execution engine made at Sanity, Inc, for filtering and projecting JSON documents. The work started in 2015. The development of this open standard started in 2019.</p>
<p>GROQ is authored by <a href="https://twitter.com/purefiction">Alexander Staubo</a> and <a href="https://twitter.com/svale">Simen Svale Skogsrud</a>. Additional follow up work by <a href="https://twitter.com/erikgrinaker">Erik Grinaker</a>, <a href="https://twitter.com/judofyr">Magnus Holm</a>, <a href="https://github.com/j33ty">Radhe</a>, and <a href="https://github.com/israelroldan">Israel Roldan</a>.</p>
<p>This specification should be considered <em>work in progress</em> until the first release.</p>
<section id="sec-Copyright-notice" class="subsec">
<h6><a href="#sec-Copyright-notice" title="link to this subsection">Copyright notice</a></h6>
<p>Copyright ¬© 2015&ndash;present, Sanity, Inc.</p>
<p>As of July 9, 2010, the following persons or entities have made this Specification available under the Open Web Foundation Final Specification Agreement (OWFa 1.0), which is available at <a href="http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0">openwebfoundation.org</a>.</p>
<ul>
<li>Sanity, Inc.</li>
</ul>
<p>You can review the signed copies of the Open Web Foundation Final Specification Agreement Version 1.0 for this specification at <a href="https://github.com/sanity-io/GROQ">github.com/sanity-io/GROQ</a>, which may also include additional parties to those listed above.</p>
<p>Your use of this Specification may be subject to other third party rights. THIS SPECIFICATION IS PROVIDED &ldquo;AS IS.&rdquo; The contributors expressly disclaim any warranties (express, implied, or otherwise), including implied warranties of merchantability, non‚Äêinfringement, fitness for a particular purpose, or title, related to the Specification. The entire risk as to implementing or otherwise using the Specification is assumed by the Specification implementer and user. IN NO EVENT WILL ANY PARTY BE LIABLE TO ANY OTHER PARTY FOR LOST PROFITS OR ANY FORM OF INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES OF ANY CHARACTER FROM ANY CAUSES OF ACTION OF ANY KIND WITH RESPECT TO THIS SPECIFICATION OR ITS GOVERNING AGREEMENT, WHETHER BASED ON BREACH OF CONTRACT, TORT (INCLUDING NEGLIGENCE), OR OTHERWISE, AND WHETHER OR NOT THE OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
</section>
<section id="sec-Conformance" class="subsec">
<h6><a href="#sec-Conformance" title="link to this subsection">Conformance</a></h6>
<p>A conforming implementation of GROQ must fulfill all normative requirements. Conformance requirements are described in this document via both descriptive assertions and key words with clearly defined meanings.</p>
<p>The key words &ldquo;MUST&rdquo;, &ldquo;MUST NOT&rdquo;, &ldquo;REQUIRED&rdquo;, &ldquo;SHALL&rdquo;, &ldquo;SHALL NOT&rdquo;, &ldquo;SHOULD&rdquo;, &ldquo;SHOULD NOT&rdquo;, &ldquo;RECOMMENDED&rdquo;, &ldquo;MAY&rdquo;, and &ldquo;OPTIONAL&rdquo; in the normative portions of this document are to be interpreted as described in <a href="https://tools.ietf.org/html/rfc2119">IETF RFC 2119</a>. These key words may appear in lowercase and still retain their meaning unless explicitly declared as non‚Äênormative.</p>
<p>A conforming implementation of GROQ may provide additional functionality, but must not where explicitly disallowed or would otherwise result in non‚Äêconformance.</p>
</section>
<section id="sec-Conforming-Algorithms" class="subsec">
<h6><a href="#sec-Conforming-Algorithms" title="link to this subsection">Conforming Algorithms</a></h6>
<p>Algorithm steps phrased in imperative grammar (e.g. &ldquo;Return the result&rdquo;) are to be interpreted with the same level of requirement as the algorithm it is contained within. Any algorithm referenced within an algorithm step (e.g. &ldquo;Let completedResult be the result of calling CompleteValue()&rdquo;) is to be interpreted as having at least the same level of requirement as the algorithm containing that step.</p>
<p>Conformance requirements expressed as algorithms can be fulfilled by an implementation of this specification in any way as long as the perceived result is equivalent. Algorithms described in this document are written to be easy to understand. Implementers are encouraged to include equivalent but optimized implementations.</p>
</section>
</section>
<nav class="spec-toc">
<div class="title">Contents</div>
<ol>
<li><a href="#sec-undefined.Overview"><span class="spec-secid">1</span>Overview</a></li>
<li><a href="#sec-Syntax"><span class="spec-secid">2</span>Syntax</a><ol>
<li><a href="#sec-JSON-Superset"><span class="spec-secid">2.1</span>JSON Superset</a></li>
<li><a href="#sec-White-Space"><span class="spec-secid">2.2</span>White Space</a></li>
<li><a href="#sec-Comments"><span class="spec-secid">2.3</span>Comments</a></li>
<li><a href="#sec-Identifier"><span class="spec-secid">2.4</span>Identifier</a></li>
<li><a href="#sec-Digits"><span class="spec-secid">2.5</span>Digits</a></li>
<li><a href="#sec-Expression"><span class="spec-secid">2.6</span>Expression</a></li>
</ol>
</li>
<li><a href="#sec-Execution"><span class="spec-secid">3</span>Execution</a><ol>
<li><a href="#sec-Execution.Overview"><span class="spec-secid">3.1</span>Overview</a></li>
<li><a href="#sec-Query-context"><span class="spec-secid">3.2</span>Query context</a></li>
<li><a href="#sec-Scope"><span class="spec-secid">3.3</span>Scope</a></li>
<li><a href="#sec-Expression-validation"><span class="spec-secid">3.4</span>Expression validation</a></li>
<li><a href="#sec-Expression-evaluation"><span class="spec-secid">3.5</span>Expression evaluation</a></li>
<li><a href="#sec-Constant-expression-evaluation"><span class="spec-secid">3.6</span>Constant expression evaluation</a></li>
<li><a href="#sec-Score-evaluation"><span class="spec-secid">3.7</span>Score evaluation</a></li>
<li><a href="#sec-Query-execution"><span class="spec-secid">3.8</span>Query execution</a></li>
</ol>
</li>
<li><a href="#sec-Data-types"><span class="spec-secid">4</span>Data types</a><ol>
<li><a href="#sec-Null"><span class="spec-secid">4.1</span>Null</a></li>
<li><a href="#sec-Boolean"><span class="spec-secid">4.2</span>Boolean</a></li>
<li><a href="#sec-Number"><span class="spec-secid">4.3</span>Number</a></li>
<li><a href="#sec-String"><span class="spec-secid">4.4</span>String</a></li>
<li><a href="#sec-Array"><span class="spec-secid">4.5</span>Array</a></li>
<li><a href="#sec-Object"><span class="spec-secid">4.6</span>Object</a></li>
<li><a href="#sec-Pair"><span class="spec-secid">4.7</span>Pair</a></li>
<li><a href="#sec-Range"><span class="spec-secid">4.8</span>Range</a></li>
<li><a href="#sec-Datetime"><span class="spec-secid">4.9</span>Datetime</a></li>
</ol>
</li>
<li><a href="#sec-Equality-and-comparison"><span class="spec-secid">5</span>Equality and comparison</a><ol>
<li><a href="#sec-Equality"><span class="spec-secid">5.1</span>Equality</a></li>
<li><a href="#sec-Partial-comparison"><span class="spec-secid">5.2</span>Partial comparison</a></li>
<li><a href="#sec-Total-comparison"><span class="spec-secid">5.3</span>Total comparison</a></li>
</ol>
</li>
<li><a href="#sec-Simple-expressions"><span class="spec-secid">6</span>Simple expressions</a><ol>
<li><a href="#sec-This-expression"><span class="spec-secid">6.1</span>This expression</a></li>
<li><a href="#sec-This-attribute-expression"><span class="spec-secid">6.2</span>This attribute expression</a></li>
<li><a href="#sec-Everything-expression"><span class="spec-secid">6.3</span>Everything expression</a></li>
<li><a href="#sec-Parent-expression"><span class="spec-secid">6.4</span>Parent expression</a></li>
<li><a href="#sec-Function-call-expression"><span class="spec-secid">6.5</span>Function call expression</a></li>
</ol>
</li>
<li><a href="#sec-Compound-expressions"><span class="spec-secid">7</span>Compound expressions</a><ol>
<li><a href="#sec-Parenthesis-expression"><span class="spec-secid">7.1</span>Parenthesis expression</a></li>
<li><a href="#sec-Attribute-access-expression"><span class="spec-secid">7.2</span>Attribute access expression</a></li>
<li><a href="#sec-Element-access-expression"><span class="spec-secid">7.3</span>Element access expression</a></li>
<li><a href="#sec-Slice-expression"><span class="spec-secid">7.4</span>Slice expression</a></li>
<li><a href="#sec-Filter-expression"><span class="spec-secid">7.5</span>Filter expression</a></li>
<li><a href="#sec-Projection-expression"><span class="spec-secid">7.6</span>Projection expression</a></li>
<li><a href="#sec-Pipe-function-call-expression"><span class="spec-secid">7.7</span>Pipe function call expression</a></li>
<li><a href="#sec-Disambiguating-square-backet-expressions"><span class="spec-secid">7.8</span>Disambiguating square backet expressions</a></li>
</ol>
</li>
<li><a href="#sec-Operators"><span class="spec-secid">8</span>Operators</a><ol>
<li><a href="#sec-And-operator"><span class="spec-secid">8.1</span>And operator</a></li>
<li><a href="#sec-Or-operator"><span class="spec-secid">8.2</span>Or operator</a></li>
<li><a href="#sec-Not-operator"><span class="spec-secid">8.3</span>Not operator</a></li>
<li><a href="#sec-Equality-operators"><span class="spec-secid">8.4</span>Equality operators</a></li>
<li><a href="#sec-Comparison-operators"><span class="spec-secid">8.5</span>Comparison operators</a></li>
<li><a href="#sec-In-operator"><span class="spec-secid">8.6</span>In operator</a></li>
<li><a href="#sec-Match-operator"><span class="spec-secid">8.7</span>Match operator</a></li>
<li><a href="#sec-Asc-operator"><span class="spec-secid">8.8</span>Asc operator</a></li>
<li><a href="#sec-Desc-operator"><span class="spec-secid">8.9</span>Desc operator</a></li>
<li><a href="#sec-Unary-plus-operator"><span class="spec-secid">8.10</span>Unary plus operator</a></li>
<li><a href="#sec-Unary-minus-operator"><span class="spec-secid">8.11</span>Unary minus operator</a></li>
<li><a href="#sec-Binary-plus-operator"><span class="spec-secid">8.12</span>Binary plus operator</a></li>
<li><a href="#sec-Binary-minus-operator"><span class="spec-secid">8.13</span>Binary minus operator</a></li>
<li><a href="#sec-Binary-star-operator"><span class="spec-secid">8.14</span>Binary star operator</a></li>
<li><a href="#sec-Binary-slash-operator"><span class="spec-secid">8.15</span>Binary slash operator</a></li>
<li><a href="#sec-Binary-percent-operator"><span class="spec-secid">8.16</span>Binary percent operator</a></li>
<li><a href="#sec-Binary-double-star-operator"><span class="spec-secid">8.17</span>Binary double star operator</a></li>
<li><a href="#sec-Dereference-operator"><span class="spec-secid">8.18</span>Dereference operator</a></li>
</ol>
</li>
<li><a href="#sec-Precedence-and-associativity"><span class="spec-secid">9</span>Precedence and associativity</a></li>
<li><a href="#sec-Functions"><span class="spec-secid">10</span>Functions</a></li>
<li><a href="#sec-Namespaces"><span class="spec-secid">11</span>Namespaces</a><ol>
<li><a href="#sec-Global-namespace"><span class="spec-secid">11.1</span>Global namespace</a><ol>
<li><a href="#sec-global-coalesce-"><span class="spec-secid">11.1.1</span>global::coalesce()</a></li>
<li><a href="#sec-global-count-"><span class="spec-secid">11.1.2</span>global::count()</a></li>
<li><a href="#sec-global-dateTime-"><span class="spec-secid">11.1.3</span>global::dateTime()</a></li>
<li><a href="#sec-global-defined-"><span class="spec-secid">11.1.4</span>global::defined()</a></li>
<li><a href="#sec-global-length-"><span class="spec-secid">11.1.5</span>global::length()</a></li>
<li><a href="#sec-global-references-"><span class="spec-secid">11.1.6</span>global::references()</a></li>
<li><a href="#sec-global-round-"><span class="spec-secid">11.1.7</span>global::round()</a></li>
<li><a href="#sec-global-select-"><span class="spec-secid">11.1.8</span>global::select()</a></li>
<li><a href="#sec-global-string-"><span class="spec-secid">11.1.9</span>global::string()</a></li>
<li><a href="#sec-global-boost-"><span class="spec-secid">11.1.10</span>global::boost()</a></li>
<li><a href="#sec-global-lower-"><span class="spec-secid">11.1.11</span>global::lower()</a></li>
<li><a href="#sec-global-upper-"><span class="spec-secid">11.1.12</span>global::upper()</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#sec-Pipe-functions"><span class="spec-secid">12</span>Pipe functions</a><ol>
<li><a href="#sec-global-order-"><span class="spec-secid">12.1</span>global::order()</a></li>
<li><a href="#sec-global-score-"><span class="spec-secid">12.2</span>global::score()</a></li>
</ol>
</li>
<li><a href="#sec-Vendor-functions"><span class="spec-secid">13</span>Vendor functions</a><ol>
<li><a href="#sec-global-identity-"><span class="spec-secid">13.1</span>global::identity()</a></li>
<li><a href="#sec-global-path-"><span class="spec-secid">13.2</span>global::path()</a></li>
</ol>
</li>
<li><a href="#sec-Extensions"><span class="spec-secid">14</span>Extensions</a><ol>
<li><a href="#sec-Portable-Text-Extension"><span class="spec-secid">14.1</span>Portable Text Extension</a><ol>
<li><a href="#sec-pt-type"><span class="spec-secid">14.1.1</span>pt type</a></li>
<li><a href="#sec-global-pt-"><span class="spec-secid">14.1.2</span>global::pt()</a></li>
<li><a href="#sec-pt-text-"><span class="spec-secid">14.1.3</span>pt::text()</a></li>
</ol>
</li>
<li><a href="#sec-Geography-Extension"><span class="spec-secid">14.2</span>Geography Extension</a><ol>
<li><a href="#sec-geo-type"><span class="spec-secid">14.2.1</span>geo type</a></li>
<li><a href="#sec-global-geo-"><span class="spec-secid">14.2.2</span>global::geo()</a></li>
<li><a href="#sec-geo-contains-"><span class="spec-secid">14.2.3</span>geo::contains()</a></li>
<li><a href="#sec-geo-intersects-"><span class="spec-secid">14.2.4</span>geo::intersects()</a></li>
<li><a href="#sec-geo-distance-"><span class="spec-secid">14.2.5</span>geo::distance()</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#index"><span class="spec-secid">¬ß</span>Index</a></li>
</ol>
</nav>
</header>
<section id="sec-undefined.Overview" secid="1">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-undefined.Overview">1</a></span>Overview</h1>
<p>GROQ (Graph-Relational Object Queries) is a declarative language designed to query collections of largely schema-less JSON documents. Its primary design goals are expressive filtering, joining of several documents into a single response, and shaping the response to fit the client application.</p>
<p>The idea behind GROQ is to be able to describe exactly what information your application needs, potentially joining together information from several sets of documents, then stitching together a very specific response with only the exact fields you need.</p>
<p>A query in GROQ typically starts with¬†<code>*</code>. This asterisk represents every document in your dataset. It is typically followed by a¬†<var data-name="filter">filter</var>¬†in brackets. The <var data-name="filter">filter</var> take <var data-name="terms">terms</var>, <var data-name="operators">operators</var> and <var data-name="functions">functions</var>. A <var data-name="projection">projection</var><em> </em>is wrapped in curly braces and describe the data as we want it returned. </p>
<p>Given these JSON documents:</p>
<pre data-language="json"><code><span class="token punctuation">{</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Peter"</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Gamora"</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Drax"</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Groot"</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Rocket"</span><span class="token punctuation">}</span>
</code></pre>
<p>The following query:</p>
<pre data-language="groq"><code>*[id &gt; 2]{name}
</code></pre>
<p>Will result in the following JSON document:</p>
<pre data-language="json"><code><span class="token punctuation">[</span>
  <span class="token punctuation">{</span> <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Drax"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Groot"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Rocket"</span><span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre>
</section>
<section id="sec-Syntax" secid="2">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Syntax">2</a></span>Syntax</h1>
<p>A GROQ query is a string consisting of Unicode characters. The encoding of the query string is implementation-defined, but UTF-8 is the preferred choice. A query consist of a single <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>, with <span class="spec-nt"><a href="#WhiteSpace" data-name="WhiteSpace">WhiteSpace</a></span> and <span class="spec-nt"><a href="#Comment" data-name="Comment">Comment</a></span> allowed anywhere with no effect on the interpretation.</p>
<div class="spec-production" id="SourceCharacter">
<span class="spec-nt"><a href="#SourceCharacter" data-name="SourceCharacter">SourceCharacter</a></span><div class="spec-rhs"><span class="spec-prose">any Unicode character</span></div>
</div>
<section id="sec-JSON-Superset" secid="2.1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-JSON-Superset">2.1</a></span>JSON Superset</h2>
<p>GROQ&rsquo;s syntax is a superset of JSON, so any valid JSON value is a valid GROQ expression (that simply returns the given value). Below are a few examples of JSON values:</p>
<pre><code>"Hi! üëã"
</code></pre>
<pre data-language="javascript"><code><span class="token punctuation">[</span><span class="token string">"An"</span><span class="token punctuation">,</span> <span class="token string">"array"</span><span class="token punctuation">,</span> <span class="token string">"of"</span><span class="token punctuation">,</span> <span class="token string">"strings"</span><span class="token punctuation">]</span>
</code></pre>
<pre data-language="json"><code><span class="token punctuation">{</span>
  <span class="token property">"array"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"string"</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token null keyword">null</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">"boolean"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token property">"number"</span><span class="token operator">:</span> <span class="token number">3.14</span><span class="token punctuation">,</span>
  <span class="token property">"null"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>
  <span class="token property">"object"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token property">"key"</span><span class="token operator">:</span> <span class="token string">"value"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"string"</span><span class="token operator">:</span> <span class="token string">"Hi! üëã"</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec-White-Space" secid="2.2">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-White-Space">2.2</a></span>White Space</h2>
<p>Whitespace is not significant in GROQ, except for acting as a token separator and comment terminator. Any sequence of the following characters is considered whitespace.</p>
<div class="spec-production" id="WhiteSpace">
<span class="spec-nt"><a href="#WhiteSpace" data-name="WhiteSpace">WhiteSpace</a></span><div class="spec-rhs"><span class="spec-prose">Tab U+0009</span></div>
<div class="spec-rhs"><span class="spec-prose">Newline U+000A</span></div>
<div class="spec-rhs"><span class="spec-prose">Vertical tab U+000B</span></div>
<div class="spec-rhs"><span class="spec-prose">Form feed U+000C</span></div>
<div class="spec-rhs"><span class="spec-prose">Carriage return U+000D</span></div>
<div class="spec-rhs"><span class="spec-prose">Space U+0020</span></div>
<div class="spec-rhs"><span class="spec-prose">Next line U+0085</span></div>
<div class="spec-rhs"><span class="spec-prose">Non-breaking space U+00A0</span></div>
</div>
<p>Whitespace inside a string literal is interpreted as-is.</p>
</section>
<section id="sec-Comments" secid="2.3">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Comments">2.3</a></span>Comments</h2>
<div class="spec-production" id="Comment">
<span class="spec-nt"><a href="#Comment" data-name="Comment">Comment</a></span><div class="spec-rhs"><span class="spec-rx">//</span><span class="spec-quantified"><span class="spec-nt"><a href="#CommentChar" data-name="CommentChar">CommentChar</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span><span class="spec-quantifier optional">opt</span></span></span></div>
</div>
<div class="spec-production" id="CommentChar">
<span class="spec-nt"><a href="#CommentChar" data-name="CommentChar">CommentChar</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#SourceCharacter" data-name="SourceCharacter">SourceCharacter</a></span><span class="spec-butnot"><span class="spec-prose">Newline U+000A</span></span></span></div>
</div>
<p>Comments serve as query documentation, and are ignored by the parser. They start with <code>//</code> and run to the end of the line:</p>
<pre><code>{ 
  // Comments can be on a separate line 
  "key": "value" // Or at the end of a line 
}
</code></pre>
<p>Comments cannot start inside a string literal.</p>
<pre><code>{ 
  "key // This isn't a comment": "value"
}
</code></pre>
</section>
<section id="sec-Identifier" secid="2.4">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Identifier">2.4</a></span>Identifier</h2>
<p>Identifiers are used to name entities such as parameters, attributes and functions. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter.</p>
<div class="spec-production" id="Identifier">
<span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span><div class="spec-rhs"><span class="spec-rx">/[A-Za-z_][A-Za-z_0-9]*/</span></div>
</div>
</section>
<section id="sec-Digits" secid="2.5">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Digits">2.5</a></span>Digits</h2>
<p>GROQ uses decimal digits (0-9) and hexadecimal digits (0-9, a-f) in various places.</p>
<div class="spec-production" id="Digit">
<span class="spec-nt"><a href="#Digit" data-name="Digit">Digit</a></span><div class="spec-oneof"><div class="spec-oneof-grid"><table>
<tr>
<td class="spec-rhs"><span class="spec-t">0</span></td><td class="spec-rhs"><span class="spec-t">1</span></td><td class="spec-rhs"><span class="spec-t">2</span></td><td class="spec-rhs"><span class="spec-t">3</span></td><td class="spec-rhs"><span class="spec-t">4</span></td><td class="spec-rhs"><span class="spec-t">5</span></td><td class="spec-rhs"><span class="spec-t">6</span></td><td class="spec-rhs"><span class="spec-t">7</span></td><td class="spec-rhs"><span class="spec-t">8</span></td><td class="spec-rhs"><span class="spec-t">9</span></td></tr>
</table></div></div>
</div>
<div class="spec-production" id="HexDigit">
<span class="spec-nt"><a href="#HexDigit" data-name="HexDigit">HexDigit</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Digit" data-name="Digit">Digit</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#HexDigit" data-name="HexDigit">HexDigit</a></span></div>
</div>
<div class="spec-production" id="HexLetter">
<span class="spec-nt"><a href="#HexLetter" data-name="HexLetter">HexLetter</a></span><div class="spec-oneof"><div class="spec-oneof-grid"><table>
<tr>
<td class="spec-rhs"><span class="spec-t">a</span></td><td class="spec-rhs"><span class="spec-t">A</span></td><td class="spec-rhs"><span class="spec-t">b</span></td><td class="spec-rhs"><span class="spec-t">B</span></td><td class="spec-rhs"><span class="spec-t">c</span></td><td class="spec-rhs"><span class="spec-t">C</span></td><td class="spec-rhs"><span class="spec-t">d</span></td><td class="spec-rhs"><span class="spec-t">D</span></td><td class="spec-rhs"><span class="spec-t">e</span></td><td class="spec-rhs"><span class="spec-t">E</span></td><td class="spec-rhs"><span class="spec-t">f</span></td><td class="spec-rhs"><span class="spec-t">F</span></td></tr>
</table></div></div>
</div>
</section>
<section id="sec-Expression" secid="2.6">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Expression">2.6</a></span>Expression</h2>
<p>An <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> is either a literal (e.g. <code>15</code>), a simple expression (e.g. <code>@</code>), or a compound expression (e.g. <code>*[name == "Michael"]</code>) or an operator call (e.g. <code>name == "Michael"</code>). The syntax and semantics of the different expressions are documented in their respective sections.</p>
<div class="spec-production" id="Expression">
<span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Literal" data-name="Literal">Literal</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#SimpleExpression" data-name="SimpleExpression">SimpleExpression</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#CompoundExpression" data-name="CompoundExpression">CompoundExpression</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#OperatorCall" data-name="OperatorCall">OperatorCall</a></span></div>
</div>
<div class="spec-production" id="Literal">
<span class="spec-nt"><a href="#Literal" data-name="Literal">Literal</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Null" data-name="Null">Null</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Boolean" data-name="Boolean">Boolean</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Number" data-name="Number">Number</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#String" data-name="String">String</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Array" data-name="Array">Array</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Object" data-name="Object">Object</a></span></div>
</div>
<div class="spec-production" id="SimpleExpression">
<span class="spec-nt"><a href="#SimpleExpression" data-name="SimpleExpression">SimpleExpression</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#This" data-name="This">This</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#ThisAttribute" data-name="ThisAttribute">ThisAttribute</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Everything" data-name="Everything">Everything</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Parent" data-name="Parent">Parent</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#FuncCall" data-name="FuncCall">FuncCall</a></span></div>
</div>
<div class="spec-production" id="CompoundExpression">
<span class="spec-nt"><a href="#CompoundExpression" data-name="CompoundExpression">CompoundExpression</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Parenthesis" data-name="Parenthesis">Parenthesis</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#AttributeAccess" data-name="AttributeAccess">AttributeAccess</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#ElementAccess" data-name="ElementAccess">ElementAccess</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Slice" data-name="Slice">Slice</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Filter" data-name="Filter">Filter</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Projection" data-name="Projection">Projection</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#PipeFuncCall" data-name="PipeFuncCall">PipeFuncCall</a></span></div>
</div>
<div class="spec-production" id="OperatorCall">
<span class="spec-nt"><a href="#OperatorCall" data-name="OperatorCall">OperatorCall</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#And" data-name="And">And</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Or" data-name="Or">Or</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Not" data-name="Not">Not</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Equality" data-name="Equality">Equality</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Comparison" data-name="Comparison">Comparison</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#In" data-name="In">In</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Match" data-name="Match">Match</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Asc" data-name="Asc">Asc</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Desc" data-name="Desc">Desc</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#UnaryPlus" data-name="UnaryPlus">UnaryPlus</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#UnaryMinus" data-name="UnaryMinus">UnaryMinus</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Plus" data-name="Plus">Plus</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Minus" data-name="Minus">Minus</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Star" data-name="Star">Star</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Slash" data-name="Slash">Slash</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Percent" data-name="Percent">Percent</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#StarStar" data-name="StarStar">StarStar</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Dereference" data-name="Dereference">Dereference</a></span></div>
</div>
</section>
</section>
<section id="sec-Execution" secid="3">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Execution">3</a></span>Execution</h1>
<section id="sec-Execution.Overview" secid="3.1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Execution.Overview">3.1</a></span>Overview</h2>
<div id="note-28f20" class="spec-note">
<a href="#note-28f20">Note</a>
The following sub-section is a non-normative overview of the execution model. See the rest of the section for the exact semantics.</div>
<p>A GROQ query is executed inside a query context, which contains the dataset and parameters, and returns a result. Typically the result is serialized to JSON. During the execution of a query different parts of the query are evaluated in different scopes. Each scope has a <em>this </em>value and can be nested. Simple attributes like <code>name</code> always refers to an attribute on the <em>this </em>value.</p>
<pre data-language="groq"><code>*[_type == "person"]{name, friends[country == "NO"]}
</code></pre>
<p>In the preceding example we have several scopes:</p>
<ul>
<li>The first filter (<code>[_type == "person"]</code>) creates a new scope for every document in the dataset. An equivalent scope is created inside the projection (<code>{name, ‚Ä¶}</code>).</li>
<li>The country filter (<code>[country == "NO"]</code>) creates a new scope for each element in the <code>friends</code> array.</li>
</ul>
<p>The parent expression (<code>^</code>) let&rsquo;s you refer to parent scopes, and this enables what is typically solved with joins in many databases.</p>
<pre data-language="groq"><code>*[_type == "person"]{
  id,
  name,
  "children": *[_type == "person" &amp;&amp; parentId == ^.id]
}
</code></pre>
<p>While executing the inner filter (<code>[_type == "person" &amp;&amp; parentId == ^.id]</code>) the expression <code>^.id</code> returns the <code>id</code> attribute of the parent scope&rsquo;s <em>this</em> value. The parent scope is here the scope created by the projection (<code>{id, name, ‚Ä¶}</code>).</p>
<p>It&rsquo;s possible for a query to be <em>invalid</em>. This can happen when you e.g. use an unknown function or call a function with incorrect number of arguments.</p>
</section>
<section id="sec-Query-context" secid="3.2">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Query-context">3.2</a></span>Query context</h2>
<p>A query context consists of:</p>
<ul>
<li>the dataset</li>
<li>parameter values (map from <var data-name="string">string</var> to <var data-name="value">value</var>)</li>
</ul>
</section>
<section id="sec-Scope" secid="3.3">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Scope">3.3</a></span>Scope</h2>
<p>A scope consists of:</p>
<ul>
<li>a this value</li>
<li>an optional parent scope</li>
<li>a query context</li>
</ul>
<p>A root scope can be constructed from a query context, and a nested scope can be constructed from an existing scope.</p>
<div class="spec-algo" id="NewNestedScope()">
<span class="spec-call"><a href="#NewNestedScope()" data-name="NewNestedScope">NewNestedScope</a>(<var data-name="value">value</var>, <var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="newScope">newScope</var> be a new scope.</li>
<li>Set the this value of <var data-name="newScope">newScope</var> to <var data-name="value">value</var>.</li>
<li>Set the parent scope of <var data-name="newScope">newScope</var> to <var data-name="scope">scope</var>.</li>
<li>Set the query context of <var data-name="newScope">newScope</var> to the query context of <var data-name="scope">scope</var>.</li>
<li>Return <var data-name="newScope">newScope</var>.</li>
</ol>
</div>
<div class="spec-algo" id="NewRootScope()">
<span class="spec-call"><a href="#NewRootScope()" data-name="NewRootScope">NewRootScope</a>(<var data-name="context">context</var>)</span><ol>
<li>Let <var data-name="newScope">newScope</var> be a new scope.</li>
<li>Set the this value of <var data-name="newScope">newScope</var> to <span class="spec-keyword">null</span>.</li>
<li>Set the parent scope of <var data-name="newScope">newScope</var> to <span class="spec-keyword">null</span>.</li>
<li>Set the query context of <var data-name="newScope">newScope</var> to <var data-name="context">context</var>.</li>
<li>Return <var data-name="newScope">newScope</var>.</li>
</ol>
</div>
</section>
<section id="sec-Expression-validation" secid="3.4">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Expression-validation">3.4</a></span>Expression validation</h2>
<p>An expression can be validated. This will only check that it&rsquo;s on a valid form, and will not execute anything. If an expression type does not have an explicitly defined validator in this specifiction, it has an implicit validator which runs <span class="spec-nt"><span data-name="Validate">Validate</span></span> on all its child expressions.</p>
<div class="spec-algo" id="Validate()">
<span class="spec-call"><a href="#Validate()" data-name="Validate">Validate</a>(<var data-name="expr">expr</var>)</span><ol>
<li>Let <var data-name="validator">validator</var> be the validator of <var data-name="expr">expr</var>.</li>
<li>Execute the <var data-name="validator">validator</var>.</li>
</ol>
</div>
</section>
<section id="sec-Expression-evaluation" secid="3.5">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Expression-evaluation">3.5</a></span>Expression evaluation</h2>
<p>An expression is evaluated in a scope. You must successfully validate an expression before you attempt to evaluate it. Every expression type has their own evaluator function in their respective section in this specification (e.g. the evaluator of <span class="spec-nt"><span data-name="ParenthesisExpression">ParenthesisExpression</span></span> is <span class="spec-call"><a href="#EvaluateParenthesis()" data-name="EvaluateParenthesis">EvaluateParenthesis</a>()</span>).</p>
<div class="spec-algo" id="Evaluate()">
<span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="expr">expr</var>, <var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="evaluator">evaluator</var> be the evaluator of <var data-name="expr">expr</var>.</li>
<li>Return the result of <span class="spec-call"><span data-name="evaluator">evaluator</span>(<var data-name="scope">scope</var>)</span>.</li>
</ol>
</div>
</section>
<section id="sec-Constant-expression-evaluation" secid="3.6">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Constant-expression-evaluation">3.6</a></span>Constant expression evaluation</h2>
<p>Some expressions can be evaluated into a constant value. This is used for validation and to disambiguate between different syntactically ambiguous expressions.</p>
<div class="spec-algo" id="ConstantEvaluate()">
<span class="spec-call"><a href="#ConstantEvaluate()" data-name="ConstantEvaluate">ConstantEvaluate</a>(<var data-name="expr">expr</var>)</span><ol>
<li>If <var data-name="expr">expr</var> is one of: <span class="spec-nt"><a href="#Literal" data-name="Literal">Literal</a></span>, <span class="spec-nt"><a href="#Parenthesis" data-name="Parenthesis">Parenthesis</a></span>, <span class="spec-nt"><a href="#Plus" data-name="Plus">Plus</a></span>, <span class="spec-nt"><a href="#Minus" data-name="Minus">Minus</a></span>, <span class="spec-nt"><a href="#Star" data-name="Star">Star</a></span>, <span class="spec-nt"><a href="#Slash" data-name="Slash">Slash</a></span>, <span class="spec-nt"><a href="#Percent" data-name="Percent">Percent</a></span>, <span class="spec-nt"><a href="#StarStar" data-name="StarStar">StarStar</a></span>, <span class="spec-nt"><a href="#UnaryPlus" data-name="UnaryPlus">UnaryPlus</a></span>, <span class="spec-nt"><a href="#UnaryMinus" data-name="UnaryMinus">UnaryMinus</a></span>.<ol>
<li>Let <var data-name="evaluator">evaluator</var> be the evaluator of <var data-name="expr">expr</var>.</li>
<li>Let <var data-name="result">result</var> be the result of executing <var data-name="evaluator">evaluator</var>, but using <span class="spec-call"><a href="#ConstantEvaluate()" data-name="ConstantEvaluate">ConstantEvaluate</a>()</span> in-place of every <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>()</span>.</li>
<li>Return the <var data-name="result">result</var>.</li>
</ol>
</li>
<li>Otherwise: Report an error.</li>
</ol>
</div>
</section>
<section id="sec-Score-evaluation" secid="3.7">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Score-evaluation">3.7</a></span>Score evaluation</h2>
<p>When evaluating <var data-name="score">score</var>, a predicate returning <code>true</code> should have its score computed as 1.0, and all other values should receive a score of 0.0. All results involved in scoring start with a score of 1.0. The scores are evaluated once per result, and then added together. For example:</p>
<pre data-language="groq"><code>* | score(a &gt; 1)
</code></pre>
<p>should assign a score of 2.0 to any document where <code>a &gt; 1</code>, and a score of 1.0 to any non-matching document.</p>
<p>For logical expressions, the score is the sum of the clauses of the expression evaluates to <code>true</code>, otherwise 0.0. In other words:</p>
<ul>
<li><code>true &amp;&amp; false</code> receives the score 0.0.</li>
<li><code>true &amp;&amp; true</code> receives the score 2.0.</li>
<li><code>true || true</code> receives the score 2.0.</li>
<li><code>true || false</code> receives the score 1.0.</li>
</ul>
<p>The scoring function for <code>match</code> is left as an implementation detail and not covered by this specification. For example, an implementation may choose to use a TF/IDF or similar text scoring function that uses the text corpus and language configuration for the given field to compute a text score.</p>
<p>A boosted predicate simply adds the boost value to the score if the predicate matches. For example, <code>boost(a &gt; 1, 10)</code> would result in a score of 11 for any expression matching <code>a &gt; 1</code>.</p>
</section>
<section id="sec-Query-execution" secid="3.8">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Query-execution">3.8</a></span>Query execution</h2>
<p>To execute a query you must first construct a query context, and then evaluate the query expression inside a root scope.</p>
<div class="spec-algo" id="ExecuteQuery()">
<span class="spec-call"><a href="#ExecuteQuery()" data-name="ExecuteQuery">ExecuteQuery</a>(<var data-name="query">query</var>, <var data-name="context">context</var>)</span><ol>
<li>Let <var data-name="scope">scope</var> be the result of <span class="spec-call"><a href="#NewRootScope()" data-name="NewRootScope">NewRootScope</a>(<var data-name="context">context</var>)</span>.</li>
<li>Let <var data-name="expr">expr</var> be the expression of <var data-name="query">query</var>.</li>
<li>Let <var data-name="result">result</var> be the result of <span class="spec-call"><span data-name="Evalute">Evalute</span>(<var data-name="expr">expr</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Return <var data-name="result">result</var>. </li>
</ol>
</div>
</section>
</section>
<section id="sec-Data-types" secid="4">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Data-types">4</a></span>Data types</h1>
<section id="sec-Null" secid="4.1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Null">4.1</a></span>Null</h2>
<p>An unknown value, expressed as <span class="spec-keyword">null</span>. This follows the SQL definition of null, which differs from the typical definition of &ldquo;no value&rdquo; in programming languages, and implies among other things that <code>1 + null</code> yields <span class="spec-keyword">null</span> (1 plus an unknown number yields an unknown number).</p>
<div class="spec-production" id="Null">
<span class="spec-nt"><a href="#Null" data-name="Null">Null</a></span><div class="spec-rhs"><span class="spec-t">null</span></div>
</div>
</section>
<section id="sec-Boolean" secid="4.2">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Boolean">4.2</a></span>Boolean</h2>
<p>Logical truth values, i.e. <span class="spec-keyword">true</span> and <span class="spec-keyword">false</span>.</p>
<div class="spec-production" id="Boolean">
<span class="spec-nt"><a href="#Boolean" data-name="Boolean">Boolean</a></span><div class="spec-rhs"><span class="spec-t">true</span></div>
<div class="spec-rhs"><span class="spec-t">false</span></div>
</div>
</section>
<section id="sec-Number" secid="4.3">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Number">4.3</a></span>Number</h2>
<p>Signed 64-bit double-precision floating point numbers, e.g. <code>3.14</code>, following the <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">IEEE 754 standard</a>. These have a magnitude of roughly 10‚Åª¬≥‚Å∞‚Å∑ to 10¬≥‚Å∞‚Å∏, and can represent 15 significant figures with exact precision &ndash; beyond this, significant figures are rounded to 53-bit precision. The special IEEE 754 values of <span class="spec-nt"><span data-name="Infinity">Infinity</span></span> and <span class="spec-nt"><span data-name="NaN">NaN</span></span> are not supported, and are coerced to <span class="spec-keyword">null</span>.</p>
<div class="spec-production" id="Number">
<span class="spec-nt"><a href="#Number" data-name="Number">Number</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Integer" data-name="Integer">Integer</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Decimal" data-name="Decimal">Decimal</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#ScientificNotation" data-name="ScientificNotation">ScientificNotation</a></span></div>
</div>
<div class="spec-production" id="Sign">
<span class="spec-nt"><a href="#Sign" data-name="Sign">Sign</a></span><div class="spec-oneof"><div class="spec-oneof-grid"><table>
<tr>
<td class="spec-rhs"><span class="spec-t">+</span></td><td class="spec-rhs"><span class="spec-t">-</span></td></tr>
</table></div></div>
</div>
<div class="spec-production" id="Integer">
<span class="spec-nt"><a href="#Integer" data-name="Integer">Integer</a></span><div class="spec-rhs"><span class="spec-quantified"><span class="spec-nt"><a href="#Sign" data-name="Sign">Sign</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Digit" data-name="Digit">Digit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span></div>
</div>
<div class="spec-production" id="Decimal">
<span class="spec-nt"><a href="#Decimal" data-name="Decimal">Decimal</a></span><div class="spec-rhs"><span class="spec-quantified"><span class="spec-nt"><a href="#Sign" data-name="Sign">Sign</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Digit" data-name="Digit">Digit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-nt"><a href="#Fractional" data-name="Fractional">Fractional</a></span></div>
</div>
<div class="spec-production" id="ScientificNotation">
<span class="spec-nt"><a href="#ScientificNotation" data-name="ScientificNotation">ScientificNotation</a></span><div class="spec-rhs"><span class="spec-quantified"><span class="spec-nt"><a href="#Sign" data-name="Sign">Sign</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Digit" data-name="Digit">Digit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Fractional" data-name="Fractional">Fractional</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-nt"><a href="#ExponentMarker" data-name="ExponentMarker">ExponentMarker</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#Sign" data-name="Sign">Sign</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Digit" data-name="Digit">Digit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span></div>
</div>
<div class="spec-production" id="Fractional">
<span class="spec-nt"><a href="#Fractional" data-name="Fractional">Fractional</a></span><div class="spec-rhs"><span class="spec-t">.</span><span class="spec-quantified"><span class="spec-nt"><a href="#Digit" data-name="Digit">Digit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span></div>
</div>
<div class="spec-production" id="ExponentMarker">
<span class="spec-nt"><a href="#ExponentMarker" data-name="ExponentMarker">ExponentMarker</a></span><div class="spec-oneof"><div class="spec-oneof-grid"><table>
<tr>
<td class="spec-rhs"><span class="spec-t">e</span></td><td class="spec-rhs"><span class="spec-t">E</span></td></tr>
</table></div></div>
</div>
</section>
<section id="sec-String" secid="4.4">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-String">4.4</a></span>String</h2>
<p>A string stores an UTF-8 encoded list of characters.</p>
<p>The syntax of a string literal is a subset of JSON with the following extensions:</p>
<ul>
<li>Any control characters (including newlines) are allowed to appear inside a string.</li>
<li>Extended support for refering to Unicode characters above 16-bit: <code>"\u{1F600}"</code>.</li>
</ul>
<div class="spec-production" id="String">
<span class="spec-nt"><a href="#String" data-name="String">String</a></span><div class="spec-rhs"><span class="spec-t">"</span><span class="spec-quantified"><span class="spec-nt"><a href="#DoubleStringCharacter" data-name="DoubleStringCharacter">DoubleStringCharacter</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span><span class="spec-quantifier optional">opt</span></span></span><span class="spec-t">"</span></div>
<div class="spec-rhs"><span class="spec-t">'</span><span class="spec-quantified"><span class="spec-nt"><a href="#SingleStringCharacter" data-name="SingleStringCharacter">SingleStringCharacter</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span><span class="spec-quantifier optional">opt</span></span></span><span class="spec-t">'</span></div>
</div>
<div class="spec-production" id="DoubleStringCharacter">
<span class="spec-nt"><a href="#DoubleStringCharacter" data-name="DoubleStringCharacter">DoubleStringCharacter</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#SourceCharacter" data-name="SourceCharacter">SourceCharacter</a></span><span class="spec-butnot"><span class="spec-t">"</span><span class="spec-t">\</span></span></span></div>
<div class="spec-rhs"><span class="spec-t">\</span><span class="spec-nt"><a href="#EscapeSequence" data-name="EscapeSequence">EscapeSequence</a></span></div>
</div>
<div class="spec-production" id="SingleStringCharacter">
<span class="spec-nt"><a href="#SingleStringCharacter" data-name="SingleStringCharacter">SingleStringCharacter</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#SourceCharacter" data-name="SourceCharacter">SourceCharacter</a></span><span class="spec-butnot"><span class="spec-t">'</span><span class="spec-t">\</span></span></span></div>
<div class="spec-rhs"><span class="spec-t">\</span><span class="spec-nt"><a href="#EscapeSequence" data-name="EscapeSequence">EscapeSequence</a></span></div>
</div>
<div class="spec-production" id="EscapeSequence">
<span class="spec-nt"><a href="#EscapeSequence" data-name="EscapeSequence">EscapeSequence</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#SingleEscapeSequence" data-name="SingleEscapeSequence">SingleEscapeSequence</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#UnicodeEscapeSequence" data-name="UnicodeEscapeSequence">UnicodeEscapeSequence</a></span></div>
</div>
<div class="spec-production" id="SingleEscapeSequence">
<span class="spec-nt"><a href="#SingleEscapeSequence" data-name="SingleEscapeSequence">SingleEscapeSequence</a></span><div class="spec-oneof"><div class="spec-oneof-grid"><table>
<tr>
<td class="spec-rhs"><span class="spec-t">'</span></td><td class="spec-rhs"><span class="spec-t">"</span></td><td class="spec-rhs"><span class="spec-t">\</span></td><td class="spec-rhs"><span class="spec-t">/</span></td><td class="spec-rhs"><span class="spec-t">b</span></td><td class="spec-rhs"><span class="spec-t">f</span></td><td class="spec-rhs"><span class="spec-t">n</span></td><td class="spec-rhs"><span class="spec-t">r</span></td><td class="spec-rhs"><span class="spec-t">t</span></td></tr>
</table></div></div>
</div>
<div class="spec-production" id="UnicodeEscapeSequence">
<span class="spec-nt"><a href="#UnicodeEscapeSequence" data-name="UnicodeEscapeSequence">UnicodeEscapeSequence</a></span><div class="spec-rhs"><span class="spec-t">u</span><span class="spec-nt"><a href="#HexDigit" data-name="HexDigit">HexDigit</a></span><span class="spec-nt"><a href="#HexDigit" data-name="HexDigit">HexDigit</a></span><span class="spec-nt"><a href="#HexDigit" data-name="HexDigit">HexDigit</a></span><span class="spec-nt"><a href="#HexDigit" data-name="HexDigit">HexDigit</a></span></div>
<div class="spec-rhs"><span class="spec-t">u{</span><span class="spec-quantified"><span class="spec-nt"><a href="#HexDigit" data-name="HexDigit">HexDigit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">}</span></div>
</div>
<p>Escape sequences are interpreted as follows:</p>
<ul>
<li><code>\'</code> represents U+0027.</li>
<li><code>\"</code> represents U+0022.</li>
<li><code>\\</code> represents U+005C.</li>
<li><code>\/</code> represents U+002F.</li>
<li><code>\b</code> represents U+0008.</li>
<li><code>\f</code> represents U+000C.</li>
<li><code>\n</code> represents U+000A.</li>
<li><code>\r</code> represents U+000D.</li>
<li><code>\t</code> represents U+0009.</li>
<li><code>\uXXXX</code> represents the Unicode code point U+XXXX.</li>
<li><code>\uXXXX\uYYYY</code>, where XXXX is a high surrogate (W1, 0xD800&ndash;0xDBFF) and YYYY is a low surrogate (W2, 0xDC00&ndash;0xDFFF) is interpreted as a UTF-16 surrogate pair and encoded into a single code point.</li>
</ul>
<p>It&rsquo;s a syntactical error when a Unicode escape sequence represents an invalid Unicode code point.</p>
</section>
<section id="sec-Array" secid="4.5">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Array">4.5</a></span>Array</h2>
<p>An ordered collection of values, e.g. <code>[1, 2, 3]</code>. Can contain any combination of other types, including other arrays and mixed types. An element inside an array literal can be preceeded by <code>...</code> which causes it to be flattened into the array.</p>
<div class="spec-production" id="Array">
<span class="spec-nt"><a href="#Array" data-name="Array">Array</a></span><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-quantified"><span class="spec-nt"><a href="#ArrayElements" data-name="ArrayElements">ArrayElements</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-t">,</span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-t">]</span></div>
</div>
<div class="spec-production" id="ArrayElements">
<span class="spec-nt"><a href="#ArrayElements" data-name="ArrayElements">ArrayElements</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#ArrayElement" data-name="ArrayElement">ArrayElement</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#ArrayElements" data-name="ArrayElements">ArrayElements</a></span><span class="spec-t">,</span><span class="spec-nt"><a href="#ArrayElement" data-name="ArrayElement">ArrayElement</a></span></div>
</div>
<div class="spec-production" id="ArrayElement">
<span class="spec-nt"><a href="#ArrayElement" data-name="ArrayElement">ArrayElement</a></span><div class="spec-rhs"><span class="spec-quantified"><span class="spec-t">...</span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateArray()">
<span class="spec-call"><a href="#EvaluateArray()" data-name="EvaluateArray">EvaluateArray</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="result">result</var> be a new empty array.</li>
<li>For each <span class="spec-nt"><a href="#ArrayElement" data-name="ArrayElement">ArrayElement</a></span>:<ol>
<li>Let <var data-name="elementNode">elementNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> of the <span class="spec-nt"><a href="#ArrayElement" data-name="ArrayElement">ArrayElement</a></span>.</li>
<li>Let <var data-name="element">element</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="elementNode">elementNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If the <span class="spec-nt"><a href="#ArrayElement" data-name="ArrayElement">ArrayElement</a></span> contains <span class="spec-t">...</span>:<ol>
<li>If <var data-name="element">element</var> is an array:<ol>
<li>Concatenate <var data-name="element">element</var> to <var data-name="result">result</var>.</li>
</ol>
</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Append <var data-name="element">element</var> to <var data-name="result">result</var>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
</section>
<section id="sec-Object" secid="4.6">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Object">4.6</a></span>Object</h2>
<p>An unordered collection of key/value pairs (referred to as attributes) with unique keys, e.g. <code>{"a": 1, "b": 2}</code>. Keys must be strings, while values can be any combination of other types, including other objects. If duplicate keys are specified, the last key is used.</p>
<p>The values of an object literal can use the full power of expressions:</p>
<pre><code>*[_type == "rect"]{"area": width * height}
</code></pre>
<div id="note-bb598" class="spec-note">
<a href="#note-bb598">Note</a>
A <span class="spec-nt"><a href="#Projection" data-name="Projection">Projection</a></span> expression is just an expression with an object literal to the right of it.</div>
<p>Object literal supports syntactical sugar when the attribute name and value is equivalent:</p>
<pre><code>// These two are equivalent
*[_type == "person"]{name}
*[_type == "person"]{"name": name}
</code></pre>
<div class="spec-production" id="Object">
<span class="spec-nt"><a href="#Object" data-name="Object">Object</a></span><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-quantified"><span class="spec-nt"><a href="#ObjectAttributes" data-name="ObjectAttributes">ObjectAttributes</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-t">,</span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-t">}</span></div>
</div>
<div class="spec-production" id="ObjectAttributes">
<span class="spec-nt"><a href="#ObjectAttributes" data-name="ObjectAttributes">ObjectAttributes</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#ObjectAttributes" data-name="ObjectAttributes">ObjectAttributes</a></span><span class="spec-t">,</span><span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span></div>
</div>
<div class="spec-production" id="ObjectAttribute">
<span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#String" data-name="String">String</a></span><span class="spec-t">:</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
<div class="spec-rhs"><span class="spec-t">...</span><span class="spec-quantified"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span></div>
</div>
<div class="spec-algo" id="EvaluateObject()">
<span class="spec-call"><a href="#EvaluateObject()" data-name="EvaluateObject">EvaluateObject</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="result">result</var> be a new empty object.</li>
<li>For each <span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span>:<ol>
<li>If the <span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span> contains <code>...</code>:<ol>
<li>If the <span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span> constains an <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>:<ol>
<li>Let <var data-name="baseNode">baseNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
</ol>
</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Let <var data-name="base">base</var> be the this value of <var data-name="scope">scope</var>.</li>
</ol>
</li>
<li>For each <var data-name="name">name</var> and <var data-name="value">value</var> of <var data-name="base">base</var>:<ol>
<li>Set the attribute <var data-name="name">name</var> to <var data-name="value">value</var> in <var data-name="result">result</var>.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Let <var data-name="valueNode">valueNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> of the <span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span>.</li>
<li>Let <var data-name="value">value</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="valueNode">valueNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If the <span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span> contains a <span class="spec-nt"><a href="#String" data-name="String">String</a></span>:<ol>
<li>Let <var data-name="name">name</var> be the string value of the <span class="spec-nt"><a href="#String" data-name="String">String</a></span>.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Let <var data-name="name">name</var> be the result of <span class="spec-call"><a href="#DetermineName()" data-name="DetermineName">DetermineName</a>(<var data-name="valueNode">valueNode</var>)</span>.</li>
</ol>
</li>
<li>Set the attribute <var data-name="name">name</var> to <var data-name="value">value</var> in <var data-name="result">result</var>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
<div class="spec-algo" id="DetermineName()">
<span class="spec-call"><a href="#DetermineName()" data-name="DetermineName">DetermineName</a>(<var data-name="node">node</var>)</span><ol>
<li>If <var data-name="node">node</var> is an <span class="spec-nt"><a href="#ThisAttribute" data-name="ThisAttribute">ThisAttribute</a></span>:<ol>
<li>Return the string value of the <span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span> of <var data-name="node">node</var>.</li>
</ol>
</li>
<li>If <var data-name="node">node</var> is a <span class="spec-nt"><a href="#Projection" data-name="Projection">Projection</a></span>, <span class="spec-nt"><a href="#ElementAccess" data-name="ElementAccess">ElementAccess</a></span>, <span class="spec-nt"><a href="#Slice" data-name="Slice">Slice</a></span>, or <span class="spec-nt"><a href="#Filter" data-name="Filter">Filter</a></span>:<ol>
<li>Let <var data-name="base">base</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> of <var data-name="expr">expr</var>.</li>
<li>Return the result of <span class="spec-call"><a href="#DetermineName()" data-name="DetermineName">DetermineName</a>(<var data-name="base">base</var>)</span>.</li>
</ol>
</li>
</ol>
</div>
<div class="spec-algo" id="ValidateObject()">
<span class="spec-call"><a href="#ValidateObject()" data-name="ValidateObject">ValidateObject</a>()</span><ol>
<li>For each <span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span>:<ol>
<li>If the <span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span> does not contain a <span class="spec-nt"><a href="#String" data-name="String">String</a></span>:<ol>
<li>Let <var data-name="expr">expr</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
</ol>
</li>
<li>Execute <span class="spec-call"><a href="#ValidateObjectAttribute()" data-name="ValidateObjectAttribute">ValidateObjectAttribute</a>(<var data-name="expr">expr</var>)</span>.</li>
</ol>
</li>
</ol>
</div>
<div class="spec-algo" id="ValidateObjectAttribute()">
<span class="spec-call"><a href="#ValidateObjectAttribute()" data-name="ValidateObjectAttribute">ValidateObjectAttribute</a>(<var data-name="expr">expr</var>)</span><ol>
<li>If <var data-name="node">node</var> is an <span class="spec-nt"><a href="#ThisAttribute" data-name="ThisAttribute">ThisAttribute</a></span>:<ol>
<li>Stop.</li>
</ol>
</li>
<li>If <var data-name="node">node</var> is a <span class="spec-nt"><a href="#Projection" data-name="Projection">Projection</a></span>, <span class="spec-nt"><a href="#ElementAccess" data-name="ElementAccess">ElementAccess</a></span>, <span class="spec-nt"><a href="#Slice" data-name="Slice">Slice</a></span>, or <span class="spec-nt"><a href="#Filter" data-name="Filter">Filter</a></span>:<ol>
<li>Let <var data-name="base">base</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> of <var data-name="expr">expr</var>.</li>
<li>Execute <span class="spec-call"><a href="#ValidateObjectAttribute()" data-name="ValidateObjectAttribute">ValidateObjectAttribute</a>(<var data-name="base">base</var>)</span>.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Report an error.</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-Pair" secid="4.7">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Pair">4.7</a></span>Pair</h2>
<p>A pair of values, e.g. <code>"a" =&gt; 1</code>. Pairs can contain any combination of other types, including other pairs, and are mainly used internally with e.g. projection conditionals and<code>select()</code>.</p>
<p>In serialized JSON, pairs are represented as a string on the form <code>fst =&gt; snd</code> where <code>fst</code> and <code>snd</code> are the serialized JSON for the first and the second expression.</p>
<div class="spec-production" id="Pair">
<span class="spec-nt"><a href="#Pair" data-name="Pair">Pair</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">=&gt;</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluatePair()">
<span class="spec-call"><a href="#EvaluatePair()" data-name="EvaluatePair">EvaluatePair</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="firstNode">firstNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="secondNode">secondNode</var> be the second <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="result">result</var> be a new pair.</li>
<li>Set the first value of <var data-name="result">result</var> to the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="firstNode">firstNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Set the second value of <var data-name="result">result</var> to the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="secondNode">secondNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
</section>
<section id="sec-Range" secid="4.8">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Range">4.8</a></span>Range</h2>
<p>An interval containing all values that are ordered between the start and end values. The starting value is always included, while the end may be either included or excluded. A right-inclusive range is expressed as two values separated by <code>..</code>, e.g. <code>1..3</code>, while a right-exclusive range is separated by <code>...</code>, e.g. <code>1...3</code>.</p>
<p>Ranges can have endpoints of any comparable data type, but both endpoints must be of the same type (except integers and floats which can be used interchangeably). Ranges with incompatible or invalid endpoints types will yield <code>null</code>.</p>
<p>Ranges are mainly used internally, e.g. with the <code>in</code> operator and array slice access operator. The endpoints may have context-dependant semantics, e.g. in array slices the range <code>[2..-1]</code> will cover the range from the third array element to the last element, while the same range is considered empty when used with <code>in</code>. For more details, see the documentation for the relevant operators.</p>
<p>In serialized JSON, ranges are represented as a string on the form <code>start..end</code> (for inclusive ranges) and <code>start...end</code> (for exclusive ranges) where <code>start</code> and <code>end</code> are the serialized JSON for the start and the end expression.</p>
<div class="spec-production" id="Range">
<span class="spec-nt"><a href="#Range" data-name="Range">Range</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#InclusiveRange" data-name="InclusiveRange">InclusiveRange</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#ExclusiveRange" data-name="ExclusiveRange">ExclusiveRange</a></span></div>
</div>
<div class="spec-production" id="InclusiveRange">
<span class="spec-nt"><a href="#InclusiveRange" data-name="InclusiveRange">InclusiveRange</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">..</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-production" id="ExclusiveRange">
<span class="spec-nt"><a href="#ExclusiveRange" data-name="ExclusiveRange">ExclusiveRange</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">...</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateRange()">
<span class="spec-call"><a href="#EvaluateRange()" data-name="EvaluateRange">EvaluateRange</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="startNode">startNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="endNode">endNode</var> be the second <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="start">start</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="startNode">startNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="end">end</var> be the result of <span class="spec-call"><span data-name="Evalaute">Evalaute</span>(<var data-name="endNode">endNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <span class="spec-call"><a href="#PartialCompare()" data-name="PartialCompare">PartialCompare</a>(<var data-name="start">start</var>, <var data-name="end">end</var>)</span> is <span class="spec-keyword">null</span>:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>Let <var data-name="result">result</var> be a new range.</li>
<li>Set the start value of <var data-name="result">result</var> to <var data-name="start">start</var>.</li>
<li>Set the end value of <var data-name="result">result</var> to <var data-name="end">end</var>.</li>
<li>Mark the range as inclusive or exclusive.</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
</section>
<section id="sec-Datetime" secid="4.9">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Datetime">4.9</a></span>Datetime</h2>
<p>A datetime is a combination of a Gregorian-calendar date and a time in UTC. It&rsquo;s stored in millisecond precision, but an implementation can choose to support even finer granularity. Datetimes support date/time arithmetic. Only valid date/time combinations can be represented.</p>
<p>Datetimes cannot be constructed from literals, but must be constructed with the <var data-name="dateTime">dateTime</var> function.</p>
<p>In serialized JSON, datetimes are represented as a string with using <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> timestamp format, e.g. <code>2006-01-02T15:04:05Z</code> using the following rules:</p>
<ol>
<li>If there is no millisecond information in the datetime, format it without any fractional digits: <code>2006-01-02T15:04:05Z</code></li>
<li>If there is millisecond information in the datetime, format it with 3 fractional digits: <code>2006-01-02T15:04:05.508Z</code></li>
<li>If the datetime contains even finer granularity, it&rsquo;s implementation dependent how the additional fractional digits are formatted. </li>
</ol>
</section>
</section>
<section id="sec-Equality-and-comparison" secid="5">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Equality-and-comparison">5</a></span>Equality and comparison</h1>
<p>GROQ provides trivial equality and comparison between numbers, strings and booleans. Other types are considered inequal or incomparable to each other. Incomparability between values are represented by operators returning <span class="spec-keyword">null</span> (e.g. <code>2 &gt; "1"</code> is <span class="spec-keyword">null</span>).</p>
<section id="sec-Equality" secid="5.1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Equality">5.1</a></span>Equality</h2>
<p>Simple values such as numbers, strings, booleans and <span class="spec-keyword">null</span> are equal when they contain the same data. All other values are considered inequal to each other (e.g. <code>[] != []</code>).</p>
<div id="note-07354" class="spec-note">
<a href="#note-07354">Note</a>
In GROQ <code>1 == null</code> returns <code>false</code> (which is different from e.g. SQL). </div>
<div class="spec-algo" id="Equal()">
<span class="spec-call"><a href="#Equal()" data-name="Equal">Equal</a>(<var data-name="a">a</var>, <var data-name="b">b</var>)</span><ol>
<li>If both <var data-name="a">a</var> and <var data-name="b">b</var> is <span class="spec-keyword">null</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>Let <var data-name="cmp">cmp</var> be the result of <span class="spec-call"><a href="#PartialCompare()" data-name="PartialCompare">PartialCompare</a>(<var data-name="a">a</var>, <var data-name="b">b</var>)</span>.</li>
<li>If <var data-name="cmp">cmp</var> is <span class="spec-nt"><span data-name="Equal">Equal</span></span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-Partial-comparison" secid="5.2">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Partial-comparison">5.2</a></span>Partial comparison</h2>
<p>A partial comparison between two values return either <span class="spec-nt"><span data-name="Greater">Greater</span></span>, <span class="spec-nt"><span data-name="Equal">Equal</span></span>, <span class="spec-nt"><span data-name="Less">Less</span></span> or <span class="spec-keyword">null</span>. <span class="spec-keyword">null</span> represents that the values are incomparable to each other. This is used by the comparison operators (&lt;, &le;, &gt;, &ge;).</p>
<div class="spec-algo" id="PartialCompare()">
<span class="spec-call"><a href="#PartialCompare()" data-name="PartialCompare">PartialCompare</a>(<var data-name="a">a</var>, <var data-name="b">b</var>)</span><ol>
<li>If the type of <var data-name="a">a</var> is different from the type of <var data-name="b">b</var>:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>If <var data-name="a">a</var> is a datetime, consider the datetimes as absolute points in time in the UTC time zone:<ol>
<li>If a &lt; b:<ol>
<li>Return <span class="spec-nt"><span data-name="Less">Less</span></span>.</li>
</ol>
</li>
<li>If a &gt; b:<ol>
<li>Return <span class="spec-nt"><span data-name="Greater">Greater</span></span>.</li>
</ol>
</li>
<li>If a = b:<ol>
<li>Return <span class="spec-nt"><span data-name="Equal">Equal</span></span>.</li>
</ol>
</li>
</ol>
</li>
<li>If <var data-name="a">a</var> is a number:<ol>
<li>If a &lt; b:<ol>
<li>Return <span class="spec-nt"><span data-name="Less">Less</span></span>.</li>
</ol>
</li>
<li>If a &gt; b:<ol>
<li>Return <span class="spec-nt"><span data-name="Greater">Greater</span></span>.</li>
</ol>
</li>
<li>If a = b:<ol>
<li>Return <span class="spec-nt"><span data-name="Equal">Equal</span></span>.</li>
</ol>
</li>
</ol>
</li>
<li>If <var data-name="a">a</var> is a string:<ol>
<li>For each Unicode code point (<var data-name="aCodePoint">aCodePoint</var>, <var data-name="bCodePoint">bCodePoint</var>) in <var data-name="a">a</var> and <var data-name="b">b</var>:<ol>
<li>If <var data-name="aCodePoint">aCodePoint</var> &lt; <var data-name="bCodePoint">bCodePoint</var>:<ol>
<li>Return <span class="spec-nt"><span data-name="Less">Less</span></span>.</li>
</ol>
</li>
</ol>
</li>
<li>If <var data-name="aCodePoint">aCodePoint</var> &gt; <var data-name="bCodePoint">bCodePoint</var>:<ol>
<li>Return <span class="spec-nt"><span data-name="Greater">Greater</span></span>.</li>
</ol>
</li>
<li>If <var data-name="a">a</var> is shorter than <var data-name="b">b</var>:<ol>
<li>Return <span class="spec-nt"><span data-name="Less">Less</span></span>.</li>
</ol>
</li>
<li>If <var data-name="a">a</var> is longer than <var data-name="b">b</var>:<ol>
<li>Return <span class="spec-nt"><span data-name="Greater">Greater</span></span>.</li>
</ol>
</li>
<li>Return <span class="spec-nt"><span data-name="Equal">Equal</span></span>.</li>
</ol>
</li>
<li>If <var data-name="a">a</var> is a boolean:<ol>
<li>Return the comparison between <var data-name="a">a</var> and <var data-name="b">b</var> with <span class="spec-keyword">false</span> &lt; <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Total-comparison" secid="5.3">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Total-comparison">5.3</a></span>Total comparison</h2>
<p>A total comparison between two values return either <span class="spec-nt"><span data-name="Greater">Greater</span></span>, <span class="spec-nt"><span data-name="Equal">Equal</span></span> or <span class="spec-nt"><span data-name="Less">Less</span></span>. It provides a consistent ordering of values of different types (for string, numbers and boolean) and considers all other types to be equal to each other. This is used by the <span class="spec-call"><a href="#order()" data-name="order">order</a>()</span> function.</p>
<div class="spec-algo" id="TypeOrder()">
<span class="spec-call"><a href="#TypeOrder()" data-name="TypeOrder">TypeOrder</a>(<var data-name="val">val</var>)</span><ol>
<li>If <var data-name="val">val</var> is a datetime:<ol>
<li>Return 1.</li>
</ol>
</li>
<li>If <var data-name="val">val</var> is a number:<ol>
<li>Return 2.</li>
</ol>
</li>
<li>If <var data-name="val">val</var> is a string:<ol>
<li>Return 3.</li>
</ol>
</li>
<li>If <var data-name="val">val</var> is a boolean:<ol>
<li>Return 4.</li>
</ol>
</li>
<li>Return 5.</li>
</ol>
</div>
<div class="spec-algo" id="TotalCompare()">
<span class="spec-call"><a href="#TotalCompare()" data-name="TotalCompare">TotalCompare</a>(<var data-name="a">a</var>, <var data-name="b">b</var>)</span><ol>
<li>Let <var data-name="aTypeOrder">aTypeOrder</var> be the result of <span class="spec-call"><a href="#TypeOrder()" data-name="TypeOrder">TypeOrder</a>(<var data-name="a">a</var>)</span>.</li>
<li>Let <var data-name="bTypeOrder">bTypeOrder</var> be the result of <span class="spec-call"><a href="#TypeOrder()" data-name="TypeOrder">TypeOrder</a>(<var data-name="b">b</var>)</span>.</li>
<li>If <var data-name="aTypeOrder">aTypeOrder</var> != <var data-name="bTypeOrder">bTypeOrder</var>:<ol>
<li>Return the result of <span class="spec-call"><a href="#PartialCompare()" data-name="PartialCompare">PartialCompare</a>(<var data-name="aTypeOrder">aTypeOrder</var>, <var data-name="bTypeOrder">bTypeOrder</var>)</span>.</li>
</ol>
</li>
<li>Let <var data-name="result">result</var> be the result of <span class="spec-call"><a href="#PartialCompare()" data-name="PartialCompare">PartialCompare</a>(<var data-name="a">a</var>, <var data-name="b">b</var>)</span>.</li>
<li>If <var data-name="result">result</var> is <span class="spec-keyword">null</span>:<ol>
<li>Return <span class="spec-nt"><span data-name="Equal">Equal</span></span>.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Return <var data-name="result">result</var>. </li>
</ol>
</li>
</ol>
</div>
</section>
</section>
<section id="sec-Simple-expressions" secid="6">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Simple-expressions">6</a></span>Simple expressions</h1>
<section id="sec-This-expression" secid="6.1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-This-expression">6.1</a></span>This expression</h2>
<p>A this expression returns the this value of the current scope.</p>
<pre data-language="groq"><code>*[_id == "doc"][0].numbers[@ &gt;= 10]
                           ~
</code></pre>
<div class="spec-production" id="This">
<span class="spec-nt"><a href="#This" data-name="This">This</a></span><div class="spec-rhs"><span class="spec-t">@</span></div>
</div>
<div class="spec-algo" id="EvaluateThis()">
<span class="spec-call"><a href="#EvaluateThis()" data-name="EvaluateThis">EvaluateThis</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Return the this value of <var data-name="scope">scope</var>.</li>
</ol>
</div>
</section>
<section id="sec-This-attribute-expression" secid="6.2">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-This-attribute-expression">6.2</a></span>This attribute expression</h2>
<p>A <em>this attribute expression </em>returns an attribute from the this value of the current scope.</p>
<pre><code>*[_id == "document"][name == "Michael Bluth"]
  ~~~                ~~~~
</code></pre>
<div class="spec-production" id="ThisAttribute">
<span class="spec-nt"><a href="#ThisAttribute" data-name="ThisAttribute">ThisAttribute</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span></div>
</div>
<div class="spec-algo" id="EvaluateThisAttribute()">
<span class="spec-call"><a href="#EvaluateThisAttribute()" data-name="EvaluateThisAttribute">EvaluateThisAttribute</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="base">base</var> be the this value of <var data-name="scope">scope</var>.</li>
<li>Let <var data-name="name">name</var> be the string value of the <span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span>.</li>
<li>If <var data-name="base">base</var> is not an object, return <span class="spec-keyword">null</span>.</li>
<li>If <var data-name="base">base</var> does not contain an attribute <var data-name="name">name</var>, return <span class="spec-keyword">null</span>.</li>
<li>Return the value of the attribute <var data-name="name">name</var> in <var data-name="base">base</var>.</li>
</ol>
</div>
</section>
<section id="sec-Everything-expression" secid="6.3">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Everything-expression">6.3</a></span>Everything expression</h2>
<p>An everything expression returns the full dataset.</p>
<pre><code>*[_type == "person"]
~
</code></pre>
<div class="spec-production" id="Everything">
<span class="spec-nt"><a href="#Everything" data-name="Everything">Everything</a></span><div class="spec-rhs"><span class="spec-t">*</span></div>
</div>
<div class="spec-algo" id="EvaluateEverything()">
<span class="spec-call"><a href="#EvaluateEverything()" data-name="EvaluateEverything">EvaluateEverything</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="context">context</var> be the query context of <var data-name="scope">scope</var>.</li>
<li>Return the dataset of <var data-name="context">context</var>.</li>
</ol>
</div>
</section>
<section id="sec-Parent-expression" secid="6.4">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Parent-expression">6.4</a></span>Parent expression</h2>
<p>A parent expression returns a this value for an upper scope.</p>
<pre><code>// Find all people who have a cool friend
*[_type == "person" &amp;&amp; *[_id == ^.friend._ref][0].isCool]
                                ~
</code></pre>
<div class="spec-production" id="Parent">
<span class="spec-nt"><a href="#Parent" data-name="Parent">Parent</a></span><div class="spec-rhs"><span class="spec-t">^</span></div>
<div class="spec-rhs"><span class="spec-t">^.</span><span class="spec-nt"><a href="#Parent" data-name="Parent">Parent</a></span></div>
</div>
<div class="spec-algo" id="EvaluateParent()">
<span class="spec-call"><a href="#EvaluateParent()" data-name="EvaluateParent">EvaluateParent</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="level">level</var> be the number of <code>^</code> in the parent expression.</li>
<li>Let <var data-name="currentScope">currentScope</var> be <var data-name="scope">scope</var>.</li>
<li>While <var data-name="level">level</var> is greater than zero:<ol>
<li>Set <var data-name="currentScope">currentScope</var> to the parent of <var data-name="currentScope">currentScope</var>. </li>
<li>If <var data-name="currentScope">currentScope</var> is now <span class="spec-keyword">null</span>, return <span class="spec-keyword">null</span>.</li>
<li>Decrease <var data-name="level">level</var> by one.</li>
</ol>
</li>
<li>Return the this value of <var data-name="currentScope">currentScope</var>.</li>
</ol>
</div>
</section>
<section id="sec-Function-call-expression" secid="6.5">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Function-call-expression">6.5</a></span>Function call expression</h2>
<p>GROQ comes with a set of built-in functions which provides additional features. See the <a href="#sec-Functions">&ldquo;Functions&rdquo;</a> for available functions and their namespaces.</p>
<pre><code>*{"score": round(score, 2)}
           ~~~~~~~~~~~~~~~

*{"description": global::lower(description)}
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<div class="spec-production" id="FuncCall">
<span class="spec-nt"><a href="#FuncCall" data-name="FuncCall">FuncCall</a></span><div class="spec-rhs"><span class="spec-quantified"><span class="spec-nt"><a href="#FuncNamespace" data-name="FuncNamespace">FuncNamespace</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-nt"><a href="#FuncIdentifier" data-name="FuncIdentifier">FuncIdentifier</a></span><span class="spec-t">(</span><span class="spec-nt"><a href="#FuncCallArgs" data-name="FuncCallArgs">FuncCallArgs</a></span><span class="spec-t">)</span></div>
</div>
<div class="spec-production" id="FuncNamespace">
<span class="spec-nt"><a href="#FuncNamespace" data-name="FuncNamespace">FuncNamespace</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span><span class="spec-prose">::</span></div>
</div>
<div class="spec-production" id="FuncIdentifier">
<span class="spec-nt"><a href="#FuncIdentifier" data-name="FuncIdentifier">FuncIdentifier</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span></div>
</div>
<div class="spec-production" id="FuncCallArgs">
<span class="spec-nt"><a href="#FuncCallArgs" data-name="FuncCallArgs">FuncCallArgs</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#FuncCallArgs" data-name="FuncCallArgs">FuncCallArgs</a></span><span class="spec-t">,</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateFuncCall()">
<span class="spec-call"><a href="#EvaluateFuncCall()" data-name="EvaluateFuncCall">EvaluateFuncCall</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="namespace">namespace</var> be the string value of the <span class="spec-nt"><a href="#FuncNamespace" data-name="FuncNamespace">FuncNamespace</a></span>.</li>
<li>Let <var data-name="name">name</var> be the string value of the <span class="spec-nt"><a href="#FuncIdentifier" data-name="FuncIdentifier">FuncIdentifier</a></span>.</li>
<li>Let <var data-name="args">args</var> be an empty array.</li>
<li>For each <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> in <span class="spec-nt"><a href="#FuncCallArgs" data-name="FuncCallArgs">FuncCallArgs</a></span>:<ol>
<li>Let <var data-name="argumentNode">argumentNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Append <var data-name="argumentNode">argumentNode</var> to <var data-name="args">args</var>.</li>
</ol>
</li>
<li>Let <var data-name="func">func</var> be the function defined under the name <var data-name="name">name</var> in either <var data-name="namespace">namespace</var> namespace if provided, or the <code>global</code> namespace.</li>
<li>Return the result of <span class="spec-call"><span data-name="func">func</span>(<var data-name="args">args</var>, <var data-name="scope">scope</var>)</span>.</li>
</ol>
</div>
<div class="spec-algo" id="ValidateFuncCall()">
<span class="spec-call"><a href="#ValidateFuncCall()" data-name="ValidateFuncCall">ValidateFuncCall</a>()</span><ol>
<li>Let <var data-name="namespace">namespace</var> be the string value of the <span class="spec-nt"><a href="#FuncNamespace" data-name="FuncNamespace">FuncNamespace</a></span>.</li>
<li>If there is no namespace named <var data-name="namespace">namespace</var>:<ol>
<li>Stop and report an error.</li>
</ol>
</li>
<li>Let <var data-name="name">name</var> be the string value of the <span class="spec-nt"><a href="#FuncIdentifier" data-name="FuncIdentifier">FuncIdentifier</a></span>.</li>
<li>If there is no function named <var data-name="name">name</var> defined in either <var data-name="namespace">namespace</var> namespace if provided, or the <code>global</code> namespace:<ol>
<li>Stop and report an error.</li>
</ol>
</li>
<li>Let <var data-name="args">args</var> be an array of the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>s in <span class="spec-nt"><a href="#FuncCallArgs" data-name="FuncCallArgs">FuncCallArgs</a></span>.</li>
<li>Let <var data-name="validator">validator</var> be the validator for the function under the name <var data-name="name">name</var>.</li>
<li>Execute <span class="spec-call"><span data-name="validator">validator</span>(<var data-name="args">args</var>)</span>. </li>
</ol>
</div>
</section>
</section>
<section id="sec-Compound-expressions" secid="7">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Compound-expressions">7</a></span>Compound expressions</h1>
<section id="sec-Parenthesis-expression" secid="7.1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Parenthesis-expression">7.1</a></span>Parenthesis expression</h2>
<p>A parenthesis expression allows you to add parenthesis around another expression to control precedence of operators.</p>
<pre data-language="groq"><code>(1 + 2) * 3
~~~~~~~
</code></pre>
<div class="spec-production" id="Parenthesis">
<span class="spec-nt"><a href="#Parenthesis" data-name="Parenthesis">Parenthesis</a></span><div class="spec-rhs"><span class="spec-t">(</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">)</span></div>
</div>
<div class="spec-algo" id="EvaluateParenthesis()">
<span class="spec-call"><a href="#EvaluateParenthesis()" data-name="EvaluateParenthesis">EvaluateParenthesis</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="innerNode">innerNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="result">result</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="innerNode">innerNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
</section>
<section id="sec-Attribute-access-expression" secid="7.2">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Attribute-access-expression">7.2</a></span>Attribute access expression</h2>
<p>An attribute access expression returns an attribute of an object.</p>
<pre><code>person.name
      ~~~~~

person["Full Name"]
      ~~~~~~~~~~~~~
</code></pre>
<div class="spec-production" id="AttributeAccess">
<span class="spec-nt"><a href="#AttributeAccess" data-name="AttributeAccess">AttributeAccess</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">.</span><span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">[</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">]</span></div>
</div>
<div id="note-61749" class="spec-note">
<a href="#note-61749">Note</a>
<span class="spec-nt"><a href="#Filter" data-name="Filter">Filter</a></span>, <span class="spec-nt"><a href="#ElementAccess" data-name="ElementAccess">ElementAccess</a></span>, <span class="spec-nt"><a href="#AttributeAccess" data-name="AttributeAccess">AttributeAccess</a></span> are syntactically ambiguous. See <a href="#sec-Disambiguating-square-backet-expressions">&ldquo;Disambiguating square backet expressions&rdquo;</a> for how to disambiguate between them.</div>
<div class="spec-algo" id="EvaluateAttributeAccess()">
<span class="spec-call"><a href="#EvaluateAttributeAccess()" data-name="EvaluateAttributeAccess">EvaluateAttributeAccess</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="baseNode">baseNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is not an object, return <span class="spec-keyword">null</span>.</li>
<li>Let <var data-name="name">name</var> be the string value of <span class="spec-nt"><a href="#String" data-name="String">String</a></span> or <span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span>.</li>
<li>If <var data-name="base">base</var> does not contain an attribute <var data-name="name">name</var>, return <span class="spec-keyword">null</span>.</li>
<li>Return the value of the attribute <var data-name="name">name</var> in <var data-name="base">base</var>.</li>
</ol>
</div>
</section>
<section id="sec-Element-access-expression" secid="7.3">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Element-access-expression">7.3</a></span>Element access expression</h2>
<p>An element access expression returns an element stored in an array. The array is 0-indexed and a negative index accesses the array from the end (i.e. an index of -1 returns the last element; -2 refers to the second last element).</p>
<div class="spec-production" id="ElementAccess">
<span class="spec-nt"><a href="#ElementAccess" data-name="ElementAccess">ElementAccess</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">[</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">]</span></div>
</div>
<div id="note-7c356" class="spec-note">
<a href="#note-7c356">Note</a>
<span class="spec-nt"><a href="#Filter" data-name="Filter">Filter</a></span>, <span class="spec-nt"><a href="#ElementAccess" data-name="ElementAccess">ElementAccess</a></span>, <span class="spec-nt"><a href="#AttributeAccess" data-name="AttributeAccess">AttributeAccess</a></span> are syntactically ambiguous. See <a href="#sec-Disambiguating-square-backet-expressions">&ldquo;Disambiguating square backet expressions&rdquo;</a> for how to disambiguate between them.</div>
<div class="spec-algo" id="EvaluateElementAccess()">
<span class="spec-call"><a href="#EvaluateElementAccess()" data-name="EvaluateElementAccess">EvaluateElementAccess</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="baseNode">baseNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is not an array, return <span class="spec-keyword">null</span>.</li>
<li>Let <var data-name="idxNode">idxNode</var> be the second <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="idx">idx</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="idxNode">idxNode</var>, <var data-name="scope">scope</var>)</span>. This value is guaranteed to be an integer due to the validation.</li>
<li>If <var data-name="idx">idx</var> is negative, add the length of <var data-name="base">base</var> to <var data-name="idx">idx</var>.</li>
<li>If <var data-name="idx">idx</var> is still negative, return <span class="spec-keyword">null</span>.</li>
<li>If <var data-name="idx">idx</var> is equal to or greater than the length of <var data-name="base">base</var>, return <span class="spec-keyword">null</span>.</li>
<li>Return the value stored at position <var data-name="idx">idx</var> in <var data-name="base">base</var>.</li>
</ol>
</div>
<div class="spec-algo" id="ValidateElementAccess()">
<span class="spec-call"><a href="#ValidateElementAccess()" data-name="ValidateElementAccess">ValidateElementAccess</a>()</span><ol>
<li>Let <var data-name="idxNode">idxNode</var> be the second <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="idx">idx</var> be the result of <span class="spec-call"><a href="#ConstantEvaluate()" data-name="ConstantEvaluate">ConstantEvaluate</a>(<var data-name="idxNode">idxNode</var>)</span>. This value is guaranteed to be a number due to square bracket disambiguation.</li>
<li>If <var data-name="idx">idx</var> is not an integer: Report an error.</li>
</ol>
</div>
</section>
<section id="sec-Slice-expression" secid="7.4">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Slice-expression">7.4</a></span>Slice expression</h2>
<p>A slice expression returns a slice of an array.</p>
<pre><code>people[0..10]
      ~~~~~~~
</code></pre>
<div class="spec-production" id="Slice">
<span class="spec-nt"><a href="#Slice" data-name="Slice">Slice</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">[</span><span class="spec-nt"><a href="#Range" data-name="Range">Range</a></span><span class="spec-t">]</span></div>
</div>
<div class="spec-algo" id="EvaluateSlice()">
<span class="spec-call"><a href="#EvaluateSlice()" data-name="EvaluateSlice">EvaluateSlice</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="baseNode">baseNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is not an array, return <span class="spec-keyword">null</span>.</li>
<li>Process the left index:<ol>
<li>Let <var data-name="leftNode">leftNode</var> be the left value of the <span class="spec-nt"><a href="#Range" data-name="Range">Range</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>. This value is guaranteed to be an integer due to the validation.</li>
<li>If <var data-name="left">left</var> is negative, add the length of <var data-name="base">base</var> to <var data-name="left">left</var>.</li>
<li>Clamp <var data-name="left">left</var> between 0 and (the length of <var data-name="base">base</var> minus 1).</li>
</ol>
</li>
<li>Process the right index:<ol>
<li>Let <var data-name="rightNode">rightNode</var> be the right value of the <span class="spec-nt"><a href="#Range" data-name="Range">Range</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>. This value is guaranteed to be an integer due to the validation.</li>
<li>If <var data-name="right">right</var> is negative, add the length of <var data-name="base">base</var> to <var data-name="right">right</var>.</li>
<li>If the <span class="spec-nt"><a href="#Range" data-name="Range">Range</a></span> is exclusive, subtract one from <var data-name="right">right</var>.</li>
<li>Clamp <var data-name="right">right</var> between 0 and (the length of <var data-name="base">base</var> minus 1).</li>
</ol>
</li>
<li>Let <var data-name="result">result</var> be an array containing the elements of <var data-name="base">base</var> from position <var data-name="left">left</var> up to and including position <var data-name="right">right</var>.</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
<div class="spec-algo" id="ValidateSlice()">
<span class="spec-call"><a href="#ValidateSlice()" data-name="ValidateSlice">ValidateSlice</a>()</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the left value of the <span class="spec-nt"><a href="#Range" data-name="Range">Range</a></span>.</li>
<li>Let <var data-name="leftValue">leftValue</var> be the result of <span class="spec-call"><a href="#ConstantEvaluate()" data-name="ConstantEvaluate">ConstantEvaluate</a>(<var data-name="leftNode">leftNode</var>)</span>.</li>
<li>If <var data-name="leftValue">leftValue</var> is not an integer: Report an error.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the right value of the <span class="spec-nt"><a href="#Range" data-name="Range">Range</a></span>.</li>
<li>Let <var data-name="rightValue">rightValue</var> be the result of <span class="spec-call"><a href="#ConstantEvaluate()" data-name="ConstantEvaluate">ConstantEvaluate</a>(<var data-name="rightNode">rightNode</var>)</span>.</li>
<li>If <var data-name="rightValue">rightValue</var> is not an integer: Report an error.</li>
</ol>
</div>
</section>
<section id="sec-Filter-expression" secid="7.5">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Filter-expression">7.5</a></span>Filter expression</h2>
<p>A filter expression filters an array using another expression.</p>
<pre><code>*[_type == "person"]
 ~~~~~~~~~~~~~~~~~~~
</code></pre>
<div class="spec-production" id="Filter">
<span class="spec-nt"><a href="#Filter" data-name="Filter">Filter</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">[</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">]</span></div>
</div>
<div id="note-22d2f" class="spec-note">
<a href="#note-22d2f">Note</a>
<span class="spec-nt"><a href="#Filter" data-name="Filter">Filter</a></span>, <span class="spec-nt"><a href="#ElementAccess" data-name="ElementAccess">ElementAccess</a></span>, <span class="spec-nt"><a href="#AttributeAccess" data-name="AttributeAccess">AttributeAccess</a></span> are syntactically ambiguous. See <a href="#sec-Disambiguating-square-backet-expressions">&ldquo;Disambiguating square backet expressions&rdquo;</a> for how to disambiguate between them.</div>
<div class="spec-algo" id="EvaluateFilter()">
<span class="spec-call"><a href="#EvaluateFilter()" data-name="EvaluateFilter">EvaluateFilter</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="baseNode">baseNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is not an array, return <var data-name="base">base</var>.</li>
<li>Let <var data-name="filterNode">filterNode</var> be the second <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="result">result</var> be a new empty array.</li>
<li>For each element <var data-name="value">value</var> in <var data-name="baseValue">baseValue</var>:<ol>
<li>Let <var data-name="elementScope">elementScope</var> be the result of <span class="spec-call"><a href="#NewNestedScope()" data-name="NewNestedScope">NewNestedScope</a>(<var data-name="value">value</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="matched">matched</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="filterNode">filterNode</var>, <var data-name="elementScope">elementScope</var>)</span>.</li>
<li>If <var data-name="matched">matched</var> is <span class="spec-keyword">true</span>, append <var data-name="value">value</var> to <var data-name="result">result</var>.</li>
</ol>
</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
</section>
<section id="sec-Projection-expression" secid="7.6">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Projection-expression">7.6</a></span>Projection expression</h2>
<p>A projection expression iterates over an array and creates new objects for each element.</p>
<pre><code>*[_type == "person"]{name, "isLegal": age &gt;= 18}
                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<div class="spec-production" id="Projection">
<span class="spec-nt"><a href="#Projection" data-name="Projection">Projection</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-quantified"><span class="spec-t">|</span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-nt"><a href="#Object" data-name="Object">Object</a></span></div>
</div>
<div class="spec-algo" id="EvaluateProjection()">
<span class="spec-call"><a href="#EvaluateProjection()" data-name="EvaluateProjection">EvaluateProjection</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="baseNode">baseNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="objNode">objNode</var> be the <span class="spec-nt"><a href="#Object" data-name="Object">Object</a></span>.</li>
<li>If <var data-name="base">base</var> is not an array:<ol>
<li>Let <var data-name="elementScope">elementScope</var> be the result of <span class="spec-call"><a href="#NewNestedScope()" data-name="NewNestedScope">NewNestedScope</a>(<var data-name="base">base</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="result">result</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="objNode">objNode</var>, <var data-name="elementScope">elementScope</var>)</span>.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Let <var data-name="result">result</var> be a new empty array.</li>
<li>For each element <var data-name="value">value</var> in <var data-name="base">base</var>:<ol>
<li>Let <var data-name="elementScope">elementScope</var> be the result of <span class="spec-call"><a href="#NewNestedScope()" data-name="NewNestedScope">NewNestedScope</a>(<var data-name="value">value</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="newValue">newValue</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="objNode">objNode</var>, <var data-name="elementScope">elementScope</var>)</span>.</li>
<li>Append <var data-name="newValue">newValue</var> to <var data-name="result">result</var>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
</section>
<section id="sec-Pipe-function-call-expression" secid="7.7">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Pipe-function-call-expression">7.7</a></span>Pipe function call expression</h2>
<p>GROQ comes with a set of built-in pipe functions which provides additional features. Pipe functions always accepts an array on the left-hand side and returns another array, and the syntax is optimized for being able to chain it together with other compund expressions. See the <a href="#sec-Pipe-functions">&ldquo;Pipe functions&rdquo;</a> for available functions.</p>
<pre><code>*[_type == "person"] | order(name) | {age}
                     ~~~~~~~~~~~~~
</code></pre>
<div class="spec-production" id="PipeFuncCall">
<span class="spec-nt"><a href="#PipeFuncCall" data-name="PipeFuncCall">PipeFuncCall</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">|</span><span class="spec-nt"><a href="#FuncCall" data-name="FuncCall">FuncCall</a></span></div>
</div>
<div class="spec-algo" id="EvaluatePipeFuncCall()">
<span class="spec-call"><a href="#EvaluatePipeFuncCall()" data-name="EvaluatePipeFuncCall">EvaluatePipeFuncCall</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="baseNode">baseNode</var> be the first Expression.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is not an array:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>Let <var data-name="name">name</var> be the string value of the <span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span> of the <span class="spec-nt"><a href="#FuncCall" data-name="FuncCall">FuncCall</a></span>.</li>
<li>Let <var data-name="args">args</var> be an empty array.</li>
<li>For each <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> in the <span class="spec-nt"><a href="#FuncCallArgs" data-name="FuncCallArgs">FuncCallArgs</a></span> of the <span class="spec-nt"><a href="#FuncCall" data-name="FuncCall">FuncCall</a></span>.<ol>
<li>Let <var data-name="argumentNode">argumentNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Append <var data-name="argumentNode">argumentNode</var> to <var data-name="args">args</var>.</li>
</ol>
</li>
<li>Let <var data-name="func">func</var> be the pipe function defined under the name <var data-name="name">name</var>.</li>
<li>Return the result of <span class="spec-call"><span data-name="func">func</span>(<var data-name="base">base</var>, <var data-name="args">args</var>, <var data-name="scope">scope</var>)</span>.</li>
</ol>
</div>
<div class="spec-algo" id="ValidatePipeFuncCall()">
<span class="spec-call"><a href="#ValidatePipeFuncCall()" data-name="ValidatePipeFuncCall">ValidatePipeFuncCall</a>()</span><ol>
<li>Let <var data-name="base">base</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Execute <span class="spec-call"><a href="#Validate()" data-name="Validate">Validate</a>(<var data-name="base">base</var>)</span>.</li>
<li>Let <var data-name="name">name</var> be the string value of the <span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span> of the <span class="spec-nt"><a href="#FuncCall" data-name="FuncCall">FuncCall</a></span>.</li>
<li>If there is no pipe function named <var data-name="name">name</var>:<ol>
<li>Stop and report an error.</li>
</ol>
</li>
<li>Let <var data-name="args">args</var> be an array of the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>s in the <span class="spec-nt"><a href="#FuncCallArgs" data-name="FuncCallArgs">FuncCallArgs</a></span> of the <span class="spec-nt"><a href="#FuncCall" data-name="FuncCall">FuncCall</a></span>.</li>
<li>Let <var data-name="validator">validator</var> be the validator for the pipe function under the name <var data-name="name">name</var>.</li>
<li>Execute <span class="spec-call"><span data-name="validator">validator</span>(<var data-name="args">args</var>)</span>.</li>
</ol>
</div>
</section>
<section id="sec-Disambiguating-square-backet-expressions" secid="7.8">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Disambiguating-square-backet-expressions">7.8</a></span>Disambiguating square backet expressions</h2>
<p><span class="spec-nt"><a href="#Filter" data-name="Filter">Filter</a></span>, <span class="spec-nt"><a href="#ElementAccess" data-name="ElementAccess">ElementAccess</a></span> and <span class="spec-nt"><a href="#AttributeAccess" data-name="AttributeAccess">AttributeAccess</a></span> are syntactically ambiguous, and the following algorithm is used to disambiguate between them.</p>
<div class="spec-production" id="SquareBracketExpression">
<span class="spec-nt"><a href="#SquareBracketExpression" data-name="SquareBracketExpression">SquareBracketExpression</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">[</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">]</span></div>
</div>
<div class="spec-algo" id="DisambiguateSquareBracketExpression()">
<span class="spec-call"><a href="#DisambiguateSquareBracketExpression()" data-name="DisambiguateSquareBracketExpression">DisambiguateSquareBracketExpression</a>()</span><ol>
<li>Let <var data-name="valueNode">valueNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="value">value</var> be the result of <span class="spec-call"><a href="#ConstantEvaluate()" data-name="ConstantEvaluate">ConstantEvaluate</a>(<var data-name="valueNode">valueNode</var>)</span>.</li>
<li>If <var data-name="value">value</var> is a string: Interpret it as an <span class="spec-nt"><a href="#AttributeAccess" data-name="AttributeAccess">AttributeAccess</a></span> expression.</li>
<li>If <var data-name="value">value</var> is a number: Interpret it as an <span class="spec-nt"><a href="#ElementAccess" data-name="ElementAccess">ElementAccess</a></span> expression.</li>
<li>Otherwise: Interpret it as a <span class="spec-nt"><a href="#Filter" data-name="Filter">Filter</a></span> expression. </li>
</ol>
</div>
</section>
</section>
<section id="sec-Operators" secid="8">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Operators">8</a></span>Operators</h1>
<section id="sec-And-operator" secid="8.1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-And-operator">8.1</a></span>And operator</h2>
<div class="spec-production" id="And">
<span class="spec-nt"><a href="#And" data-name="And">And</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">&amp;&amp;</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateAnd()">
<span class="spec-call"><a href="#EvaluateAnd()" data-name="EvaluateAnd">EvaluateAnd</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="left">left</var> or <var data-name="right">right</var> is <span class="spec-keyword">false</span>:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>If <var data-name="left">left</var> or <var data-name="right">right</var> is not a boolean:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</div>
</section>
<section id="sec-Or-operator" secid="8.2">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Or-operator">8.2</a></span>Or operator</h2>
<div class="spec-production" id="Or">
<span class="spec-nt"><a href="#Or" data-name="Or">Or</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">||</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateOr()">
<span class="spec-call"><a href="#EvaluateOr()" data-name="EvaluateOr">EvaluateOr</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="left">left</var> or <var data-name="right">right</var> is <span class="spec-keyword">true</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>If <var data-name="left">left</var> or <var data-name="right">right</var> is not a boolean:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</div>
</section>
<section id="sec-Not-operator" secid="8.3">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Not-operator">8.3</a></span>Not operator</h2>
<div class="spec-production" id="Not">
<span class="spec-nt"><a href="#Not" data-name="Not">Not</a></span><div class="spec-rhs"><span class="spec-t">!</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateNot()">
<span class="spec-call"><a href="#EvaluateNot()" data-name="EvaluateNot">EvaluateNot</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="valueNode">valueNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="value">value</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="valueNode">valueNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="value">value</var> is <span class="spec-keyword">false</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>If <var data-name="value">value</var> is <span class="spec-keyword">true</span>:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Equality-operators" secid="8.4">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Equality-operators">8.4</a></span>Equality operators</h2>
<div class="spec-production" id="Equality">
<span class="spec-nt"><a href="#Equality" data-name="Equality">Equality</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-nt"><a href="#EqualityOperator" data-name="EqualityOperator">EqualityOperator</a></span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-production" id="EqualityOperator">
<span class="spec-nt"><a href="#EqualityOperator" data-name="EqualityOperator">EqualityOperator</a></span><div class="spec-oneof"><div class="spec-oneof-grid"><table>
<tr>
<td class="spec-rhs"><span class="spec-t">==</span></td><td class="spec-rhs"><span class="spec-t">,</span></td><td class="spec-rhs"><span class="spec-t">!=</span></td></tr>
</table></div></div>
</div>
<div class="spec-algo" id="EvaluateEquality()">
<span class="spec-call"><a href="#EvaluateEquality()" data-name="EvaluateEquality">EvaluateEquality</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="result">result</var> be the result of <span class="spec-call"><a href="#Equal()" data-name="Equal">Equal</a>(<var data-name="left">left</var>, <var data-name="right">right</var>)</span>.</li>
<li>If the operator is <code>!=</code>:<ol>
<li>If <var data-name="result">result</var> is <span class="spec-keyword">true</span>:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>If <var data-name="result">result</var> is <span class="spec-keyword">false</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
</section>
<section id="sec-Comparison-operators" secid="8.5">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Comparison-operators">8.5</a></span>Comparison operators</h2>
<div class="spec-production" id="Comparison">
<span class="spec-nt"><a href="#Comparison" data-name="Comparison">Comparison</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-nt"><a href="#ComparisonOperator" data-name="ComparisonOperator">ComparisonOperator</a></span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-production" id="ComparisonOperator">
<span class="spec-nt"><a href="#ComparisonOperator" data-name="ComparisonOperator">ComparisonOperator</a></span><div class="spec-oneof"><div class="spec-oneof-grid"><table>
<tr>
<td class="spec-rhs"><span class="spec-t">&lt;</span></td><td class="spec-rhs"><span class="spec-t">,</span></td><td class="spec-rhs"><span class="spec-t">&lt;=</span></td><td class="spec-rhs"><span class="spec-t">,</span></td><td class="spec-rhs"><span class="spec-t">&gt;</span></td><td class="spec-rhs"><span class="spec-t">,</span></td><td class="spec-rhs"><span class="spec-t">&gt;=</span></td></tr>
</table></div></div>
</div>
<div class="spec-algo" id="EvaluateComparison()">
<span class="spec-call"><a href="#EvaluateComparison()" data-name="EvaluateComparison">EvaluateComparison</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="cmp">cmp</var> be the result of <span class="spec-call"><a href="#PartialCompare()" data-name="PartialCompare">PartialCompare</a>(<var data-name="left">left</var>, <var data-name="right">right</var>)</span>.</li>
<li>If <var data-name="cmp">cmp</var> is <span class="spec-keyword">null</span>:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>If <var data-name="cmp">cmp</var> is <span class="spec-nt"><span data-name="Less">Less</span></span> and the operator is <span class="spec-t">&lt;</span> or <span class="spec-t">&lt;=</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>If <var data-name="cmp">cmp</var> is <span class="spec-nt"><span data-name="Greater">Greater</span></span> and the operator is <span class="spec-t">&gt;</span> or <span class="spec-t">&gt;=</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>If <var data-name="cmp">cmp</var> is <span class="spec-nt"><span data-name="Equal">Equal</span></span> and the operator is <span class="spec-t">&lt;=</span> or <span class="spec-t">&gt;=</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</div>
</section>
<section id="sec-In-operator" secid="8.6">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-In-operator">8.6</a></span>In operator</h2>
<div class="spec-production" id="In">
<span class="spec-nt"><a href="#In" data-name="In">In</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">in</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateIn()">
<span class="spec-call"><a href="#EvaluateIn()" data-name="EvaluateIn">EvaluateIn</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="right">right</var> is an array:<ol>
<li>For each <var data-name="value">value</var> in <var data-name="right">right</var>:<ol>
<li>If <span class="spec-call"><a href="#Equal()" data-name="Equal">Equal</a>(<var data-name="left">left</var>, <var data-name="value">value</var>)</span> is <span class="spec-keyword">true</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>If <var data-name="right">right</var> is a range:<ol>
<li>Let <var data-name="lower">lower</var> be the start value of <var data-name="right">right</var>.</li>
<li>Let <var data-name="upper">upper</var> be the end value of <var data-name="right">right</var>.</li>
<li>Let <var data-name="leftCmp">leftCmp</var> be the result of <span class="spec-call"><a href="#PartialCompare()" data-name="PartialCompare">PartialCompare</a>(<var data-name="left">left</var>, <var data-name="lower">lower</var>)</span>.</li>
<li>Let <var data-name="rightCmp">rightCmp</var> be the result of <span class="spec-call"><a href="#PartialCompare()" data-name="PartialCompare">PartialCompare</a>(<var data-name="left">left</var>, <var data-name="upper">upper</var>)</span>.</li>
<li>If <var data-name="leftCmp">leftCmp</var> or <var data-name="rightCmp">rightCmp</var> is <span class="spec-keyword">null</span>:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>If <var data-name="leftCmp">leftCmp</var> is <span class="spec-nt"><span data-name="Less">Less</span></span>:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>If <var data-name="rightCmp">rightCmp</var> is <span class="spec-nt"><span data-name="Greater">Greater</span></span>:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>If the <var data-name="right">right</var> range is exclusive and <var data-name="rightCmp">rightCmp</var> is <span class="spec-nt"><span data-name="Equal">Equal</span></span>:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Match-operator" secid="8.7">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Match-operator">8.7</a></span>Match operator</h2>
<p>The match operator is defined in terms of <em>patterns</em> and <em>tokens</em>: It returns true when any of patterns matches all of the tokens. The exact way of tokenizing text and interpreting patterns is left as an implementation detail.</p>
<div class="spec-production" id="Match">
<span class="spec-nt"><a href="#Match" data-name="Match">Match</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">match</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateMatch()">
<span class="spec-call"><a href="#EvaluateMatch()" data-name="EvaluateMatch">EvaluateMatch</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="tokens">tokens</var> be an empty array.</li>
<li>If <var data-name="left">left</var> is a string:<ol>
<li>Concatenate <span class="spec-call"><a href="#MatchTokenize()" data-name="MatchTokenize">MatchTokenize</a>(<var data-name="left">left</var>)</span> to <var data-name="tokens">tokens</var>.</li>
</ol>
</li>
<li>If <var data-name="left">left</var> is an array:<ol>
<li>For each <var data-name="value">value</var> in <var data-name="left">left</var>:<ol>
<li>If <var data-name="value">value</var> is a string:<ol>
<li>Concatenate <span class="spec-call"><a href="#MatchTokenize()" data-name="MatchTokenize">MatchTokenize</a>(<var data-name="value">value</var>)</span> to <var data-name="tokens">tokens</var>.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>Let <var data-name="patterns">patterns</var> be an empty array. </li>
<li>If <var data-name="right">right</var> is a string:<ol>
<li>Append <span class="spec-call"><a href="#MatchAnalyzePattern()" data-name="MatchAnalyzePattern">MatchAnalyzePattern</a>(<var data-name="right">right</var>)</span> to <var data-name="patterns">patterns</var>.</li>
</ol>
</li>
<li>If <var data-name="right">right</var> is an array:<ol>
<li>For each <var data-name="value">value</var> in <var data-name="right">right</var>:<ol>
<li>If <var data-name="value">value</var> is a string:<ol>
<li>Append <span class="spec-call"><a href="#MatchAnalyzePattern()" data-name="MatchAnalyzePattern">MatchAnalyzePattern</a>(<var data-name="value">value</var>)</span> to <var data-name="patterns">patterns</var>.</li>
</ol>
</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
</ol>
</li>
<li>If <var data-name="patterns">patterns</var> is empty:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>For each <var data-name="pattern">pattern</var> in <var data-name="patterns">patterns</var>:<ol>
<li>If <var data-name="pattern">pattern</var> does not matches <var data-name="tokens">tokens</var>:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</div>
<div class="spec-algo" id="MatchTokenize()">
<span class="spec-call"><a href="#MatchTokenize()" data-name="MatchTokenize">MatchTokenize</a>(<var data-name="value">value</var>)</span><ol>
<li>Return an array of tokens. </li>
</ol>
</div>
<div class="spec-algo" id="MatchAnalyzePattern()">
<span class="spec-call"><a href="#MatchAnalyzePattern()" data-name="MatchAnalyzePattern">MatchAnalyzePattern</a>(<var data-name="value">value</var>)</span><ol>
<li>Return a pattern for the given string.</li>
</ol>
</div>
</section>
<section id="sec-Asc-operator" secid="8.8">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Asc-operator">8.8</a></span>Asc operator</h2>
<p>The asc operator is used by the <span class="spec-call"><a href="#order()" data-name="order">order</a>()</span> function to signal that you want ascending sorting. Evaluating it in any other context is not allowed.</p>
<div class="spec-production" id="Asc">
<span class="spec-nt"><a href="#Asc" data-name="Asc">Asc</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">asc</span></div>
</div>
<div class="spec-algo" id="ValidateAsc()">
<span class="spec-call"><a href="#ValidateAsc()" data-name="ValidateAsc">ValidateAsc</a>()</span><ol>
<li>Report an error.</li>
</ol>
</div>
</section>
<section id="sec-Desc-operator" secid="8.9">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Desc-operator">8.9</a></span>Desc operator</h2>
<p>The desc operator is used by the <span class="spec-call"><a href="#order()" data-name="order">order</a>()</span> function to signal that you want descending sorting. Evaluating it in any other context is not allowed.</p>
<div class="spec-production" id="Desc">
<span class="spec-nt"><a href="#Desc" data-name="Desc">Desc</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">desc</span></div>
</div>
<div class="spec-algo" id="ValidateDesc()">
<span class="spec-call"><a href="#ValidateDesc()" data-name="ValidateDesc">ValidateDesc</a>()</span><ol>
<li>Report an error.</li>
</ol>
</div>
</section>
<section id="sec-Unary-plus-operator" secid="8.10">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Unary-plus-operator">8.10</a></span>Unary plus operator</h2>
<div class="spec-production" id="UnaryPlus">
<span class="spec-nt"><a href="#UnaryPlus" data-name="UnaryPlus">UnaryPlus</a></span><div class="spec-rhs"><span class="spec-t">+</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateUnaryPlus()">
<span class="spec-call"><a href="#EvaluateUnaryPlus()" data-name="EvaluateUnaryPlus">EvaluateUnaryPlus</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="valueNode">valueNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="value">value</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="valueNode">valueNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="value">value</var> is a number:<ol>
<li>Return <var data-name="value">value</var>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Unary-minus-operator" secid="8.11">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Unary-minus-operator">8.11</a></span>Unary minus operator</h2>
<div class="spec-production" id="UnaryMinus">
<span class="spec-nt"><a href="#UnaryMinus" data-name="UnaryMinus">UnaryMinus</a></span><div class="spec-rhs"><span class="spec-t">-</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateUnaryMinus()">
<span class="spec-call"><a href="#EvaluateUnaryMinus()" data-name="EvaluateUnaryMinus">EvaluateUnaryMinus</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="valueNode">valueNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="value">value</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="valueNode">valueNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="value">value</var> is a number:<ol>
<li>Return <var data-name="value">value</var> with opposite sign.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Binary-plus-operator" secid="8.12">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Binary-plus-operator">8.12</a></span>Binary plus operator</h2>
<div class="spec-production" id="Plus">
<span class="spec-nt"><a href="#Plus" data-name="Plus">Plus</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">+</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluatePlus()">
<span class="spec-call"><a href="#EvaluatePlus()" data-name="EvaluatePlus">EvaluatePlus</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are strings:<ol>
<li>Return the string concatenation of <var data-name="left">left</var> and <var data-name="right">right</var>.</li>
</ol>
</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are numbers:<ol>
<li>Return the addition of <var data-name="left">left</var> and <var data-name="right">right</var>.</li>
</ol>
</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are arrays:<ol>
<li>Return the concatenation of <var data-name="left">left</var> and <var data-name="right">right</var>.</li>
</ol>
</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are objects:<ol>
<li>Return the merged object of <var data-name="left">left</var> and <var data-name="right">right</var>. For duplicate fields the value from <var data-name="right">right</var> takes precedence.</li>
</ol>
</li>
<li>If <var data-name="left">left</var> is a datetime and <var data-name="right">right</var> is a number:<ol>
<li>Return a new datetime that adds (or subtracts, if negative) <var data-name="right">right</var> as a number of seconds to <var data-name="left">left</var>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Binary-minus-operator" secid="8.13">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Binary-minus-operator">8.13</a></span>Binary minus operator</h2>
<div class="spec-production" id="Minus">
<span class="spec-nt"><a href="#Minus" data-name="Minus">Minus</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">-</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateMinus()">
<span class="spec-call"><a href="#EvaluateMinus()" data-name="EvaluateMinus">EvaluateMinus</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are numbers:<ol>
<li>Return the subtraction of <var data-name="left">left</var> from <var data-name="right">right</var>.</li>
</ol>
</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are datetimes:<ol>
<li>Return the difference, in seconds, between <var data-name="left">left</var> from <var data-name="right">right</var>.</li>
</ol>
</li>
<li>If <var data-name="left">left</var> is a datetime and <var data-name="right">right</var> is a number:<ol>
<li>Return a new datetime being <var data-name="left">left</var> minus <var data-name="right">right</var> as seconds.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Binary-star-operator" secid="8.14">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Binary-star-operator">8.14</a></span>Binary star operator</h2>
<div class="spec-production" id="Star">
<span class="spec-nt"><a href="#Star" data-name="Star">Star</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">*</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateStar()">
<span class="spec-call"><a href="#EvaluateStar()" data-name="EvaluateStar">EvaluateStar</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are numbers:<ol>
<li>Return the multiplication of <var data-name="left">left</var> and <var data-name="right">right</var>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Binary-slash-operator" secid="8.15">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Binary-slash-operator">8.15</a></span>Binary slash operator</h2>
<div class="spec-production" id="Slash">
<span class="spec-nt"><a href="#Slash" data-name="Slash">Slash</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">/</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateSlash()">
<span class="spec-call"><a href="#EvaluateSlash()" data-name="EvaluateSlash">EvaluateSlash</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are numbers:<ol>
<li>Return the division of <var data-name="left">left</var> by <var data-name="right">right</var>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Binary-percent-operator" secid="8.16">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Binary-percent-operator">8.16</a></span>Binary percent operator</h2>
<div class="spec-production" id="Percent">
<span class="spec-nt"><a href="#Percent" data-name="Percent">Percent</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">%</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluatePercent()">
<span class="spec-call"><a href="#EvaluatePercent()" data-name="EvaluatePercent">EvaluatePercent</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are numbers:<ol>
<li>Return the remainder of <var data-name="left">left</var> after division by <var data-name="right">right</var>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Binary-double-star-operator" secid="8.17">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Binary-double-star-operator">8.17</a></span>Binary double star operator</h2>
<div class="spec-production" id="StarStar">
<span class="spec-nt"><a href="#StarStar" data-name="StarStar">StarStar</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">**</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateStarStar()">
<span class="spec-call"><a href="#EvaluateStarStar()" data-name="EvaluateStarStar">EvaluateStarStar</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If both <var data-name="left">left</var> and right are numbers:<ol>
<li>Return the exponentiation of <var data-name="left">left</var> to the power of <var data-name="right">right</var>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Dereference-operator" secid="8.18">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Dereference-operator">8.18</a></span>Dereference operator</h2>
<div class="spec-production" id="Dereference">
<span class="spec-nt"><a href="#Dereference" data-name="Dereference">Dereference</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">-&gt;</span><span class="spec-quantified"><span class="spec-nt"><a href="#String" data-name="String">String</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span></div>
</div>
<div class="spec-algo" id="EvaluateDereference()">
<span class="spec-call"><a href="#EvaluateDereference()" data-name="EvaluateDereference">EvaluateDereference</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="valueNode">valueNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="value">value</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="valueNode">valueNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="value">value</var> is not an object:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>If <var data-name="value">value</var> does not have an attribute <code>_ref</code>:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>Let <var data-name="ref">ref</var> be the value of the attribute <code>_ref</code> in <var data-name="value">value</var>.</li>
<li>If <var data-name="ref">ref</var> is not a string:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>Let <var data-name="dataset">dataset</var> be the dataset of the query context of <var data-name="scope">scope</var>.</li>
<li>If <var data-name="dataset">dataset</var> is not an array:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>Let <var data-name="result">result</var> be <span class="spec-keyword">null</span>.</li>
<li>For each <var data-name="document">document</var> in <var data-name="dataset">dataset</var>:<ol>
<li>If <var data-name="document">document</var> is an object and has an attribute <code>_id</code>:<ol>
<li>Let <var data-name="id">id</var> be the value of the attribute <code>_id</code> in <var data-name="document">document</var>.</li>
</ol>
</li>
<li>If <span class="spec-call"><a href="#Equal()" data-name="Equal">Equal</a>(<var data-name="ref">ref</var>, <var data-name="id">id</var>)</span> is <span class="spec-keyword">true</span>:<ol>
<li>Set <var data-name="result">result</var> to <var data-name="document">document</var>.</li>
</ol>
</li>
</ol>
</li>
</ol>
</div>
<pre><code>  * Stop the loop.</code></pre>
<ul>
<li>If the dereference expression contains a <span class="spec-nt"><a href="#String" data-name="String">String</a></span>:<ul>
<li>Let <var data-name="name">name</var> be the string value of the <span class="spec-nt"><a href="#String" data-name="String">String</a></span>.</li>
<li>If <var data-name="result">result</var> is an object and contains an attribute <var data-name="name">name</var>:<ul>
<li>Return the <var data-name="value">value</var> of the attribute <var data-name="name">name</var> in <var data-name="result">result</var>.</li>
</ul>
</li>
<li>Otherwise:<ul>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <var data-name="result">result</var>. </li>
</ul>
</section>
</section>
<section id="sec-Precedence-and-associativity" secid="9">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Precedence-and-associativity">9</a></span>Precedence and associativity</h1>
<p>In this specification the various expressions and operators are defined in ambiguously in terms on precedence and associativity. The table below describes the precedence levels used to determine the correct unambiguous interpretation.</p>
<p>From highest to lowest:</p>
<ul>
<li>Level 11: <a href="#sec-Compound-expressions">Compound expressions</a>.</li>
<li>Level 10, prefix: <code>+</code>, <code>!</code>.</li>
<li>Level 9, right-assoative: <a href="#sec-Binary-double-star-operator"></a> <code>**</code>.</li>
<li>Level 8, prefix: <code>-</code>.</li>
<li>Level 7, left-associative: Multiplicatives (<code>*</code>, <code>/</code>, <code>%</code>).</li>
<li>Level 6, left-associative: Additives (<code>+</code>, <code>-</code>),</li>
<li>Level 5, non-associative: Ranges (<code>..</code>, <code>...</code>).</li>
<li>Level 4, non-associative: Comparisons (<code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>,<code>&lt;</code>, <code>&lt;=</code>, <code>in</code>, <code>match</code>).</li>
<li>Level 4, postfix: Ordering (<code>asc</code>, <code>desc</code>).</li>
<li>Level 3, left-associative: <code>&amp;&amp;</code>.</li>
<li>Level 2, left-associative: <code>||</code>.</li>
<li>Level 1, non-associative: <code>=&gt;</code>. </li>
</ul>
</section>
<section id="sec-Functions" secid="10">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Functions">10</a></span>Functions</h1>
<p>Functions provide additional functionality to GROQ queries. They are invoked through a <a href="#sec-Function-call-expression">Function call expression</a>. Note that function arguments are not evaluated eagerly, and it&rsquo;s up to the function to decide which scope the arguments are evaluated it. As such, all functions below take an array of nodes.</p>
<p>An implementation may provide additional functions, but should be aware that this can cause problems when interopting with future versions of GROQ.</p>
</section>
<section id="sec-Namespaces" secid="11">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Namespaces">11</a></span>Namespaces</h1>
<p>Functions are namespaced which allows to group functions by logical scope. A function may be associated with multiple namespaces and behave differently. When a function is called without a namespace, it is by default associated with a &ldquo;<strong>global</strong>&rdquo; namespace.</p>
<section id="sec-Global-namespace" secid="11.1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Global-namespace">11.1</a></span>Global namespace</h2>
<section id="sec-global-coalesce-" secid="11.1.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-global-coalesce-">11.1.1</a></span>global::coalesce()</h3>
<p>The coalesce function returns the first value of the arguments which is not <span class="spec-keyword">null</span>.</p>
<p>global::coalesce(args, scope):</p>
<ul>
<li>For each <var data-name="arg">arg</var> in <var data-name="args">args</var>:<ul>
<li>Let <var data-name="value">value</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="arg">arg</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="value">value</var> is not <span class="spec-keyword">null</span>:<ul>
<li>Return <var data-name="value">value</var>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
</section>
<section id="sec-global-count-" secid="11.1.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-global-count-">11.1.2</a></span>global::count()</h3>
<p>The count function returns the length of an array.</p>
<p>global::count(args, scope):</p>
<ul>
<li>Let <var data-name="baseNode">baseNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is an array:<ul>
<li>Return the length of <var data-name="base">base</var>.</li>
</ul>
</li>
<li>Otherwise:<ul>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
</li>
</ul>
<p>global::countValidate(args):</p>
<ul>
<li>If the length of <var data-name="args">args</var> is not 1:<ul>
<li>Report an error.</li>
</ul>
</li>
</ul>
</section>
<section id="sec-global-dateTime-" secid="11.1.3">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-global-dateTime-">11.1.3</a></span>global::dateTime()</h3>
<p>The <code>dateTime</code> function takes a string or another datatime value, returning a datetime value. This function is idempotent.</p>
<p>global::dateTime(args, scope):</p>
<ul>
<li>Let <var data-name="baseNode">baseNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is a string:<ul>
<li>Try to parse <var data-name="base">base</var> as a datetime using the <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> timestamp format.</li>
<li>If the input is a valid datetime:<ul>
<li>Return the datetime.</li>
</ul>
</li>
</ul>
</li>
<li>If <var data-name="base">base</var> is a datetime value:<ul>
<li>Return <var data-name="base">base</var>.</li>
</ul>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
<p>global::dateTimeValidate(args):</p>
<ul>
<li>If the length of <var data-name="args">args</var> is not 1:<ul>
<li>Report an error.</li>
</ul>
</li>
</ul>
</section>
<section id="sec-global-defined-" secid="11.1.4">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-global-defined-">11.1.4</a></span>global::defined()</h3>
<p>The defined function checks if the argument is not <span class="spec-keyword">null</span>.</p>
<p>global::defined(args, scope):</p>
<ul>
<li>Let <var data-name="baseNode">baseNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is <span class="spec-keyword">null</span>:<ul>
<li>Return <span class="spec-keyword">false</span>.</li>
</ul>
</li>
<li>Otherwise:<ul>
<li>Return <span class="spec-keyword">true</span>.</li>
</ul>
</li>
</ul>
<p>global::definedValidate(args):</p>
<ul>
<li>If the length of <var data-name="args">args</var> is not 1:<ul>
<li>Report an error.</li>
</ul>
</li>
</ul>
</section>
<section id="sec-global-length-" secid="11.1.5">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-global-length-">11.1.5</a></span>global::length()</h3>
<p>The length function returns the length of a string or an array.</p>
<p>global::length(args, scope):</p>
<ul>
<li>Let <var data-name="baseNode">baseNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is a string:<ul>
<li>Return the length of <var data-name="base">base</var>.</li>
</ul>
</li>
<li>If <var data-name="base">base</var> is an array:<ul>
<li>Return the length of <var data-name="base">base</var>.</li>
</ul>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
<p>global::lengthValidate(args):</p>
<ul>
<li>If the length of <var data-name="args">args</var> is not 1:<ul>
<li>Report an error.</li>
</ul>
</li>
</ul>
</section>
<section id="sec-global-references-" secid="11.1.6">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-global-references-">11.1.6</a></span>global::references()</h3>
<p>The references function implicitly takes this value of the current scope and recursively checks whether it contains any references to the given document ID.</p>
<p>global::references(args, scope):</p>
<ul>
<li>Let <var data-name="pathSet">pathSet</var> be an empty array.</li>
<li>For each <var data-name="arg">arg</var> of <var data-name="args">args</var>:<ul>
<li>Let <var data-name="path">path</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="arg">arg</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="path">path</var> is a string:<ul>
<li>Append <var data-name="path">path</var> to <var data-name="pathSet">pathSet</var>.</li>
</ul>
</li>
<li>If <var data-name="path">path</var> is an array:<ul>
<li>Concatenate all strings of <var data-name="path">path</var> to <var data-name="pathSet">pathSet</var>.</li>
</ul>
</li>
</ul>
</li>
<li>If <var data-name="pathSet">pathSet</var> is empty:<ul>
<li>Return <span class="spec-keyword">false</span>.</li>
</ul>
</li>
<li>Let <var data-name="base">base</var> be the this value of <var data-name="scope">scope</var>.</li>
<li>Return the result of <span class="spec-call"><span data-name="HasReferenceTo">HasReferenceTo</span>(<var data-name="base">base</var>, <var data-name="pathSet">pathSet</var>)</span>.</li>
</ul>
<p>global::HasReferenceTo(base, pathSet):</p>
<ul>
<li>If <var data-name="base">base</var> is an array:<ul>
<li>For each <var data-name="value">value</var> in <var data-name="base">base</var>:<ul>
<li>Let <var data-name="result">result</var> be the result of <span class="spec-call"><span data-name="HasReferenceTo">HasReferenceTo</span>(<var data-name="value">value</var>, <var data-name="pathSet">pathSet</var>)</span>.</li>
<li>If <var data-name="result">result</var> is <span class="spec-keyword">true</span>:<ul>
<li>Return <span class="spec-keyword">true</span>.</li>
</ul>
</li>
</ul>
</li>
<li>Return <span class="spec-keyword">false</span>.</li>
</ul>
</li>
<li>If <var data-name="base">base</var> is an object:<ul>
<li>If <var data-name="base">base</var> has an attribute <code>_ref</code>:<ul>
<li>Let <var data-name="ref">ref</var> be the value of the attribute <code>_ref</code> in <var data-name="base">base</var>.</li>
<li>If <var data-name="ref">ref</var> exists in <var data-name="pathSet">pathSet</var>:<ul>
<li>Return <span class="spec-keyword">true</span>.</li>
</ul>
</li>
<li>Otherwise:<ul>
<li>Return <span class="spec-keyword">false</span>.</li>
</ul>
</li>
</ul>
</li>
<li>For each <var data-name="key">key</var> and <var data-name="value">value</var> in <var data-name="base">base</var>:<ul>
<li>Let <var data-name="result">result</var> be the result of <span class="spec-call"><span data-name="HasReferenceTo">HasReferenceTo</span>(<var data-name="value">value</var>, <var data-name="pathSet">pathSet</var>)</span>.</li>
<li>If <var data-name="result">result</var> is <span class="spec-keyword">true</span>:<ul>
<li>Return <span class="spec-keyword">true</span>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Return <span class="spec-keyword">false</span>.</li>
</ul>
<p>global::referencesValidate(args):</p>
<ul>
<li>If the length of <var data-name="args">args</var> is 0:<ul>
<li>Report an error.</li>
</ul>
</li>
</ul>
</section>
<section id="sec-global-round-" secid="11.1.7">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-global-round-">11.1.7</a></span>global::round()</h3>
<p>The round function accepts a number and rounds it to a certain precision.</p>
<p>global::round(args, scope):</p>
<ul>
<li>Let <var data-name="numNode">numNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="num">num</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="numNode">numNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="num">num</var> is not a number:<ul>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
</li>
<li>If the length of <var data-name="args">args</var> is 2:<ul>
<li>Let <var data-name="precNode">precNode</var> be the second element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="prec">prec</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="precNode">precNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="prec">prec</var> is not a number:<ul>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
</li>
</ul>
</li>
<li>Otherwise:<ul>
<li>Let <var data-name="prec">prec</var> be 0.</li>
</ul>
</li>
<li>Return <var data-name="num">num</var> rounded to <var data-name="prec">prec</var> number of digits after the decimal point.</li>
</ul>
<p>global::roundValidate(args):</p>
<ul>
<li>If the length of <var data-name="args">args</var> is less than 1 or greater than 2:<ul>
<li>Report an error.</li>
</ul>
</li>
</ul>
</section>
<section id="sec-global-select-" secid="11.1.8">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-global-select-">11.1.8</a></span>global::select()</h3>
<p>The select function chooses takes a variable number of arguments that are either pairs or any other type and iterates over them. When encountering a pair whose left-hand value evaluates to <span class="spec-keyword">true</span>, the right-hand value is returned immediately. When encountering a non-pair argument, that argument is returned immediately. Falls back to returning <span class="spec-keyword">null</span>.</p>
<p>global::select(args, scope):</p>
<ul>
<li>For each <var data-name="arg">arg</var> in <var data-name="args">args</var>:<ul>
<li>If <var data-name="arg">arg</var> is a <span class="spec-nt"><a href="#Pair" data-name="Pair">Pair</a></span>:<ul>
<li>Let <var data-name="condNode">condNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> of the <span class="spec-nt"><a href="#Pair" data-name="Pair">Pair</a></span>.</li>
<li>Let <var data-name="resultNode">resultNode</var> be the second <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> of the <span class="spec-nt"><a href="#Pair" data-name="Pair">Pair</a></span>.</li>
<li>Let <var data-name="cond">cond</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="condNode">condNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="cond">cond</var> is <span class="spec-keyword">true</span>:<ul>
<li>Return the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="resultNode">resultNode</var>, <var data-name="scope">scope</var>)</span>.</li>
</ul>
</li>
</ul>
</li>
<li>Otherwise:<ul>
<li>Return the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="arg">arg</var>, <var data-name="scope">scope</var>)</span>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>global::selectValidate(args):</p>
<ul>
<li>Let <var data-name="seenDefault">seenDefault</var> be <span class="spec-keyword">false</span>.</li>
<li>For each <var data-name="arg">arg</var> in <var data-name="args">args</var>:<ul>
<li>If <var data-name="seenDefault">seenDefault</var> is <span class="spec-keyword">true</span>:<ul>
<li>Report an error.</li>
</ul>
</li>
<li>If <var data-name="arg">arg</var> is not a <span class="spec-nt"><a href="#Pair" data-name="Pair">Pair</a></span>:<ul>
<li>Set <var data-name="seenDefault">seenDefault</var> to <span class="spec-keyword">true</span>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="sec-global-string-" secid="11.1.9">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-global-string-">11.1.9</a></span>global::string()</h3>
<p>The string function returns the string representation of scalar values or <span class="spec-keyword">null</span> for any other values.</p>
<p>global::string(args, scope):</p>
<ul>
<li>Let <var data-name="node">node</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="val">val</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="node">node</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="val">val</var> is <span class="spec-keyword">true</span>:<ul>
<li>Return the string <code>"true"</code></li>
</ul>
</li>
<li>If <var data-name="val">val</var> is <span class="spec-keyword">false</span>:<ul>
<li>Return the string <code>"false"</code></li>
</ul>
</li>
<li>If <var data-name="val">val</var> is a string:<ul>
<li>Return <var data-name="val">val</var>.</li>
</ul>
</li>
<li>If <var data-name="val">val</var> is a number:<ul>
<li>Return a string representation of the number.</li>
</ul>
</li>
<li>If <var data-name="val">val</var> is a datetime:<ul>
<li>Return the datetime in the <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> timestamp format with a Z suffix.</li>
</ul>
</li>
<li>Otherwise:<ul>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
</li>
</ul>
<p>global::stringValidate(args):</p>
<ul>
<li>If the length of <var data-name="args">args</var> is not 1:<ul>
<li>Report an error.</li>
</ul>
</li>
</ul>
</section>
<section id="sec-global-boost-" secid="11.1.10">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-global-boost-">11.1.10</a></span>global::boost()</h3>
<p>The <code>boost</code> function accepts an expression and a boost value, and increases or decreases the score computed by <code>score()</code> (see <a href="#sec-Pipe-functions">&ldquo;Pipe functions&rdquo;</a>) accordingly. <code>boost</code> can only be used within the argument list to <code>score()</code>.</p>
<pre data-language="groq"><code>* | score(boost(title matches "milk", 5.0), body matches "milk")
</code></pre>
<p>The expression must be a predicate expressions that evaluates to a single boolean value. Any other result value is ignored.</p>
<p>The value argument must be a number &ge; 0.</p>
<p>The return value is the same as the input predicate. Internally, the scoring execution model uses the provided boost value to increase the computed score if the predicate matches.</p>
<div class="spec-algo" id="boost()">
<span class="spec-call"><a href="#boost()" data-name="boost">boost</a>(<var data-name="args">args</var>, <var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="predicateNode">predicateNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="result">result</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="predicateNode">predicateNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="numNode">numNode</var> be the second element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="num">num</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="numNode">numNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="num">num</var> is not a number:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>If <var data-name="num">num</var> is negative:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
<div class="spec-algo" id="boostValidate()">
<span class="spec-call"><a href="#boostValidate()" data-name="boostValidate">boostValidate</a>(<var data-name="args">args</var>)</span><ol>
<li>If the length of <var data-name="args">args</var> is not 2:<ol>
<li>Report an error.</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-global-lower-" secid="11.1.11">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-global-lower-">11.1.11</a></span>global::lower()</h3>
<p>The lower function returns lowercased string.</p>
<p>global::lower(args, scope):</p>
<ul>
<li>Let <var data-name="value">value</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="arg">arg</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="value">value</var> is not <span class="spec-keyword">null</span>:<ul>
<li>Return lowercase form of <var data-name="value">value</var>.</li>
</ul>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
<p>global::lowerValidate(args):</p>
<ul>
<li>If the length of <var data-name="args">args</var> is not 1:<ul>
<li>Report an error.</li>
</ul>
</li>
</ul>
</section>
<section id="sec-global-upper-" secid="11.1.12">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-global-upper-">11.1.12</a></span>global::upper()</h3>
<p>The upper function returns uppercased string.</p>
<p>global::upper(args, scope):</p>
<ul>
<li>Let <var data-name="value">value</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="arg">arg</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="value">value</var> is not <span class="spec-keyword">null</span>:<ul>
<li>Return uppercase form of <var data-name="value">value</var>.</li>
</ul>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
<p>global::upperValidate(args):</p>
<ul>
<li>If the length of <var data-name="args">args</var> is not 1:<ul>
<li>Report an error.</li>
</ul>
</li>
</ul>
<p>In addition to the functions mentioned above, constructors for <a href="#sec-Extensions">extensions</a> are global as well. </p>
</section>
</section>
</section>
<section id="sec-Pipe-functions" secid="12">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Pipe-functions">12</a></span>Pipe functions</h1>
<p>Pipe functions provide additional functionalty to GROQ queries. They are invoked through a <a href="#sec-Pipe-function-call-expression">Pipe function call expression</a>. They differ from regular functions in that they always accept an array as input and returns another array (or <span class="spec-keyword">null</span>). As such, the syntax is optimized for chaining (the array it works on comes on the left-hand side instead of being an argument):</p>
<pre><code>*[_type == "person"] | order(name) | {age}
</code></pre>
<div id="note-88a44" class="spec-note">
<a href="#note-88a44">Note</a>
that function arguments are not evaluated eagerly, and it&rsquo;s up to the function to decide which scope the arguments are evaluated in. All definitions below take an array of nodes.</div>
<p>An implementation may provide additional pipe functions, but should be aware that this can cause problems when interopting with future versions of GROQ.</p>
<section id="sec-global-order-" secid="12.1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-global-order-">12.1</a></span>global::order()</h2>
<p>The order function sorts an array based on arbitrary expressions.</p>
<div class="spec-algo" id="order()">
<span class="spec-call"><a href="#order()" data-name="order">order</a>(<var data-name="base">base</var>, <var data-name="args">args</var>, <var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="cmp">cmp</var> be a function which takes two arguments and returns either <span class="spec-nt"><span data-name="Less">Less</span></span>, <span class="spec-nt"><span data-name="Equal">Equal</span></span> or <span class="spec-nt"><span data-name="Greater">Greater</span></span>.</li>
<li>Define <span class="spec-call"><span data-name="cmp">cmp</span>(<var data-name="left">left</var>, <var data-name="right">right</var>)</span> as follows:<ol>
<li>Let <var data-name="leftScope">leftScope</var> be the result of <span class="spec-call"><a href="#NewNestedScope()" data-name="NewNestedScope">NewNestedScope</a>(<var data-name="left">left</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightScope">rightScope</var> be the result of <span class="spec-call"><a href="#NewNestedScope()" data-name="NewNestedScope">NewNestedScope</a>(<var data-name="right">right</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>For each <var data-name="argNode">argNode</var> of <var data-name="args">args</var>:<ol>
<li>Let <var data-name="direction">direction</var> be <span class="spec-nt"><span data-name="Normal">Normal</span></span>.</li>
</ol>
</li>
<li>Let <var data-name="valueNode">valueNode</var> be <var data-name="argNode">argNode</var>.<ol>
<li>If <var data-name="valueNode">valueNode</var> is an <span class="spec-nt"><a href="#Asc" data-name="Asc">Asc</a></span> operator:<ol>
<li>Set <var data-name="valueNode">valueNode</var> to be the Expression of the <span class="spec-nt"><a href="#Asc" data-name="Asc">Asc</a></span> operator.</li>
</ol>
</li>
<li>Else if <var data-name="valueNode">valueNode</var> is a <span class="spec-nt"><a href="#Desc" data-name="Desc">Desc</a></span> operator:<ol>
<li>Set direction to <span class="spec-nt"><span data-name="Reverse">Reverse</span></span>.</li>
</ol>
</li>
<li>Set <var data-name="valueNode">valueNode</var> to be the Expression of the <span class="spec-nt"><a href="#Desc" data-name="Desc">Desc</a></span> operator.</li>
<li>Let <var data-name="leftValue">leftValue</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="valueNode">valueNode</var>, <var data-name="leftScope">leftScope</var>)</span>.</li>
<li>Let <var data-name="rightValue">rightValue</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="valueNode">valueNode</var>, <var data-name="rightScope">rightScope</var>)</span>.</li>
<li>Let <var data-name="order">order</var> be the result of <span class="spec-call"><a href="#TotalCompare()" data-name="TotalCompare">TotalCompare</a>(<var data-name="leftValue">leftValue</var>, <var data-name="rightValue">rightValue</var>)</span>.</li>
<li>If <var data-name="direction">direction</var> is <span class="spec-nt"><span data-name="Reverse">Reverse</span></span> and <var data-name="order">order</var> is <span class="spec-nt"><span data-name="Less">Less</span></span>:<ol>
<li>Set <var data-name="order">order</var> to <span class="spec-nt"><span data-name="Greater">Greater</span></span>.</li>
</ol>
</li>
<li>Else if <var data-name="direction">direction</var> is <span class="spec-nt"><span data-name="Reverse">Reverse</span></span> and <var data-name="order">order</var> is <span class="spec-nt"><span data-name="Greater">Greater</span></span>:<ol>
<li>Set <var data-name="order">order</var> to <span class="spec-nt"><span data-name="Less">Less</span></span>.</li>
</ol>
</li>
<li>If <var data-name="order">order</var> is not <span class="spec-nt"><span data-name="Equal">Equal</span></span>:<ol>
<li>Return <var data-name="order">order</var>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <span class="spec-nt"><span data-name="Equal">Equal</span></span>.</li>
</ol>
</li>
<li>Return a sorted array using <var data-name="cmp">cmp</var> as the comparator function.</li>
</ol>
</div>
<div class="spec-algo" id="orderValidate()">
<span class="spec-call"><a href="#orderValidate()" data-name="orderValidate">orderValidate</a>(<var data-name="args">args</var>)</span><ol>
<li>If the length of <var data-name="args">args</var> is 0:<ol>
<li>Report an error.</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-global-score-" secid="12.2">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-global-score-">12.2</a></span>global::score()</h2>
<p>The <code>score</code> function assigns a score to an array of results, based on one or more scoring expressions. The <code>score</code> function may only be used as a pipe function.</p>
<pre data-language="groq"><code>*[_type == "listing"] | score(body match "jacuzzi")
</code></pre>
<p>In this query, anything where <code>body match "jacuzzi"</code> returns true will be scored higher than other results. Multiple expressions can be used:</p>
<pre data-language="groq"><code>*[_type == "listing"] | score(body match "jacuzzi", bedrooms &gt; 2, available &amp;&amp; !inContract)
</code></pre>
<p>When multiple expressions are provided, the scores are merged into a single score for each result (see <a href="#sec-Score-evaluation">score evaluation</a>)</p>
<p>Only predicate expressions &mdash; that is, expressions that evaluate to a single boolean value or to <code>null</code> &mdash; may be used, including <code>boost()</code>. However, an implementation can put further constraints on which expressions are permitted as a score expression for optimization purposes.</p>
<p>Each score is assigned to the result as the new attribute <code>_score</code>, set to a positive number.</p>
<p>Scoring is additive. That is <code>* | score(a == 1) | score(b == 2)</code> is equivalent to <code>* | score(a == 1, b == 2)</code>.</p>
<div class="spec-algo" id="score()">
<span class="spec-call"><a href="#score()" data-name="score">score</a>(<var data-name="base">base</var>, <var data-name="args">args</var>, <var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="baseNode">baseNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is an array:<ol>
<li>Let <var data-name="result">result</var> be an empty <span class="spec-nt"><a href="#Array" data-name="Array">Array</a></span>.</li>
<li>For each <var data-name="element">element</var> of <var data-name="base">base</var>:<ol>
<li>If <var data-name="element">element</var> is an object:<ol>
<li>Let <var data-name="elementScope">elementScope</var> be the result of <span class="spec-call"><a href="#NewNestedScope()" data-name="NewNestedScope">NewNestedScope</a>(<var data-name="element">element</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="newElement">newElement</var> be a new empty <span class="spec-nt"><a href="#Object" data-name="Object">Object</a></span></li>
<li>Add the attributes from <var data-name="element">element</var> to it.</li>
<li>If <var data-name="element">element</var> already has a <code>_score</code>:<ol>
<li>Let <var data-name="scoreSum">scoreSum</var> be the current value of <code>_score</code>.</li>
<li>Otherwise let <var data-name="scoreSum">scoreSum</var> be 1.0.</li>
</ol>
</li>
<li>For each <var data-name="predicateNode">predicateNode</var> of <var data-name="args">args</var>:<ol>
<li>Let <var data-name="scoreValue">scoreValue</var> be the result of <span class="spec-call"><a href="#EvaluateScore()" data-name="EvaluateScore">EvaluateScore</a>(<var data-name="predicateNode">predicateNode</var>, <var data-name="elementScope">elementScope</var>)</span>.</li>
<li>Add <var data-name="scoreValue">scoreValue</var> to <var data-name="scoreSum">scoreSum</var>.</li>
</ol>
</li>
<li>Add the attribute <code>_score</code> set to <var data-name="scoreSum">scoreSum</var>.</li>
<li>Add <var data-name="newElement">newElement</var> to <var data-name="result">result</var>.</li>
</ol>
</li>
<li>Otherwise add <var data-name="element">element</var> to <var data-name="result">result</var>.</li>
</ol>
</li>
<li>Return <var data-name="result">result</var> sorted by the score, in descending order.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
<div class="spec-algo" id="EvaluateScore()">
<span class="spec-call"><a href="#EvaluateScore()" data-name="EvaluateScore">EvaluateScore</a>(<var data-name="expr">expr</var>, <var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="evaluator">evaluator</var> be the score evaluator of <var data-name="expr">expr</var>.</li>
<li>Return the result of <span class="spec-call"><span data-name="evaluator">evaluator</span>(<var data-name="scope">scope</var>)</span>.</li>
</ol>
</div>
<div class="spec-algo" id="scoreValidate()">
<span class="spec-call"><a href="#scoreValidate()" data-name="scoreValidate">scoreValidate</a>(<var data-name="args">args</var>)</span><ol>
<li>If the length of <var data-name="args">args</var> is 0:<ol>
<li>Report an error. </li>
</ol>
</li>
</ol>
</div>
</section>
</section>
<section id="sec-Vendor-functions" secid="13">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Vendor-functions">13</a></span>Vendor functions</h1>
<p>An implementation is free to introduce additional functions than what is presented in this specification, but this is problematic if a function with the same name is introduced in a future version. The following section defines optional <em>vendor functions</em> which are guaranteed to never be a regular function in a future specfication. There&rsquo;s also a short description of each vendor function so different implementations can attempt to be compatible with each other. The description is intentially brief and it&rsquo;s up to the vendor to define it completely.</p>
<section id="sec-global-identity-" secid="13.1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-global-identity-">13.1</a></span>global::identity()</h2>
<p>The identity function should accept zero arguments and return a string which represents the identity of the client executing the query.</p>
</section>
<section id="sec-global-path-" secid="13.2">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-global-path-">13.2</a></span>global::path()</h2>
<p>The path function should accept a single argument and return a path object. </p>
</section>
</section>
<section id="sec-Extensions" secid="14">
<h1><span class="spec-secid" title="link to this section"><a href="#sec-Extensions">14</a></span>Extensions</h1>
<p>Extensions are the capabilities which extend GROQ queries beyond basic Spec. These capabilities can include function namespaces, functions and operators. However, extensions can not introduce a new syntax.</p>
<section id="sec-Portable-Text-Extension" secid="14.1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Portable-Text-Extension">14.1</a></span>Portable Text Extension</h2>
<p>Functions available in Portable text extension are grouped under <code>pt</code> namespace except for the constructor which is global.</p>
<section id="sec-pt-type" secid="14.1.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-pt-type">14.1.1</a></span>pt type</h3>
<p>PT type represents an object following <a href="https://github.com/portabletext/portabletext">portable text spec</a>.</p>
</section>
<section id="sec-global-pt-" secid="14.1.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-global-pt-">14.1.2</a></span>global::pt()</h3>
<p>This function takes in an object or an array of objects, and returns a PT value.</p>
<p>global::pt(args, scope):</p>
<ul>
<li>Let <var data-name="baseNode">baseNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is an object:<ul>
<li>Try to parse it as Portable Text Block:</li>
<li>If <var data-name="base">base</var> is a valid Portable Text Block:<ul>
<li>Return <var data-name="base">base</var>.</li>
</ul>
</li>
</ul>
</li>
<li>If <var data-name="base">base</var> is an array of objects:<ul>
<li>Try to parse it as an array of Portable Text blocks:<ul>
<li>If all elements in <var data-name="base">base</var> array are valid Portable Text blocks:<ul>
<li>Return <var data-name="base">base</var>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Otherwise:<ul>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
</li>
</ul>
<p>global::ptValidate(args):</p>
<ul>
<li>If the length of <var data-name="args">args</var> is not 1:<ul>
<li>Report an error.</li>
</ul>
</li>
</ul>
</section>
<section id="sec-pt-text-" secid="14.1.3">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-pt-text-">14.1.3</a></span>pt::text()</h3>
<p>This function takes in a PT value and returns a string versions of text. PT value which consists of more than one Portable text block has blocks appended with double newline character (<code>\n\n</code>) in the string version. </p>
<p>pt::text(args, scope):</p>
<ul>
<li>Let <var data-name="baseNode">baseNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is an object:<ul>
<li>Try to parse it as Portable Text Block:</li>
<li>If <var data-name="base">base</var>is a valid Portable Text Block:<ul>
<li>Return string version of text in <var data-name="base">base</var>.</li>
</ul>
</li>
</ul>
</li>
<li>If <var data-name="base">base</var> is an array of objects:<ul>
<li>Try to parse it as an array of Portable Text blocks:</li>
<li>If all elements in <var data-name="base">base</var> array are valid Portable Text blocks:<ul>
<li>Return string version of text in <var data-name="base">base</var>.</li>
</ul>
</li>
</ul>
</li>
<li>Otherwise:<ul>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
</li>
</ul>
<p>pt::textValidate(args):</p>
<ul>
<li>If the length of <var data-name="args">args</var> is not 1:<ul>
<li>Report an error.</li>
</ul>
</li>
</ul>
</section>
</section>
<section id="sec-Geography-Extension" secid="14.2">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Geography-Extension">14.2</a></span>Geography Extension</h2>
<p>Functions available in Geography extension are grouped under <code>geo</code> namespace except for the constructor which is global.</p>
<section id="sec-geo-type" secid="14.2.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-geo-type">14.2.1</a></span>geo type</h3>
<p>The geo type represents a geography and can contain points, lines, and polygons which can be expressed with a single latitude/longitude coordinate, or as a GeoJSON object. Concretely, an object is coerced to the geo type if:</p>
<ol>
<li>If the object is coerced to a geographic point, that is it has a key <code>lat</code> for latitude and a key <code>lng</code> or <code>lon</code> for longitude (but not both).</li>
<li>If the object has <a href="https://tools.ietf.org/html/rfc7946">GeoJSON</a> representation.</li>
</ol>
<p>Geo type supports following GeoJSON Geometry Objects:</p>
<ol>
<li><code>Position</code></li>
<li><code>Point</code></li>
<li><code>MultiPoint</code></li>
<li><code>LineString</code></li>
<li><code>MultiLineString</code></li>
<li><code>Polygon</code></li>
<li><code>MultiPolygon</code></li>
<li><code>GeometryCollection</code></li>
</ol>
<p>And, it does not support:</p>
<ol>
<li>GeoJSON Object <code>Feature</code> and <code>FeatureCollection</code>. </li>
<li>Arrays of geographic values. Instead, one of the GeoJSON <code>Multi</code> types should be used.</li>
</ol>
</section>
<section id="sec-global-geo-" secid="14.2.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-global-geo-">14.2.2</a></span>global::geo()</h3>
<p>This function is a constructor for geographic value. It takes an object or another geo value, returning a geo value.</p>
<p>global::geo(args, scope):</p>
<ul>
<li>Let <var data-name="baseNode">baseNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is an object:<ul>
<li>Try to parse it as Geo Point and GeoJSON:</li>
<li>If <var data-name="base">base</var> is a valid geo value:<ul>
<li>Return <var data-name="base">base</var>.</li>
</ul>
</li>
</ul>
</li>
<li>If <var data-name="base">base</var> is a geo value:<ul>
<li>Return <var data-name="base">base</var>.</li>
</ul>
</li>
<li>Otherwise:<ul>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
</li>
</ul>
<p>global::geoValidate(args):</p>
<ul>
<li>If the length of <var data-name="args">args</var> is not 1:<ul>
<li>Report an error.</li>
</ul>
</li>
</ul>
</section>
<section id="sec-geo-contains-" secid="14.2.3">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-geo-contains-">14.2.3</a></span>geo::contains()</h3>
<p>Returns true if first geo argument completely contains the second one, using a planar (non-spherical) coordinate system. Both geo argument can be any geo value. A geo value is considered contained if all its points are within the boundaries of the first geo value. For <code>MultiPolygon</code>, it&rsquo;s sufficient that only one of the polygons contains the first geo value.</p>
<p>geo::contains(args, scope):</p>
<ul>
<li>Let <var data-name="firstNode">firstNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="secondNode">secondNode</var> be the second element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="first">first</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="firstNode">firstNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="second">second</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="secondNode">secondNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="first">first</var> or <var data-name="second">second</var> is a not a geo value:<ul>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
</li>
<li>If <var data-name="first">first</var> completely contains <var data-name="second">second</var>:<ul>
<li>Return <span class="spec-keyword">true</span>.</li>
</ul>
</li>
<li>Otherwise:<ul>
<li>Return <span class="spec-keyword">false</span>.</li>
</ul>
</li>
</ul>
<p>geo::containsValidate(args):</p>
<ul>
<li>If the length of <var data-name="args">args</var> is not 2:<ul>
<li>Report an error.</li>
</ul>
</li>
</ul>
</section>
<section id="sec-geo-intersects-" secid="14.2.4">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-geo-intersects-">14.2.4</a></span>geo::intersects()</h3>
<p>This function takes two geo values, and returns true if they intersect in a planar (non-spherical) coordinate system. The arguments can be any geo values. A geo value intersects with another if it shares any geometric points with the second value; for example, a line crossing a polygon.</p>
<p>geo::intersects(args, scope):</p>
<ul>
<li>Let <var data-name="firstNode">firstNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="secondNode">secondNode</var> be the second element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="first">first</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="firstNode">firstNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="second">second</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="secondNode">secondNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="first">first</var> or <var data-name="second">second</var> is a not a geo value:<ul>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
</li>
<li>If <var data-name="first">first</var> intersects <var data-name="second">second</var>:<ul>
<li>Return <span class="spec-keyword">true</span>.</li>
</ul>
</li>
<li>Otherwise:<ul>
<li>Return <span class="spec-keyword">false</span>.</li>
</ul>
</li>
</ul>
<p>geo::intersectsValidate(args):</p>
<ul>
<li>If the length of <var data-name="args">args</var> is not 2:<ul>
<li>Report an error.</li>
</ul>
</li>
</ul>
</section>
<section id="sec-geo-distance-" secid="14.2.5">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-geo-distance-">14.2.5</a></span>geo::distance()</h3>
<p>This functions accepts two geo values, which must be point values, and returns the distance in meters. While exact algorithm is implementation-defined &mdash; for example, it may use the <a href="https://en.wikipedia.org/wiki/Haversine_formula">Haversine formula</a> &mdash; it should use as close an approximation to a real Earth distance as possible.</p>
<p>geo::distance(args, scope):</p>
<ul>
<li>Let <var data-name="firstNode">firstNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="secondNode">secondNode</var> be the second element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="first">first</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="firstNode">firstNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="second">second</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="secondNode">secondNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="first">first</var> or <var data-name="second">second</var> is a not a geo value:<ul>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
</li>
<li>If <var data-name="first">first</var> or <var data-name="second">second</var> is a not a Geo Point or GeoJSON Point:<ul>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
</li>
<li>Let <var data-name="distance">distance</var> be the geographic distance between <var data-name="first">first</var> and <var data-name="second">second</var>:<ul>
<li>Return <var data-name="distance">distance</var>.</li>
</ul>
</li>
<li>Otherwise:<ul>
<li>Return <span class="spec-keyword">null</span>.</li>
</ul>
</li>
</ul>
<p>geo::distanceValidate(args):</p>
<ul>
<li>If the length of <var data-name="args">args</var> is not 2:<ul>
<li>Report an error. </li>
</ul>
</li>
</ul>
</section>
</section>
</section>
<section id="index" secid="index" class="spec-index">
<h1>
<span class="spec-secid" title="link to the index"><a href="#index">¬ß</a></span>Index</h1>
<ol>
<li><a href="#And">And</a></li>
<li><a href="#Array">Array</a></li>
<li><a href="#ArrayElement">ArrayElement</a></li>
<li><a href="#ArrayElements">ArrayElements</a></li>
<li><a href="#Asc">Asc</a></li>
<li><a href="#AttributeAccess">AttributeAccess</a></li>
<li><a href="#Boolean">Boolean</a></li>
<li><a href="#boost()">boost</a></li>
<li><a href="#boostValidate()">boostValidate</a></li>
<li><a href="#Comment">Comment</a></li>
<li><a href="#CommentChar">CommentChar</a></li>
<li><a href="#Comparison">Comparison</a></li>
<li><a href="#ComparisonOperator">ComparisonOperator</a></li>
<li><a href="#CompoundExpression">CompoundExpression</a></li>
<li><a href="#ConstantEvaluate()">ConstantEvaluate</a></li>
<li><a href="#Decimal">Decimal</a></li>
<li><a href="#Dereference">Dereference</a></li>
<li><a href="#Desc">Desc</a></li>
<li><a href="#DetermineName()">DetermineName</a></li>
<li><a href="#Digit">Digit</a></li>
<li><a href="#DisambiguateSquareBracketExpression()">DisambiguateSquareBracketExpression</a></li>
<li><a href="#DoubleStringCharacter">DoubleStringCharacter</a></li>
<li><a href="#ElementAccess">ElementAccess</a></li>
<li><a href="#Equal()">Equal</a></li>
<li><a href="#Equality">Equality</a></li>
<li><a href="#EqualityOperator">EqualityOperator</a></li>
<li><a href="#EscapeSequence">EscapeSequence</a></li>
<li><a href="#Evaluate()">Evaluate</a></li>
<li><a href="#EvaluateAnd()">EvaluateAnd</a></li>
<li><a href="#EvaluateArray()">EvaluateArray</a></li>
<li><a href="#EvaluateAttributeAccess()">EvaluateAttributeAccess</a></li>
<li><a href="#EvaluateComparison()">EvaluateComparison</a></li>
<li><a href="#EvaluateDereference()">EvaluateDereference</a></li>
<li><a href="#EvaluateElementAccess()">EvaluateElementAccess</a></li>
<li><a href="#EvaluateEquality()">EvaluateEquality</a></li>
<li><a href="#EvaluateEverything()">EvaluateEverything</a></li>
<li><a href="#EvaluateFilter()">EvaluateFilter</a></li>
<li><a href="#EvaluateFuncCall()">EvaluateFuncCall</a></li>
<li><a href="#EvaluateIn()">EvaluateIn</a></li>
<li><a href="#EvaluateMatch()">EvaluateMatch</a></li>
<li><a href="#EvaluateMinus()">EvaluateMinus</a></li>
<li><a href="#EvaluateNot()">EvaluateNot</a></li>
<li><a href="#EvaluateObject()">EvaluateObject</a></li>
<li><a href="#EvaluateOr()">EvaluateOr</a></li>
<li><a href="#EvaluatePair()">EvaluatePair</a></li>
<li><a href="#EvaluateParent()">EvaluateParent</a></li>
<li><a href="#EvaluateParenthesis()">EvaluateParenthesis</a></li>
<li><a href="#EvaluatePercent()">EvaluatePercent</a></li>
<li><a href="#EvaluatePipeFuncCall()">EvaluatePipeFuncCall</a></li>
<li><a href="#EvaluatePlus()">EvaluatePlus</a></li>
<li><a href="#EvaluateProjection()">EvaluateProjection</a></li>
<li><a href="#EvaluateRange()">EvaluateRange</a></li>
<li><a href="#EvaluateScore()">EvaluateScore</a></li>
<li><a href="#EvaluateSlash()">EvaluateSlash</a></li>
<li><a href="#EvaluateSlice()">EvaluateSlice</a></li>
<li><a href="#EvaluateStar()">EvaluateStar</a></li>
<li><a href="#EvaluateStarStar()">EvaluateStarStar</a></li>
<li><a href="#EvaluateThis()">EvaluateThis</a></li>
<li><a href="#EvaluateThisAttribute()">EvaluateThisAttribute</a></li>
<li><a href="#EvaluateUnaryMinus()">EvaluateUnaryMinus</a></li>
<li><a href="#EvaluateUnaryPlus()">EvaluateUnaryPlus</a></li>
<li><a href="#Everything">Everything</a></li>
<li><a href="#ExclusiveRange">ExclusiveRange</a></li>
<li><a href="#ExecuteQuery()">ExecuteQuery</a></li>
<li><a href="#ExponentMarker">ExponentMarker</a></li>
<li><a href="#Expression">Expression</a></li>
<li><a href="#Filter">Filter</a></li>
<li><a href="#Fractional">Fractional</a></li>
<li><a href="#FuncCall">FuncCall</a></li>
<li><a href="#FuncCallArgs">FuncCallArgs</a></li>
<li><a href="#FuncIdentifier">FuncIdentifier</a></li>
<li><a href="#FuncNamespace">FuncNamespace</a></li>
<li><a href="#HexDigit">HexDigit</a></li>
<li><a href="#HexLetter">HexLetter</a></li>
<li><a href="#Identifier">Identifier</a></li>
<li><a href="#In">In</a></li>
<li><a href="#InclusiveRange">InclusiveRange</a></li>
<li><a href="#Integer">Integer</a></li>
<li><a href="#Literal">Literal</a></li>
<li><a href="#Match">Match</a></li>
<li><a href="#MatchAnalyzePattern()">MatchAnalyzePattern</a></li>
<li><a href="#MatchTokenize()">MatchTokenize</a></li>
<li><a href="#Minus">Minus</a></li>
<li><a href="#NewNestedScope()">NewNestedScope</a></li>
<li><a href="#NewRootScope()">NewRootScope</a></li>
<li><a href="#Not">Not</a></li>
<li><a href="#Null">Null</a></li>
<li><a href="#Number">Number</a></li>
<li><a href="#Object">Object</a></li>
<li><a href="#ObjectAttribute">ObjectAttribute</a></li>
<li><a href="#ObjectAttributes">ObjectAttributes</a></li>
<li><a href="#OperatorCall">OperatorCall</a></li>
<li><a href="#Or">Or</a></li>
<li><a href="#order()">order</a></li>
<li><a href="#orderValidate()">orderValidate</a></li>
<li><a href="#Pair">Pair</a></li>
<li><a href="#Parent">Parent</a></li>
<li><a href="#Parenthesis">Parenthesis</a></li>
<li><a href="#PartialCompare()">PartialCompare</a></li>
<li><a href="#Percent">Percent</a></li>
<li><a href="#PipeFuncCall">PipeFuncCall</a></li>
<li><a href="#Plus">Plus</a></li>
<li><a href="#Projection">Projection</a></li>
<li><a href="#Range">Range</a></li>
<li><a href="#ScientificNotation">ScientificNotation</a></li>
<li><a href="#score()">score</a></li>
<li><a href="#scoreValidate()">scoreValidate</a></li>
<li><a href="#Sign">Sign</a></li>
<li><a href="#SimpleExpression">SimpleExpression</a></li>
<li><a href="#SingleEscapeSequence">SingleEscapeSequence</a></li>
<li><a href="#SingleStringCharacter">SingleStringCharacter</a></li>
<li><a href="#Slash">Slash</a></li>
<li><a href="#Slice">Slice</a></li>
<li><a href="#SourceCharacter">SourceCharacter</a></li>
<li><a href="#SquareBracketExpression">SquareBracketExpression</a></li>
<li><a href="#Star">Star</a></li>
<li><a href="#StarStar">StarStar</a></li>
<li><a href="#String">String</a></li>
<li><a href="#This">This</a></li>
<li><a href="#ThisAttribute">ThisAttribute</a></li>
<li><a href="#TotalCompare()">TotalCompare</a></li>
<li><a href="#TypeOrder()">TypeOrder</a></li>
<li><a href="#UnaryMinus">UnaryMinus</a></li>
<li><a href="#UnaryPlus">UnaryPlus</a></li>
<li><a href="#UnicodeEscapeSequence">UnicodeEscapeSequence</a></li>
<li><a href="#Validate()">Validate</a></li>
<li><a href="#ValidateAsc()">ValidateAsc</a></li>
<li><a href="#ValidateDesc()">ValidateDesc</a></li>
<li><a href="#ValidateElementAccess()">ValidateElementAccess</a></li>
<li><a href="#ValidateFuncCall()">ValidateFuncCall</a></li>
<li><a href="#ValidateObject()">ValidateObject</a></li>
<li><a href="#ValidateObjectAttribute()">ValidateObjectAttribute</a></li>
<li><a href="#ValidatePipeFuncCall()">ValidatePipeFuncCall</a></li>
<li><a href="#ValidateSlice()">ValidateSlice</a></li>
<li><a href="#WhiteSpace">WhiteSpace</a></li>
</ol>
</section>
</article>
<footer>
Written in <a href="https://spec-md.com" target="_blank">Spec Markdown</a>.</footer>
<input hidden class="spec-sidebar-toggle" type="checkbox" id="spec-sidebar-toggle" aria-hidden /><label for="spec-sidebar-toggle" aria-hidden><div class="spec-sidebar-button">&#x2630;</div></label>
<div class="spec-sidebar" aria-hidden>
<div class="spec-toc">
<div class="title"><a href="#">GROQ</a></div>
<ol><li id="_sidebar_1"><a href="#sec-undefined.Overview"><span class="spec-secid">1</span>Overview</a></li>
<li id="_sidebar_2"><a href="#sec-Syntax"><span class="spec-secid">2</span>Syntax</a>
<input hidden class="toggle" type="checkbox" id="_toggle_2" /><label for="_toggle_2"></label>
<ol>
<li id="_sidebar_2.1"><a href="#sec-JSON-Superset"><span class="spec-secid">2.1</span>JSON Superset</a></li>
<li id="_sidebar_2.2"><a href="#sec-White-Space"><span class="spec-secid">2.2</span>White Space</a></li>
<li id="_sidebar_2.3"><a href="#sec-Comments"><span class="spec-secid">2.3</span>Comments</a></li>
<li id="_sidebar_2.4"><a href="#sec-Identifier"><span class="spec-secid">2.4</span>Identifier</a></li>
<li id="_sidebar_2.5"><a href="#sec-Digits"><span class="spec-secid">2.5</span>Digits</a></li>
<li id="_sidebar_2.6"><a href="#sec-Expression"><span class="spec-secid">2.6</span>Expression</a></li>
</ol>
</li>
<li id="_sidebar_3"><a href="#sec-Execution"><span class="spec-secid">3</span>Execution</a>
<input hidden class="toggle" type="checkbox" id="_toggle_3" /><label for="_toggle_3"></label>
<ol>
<li id="_sidebar_3.1"><a href="#sec-Execution.Overview"><span class="spec-secid">3.1</span>Overview</a></li>
<li id="_sidebar_3.2"><a href="#sec-Query-context"><span class="spec-secid">3.2</span>Query context</a></li>
<li id="_sidebar_3.3"><a href="#sec-Scope"><span class="spec-secid">3.3</span>Scope</a></li>
<li id="_sidebar_3.4"><a href="#sec-Expression-validation"><span class="spec-secid">3.4</span>Expression validation</a></li>
<li id="_sidebar_3.5"><a href="#sec-Expression-evaluation"><span class="spec-secid">3.5</span>Expression evaluation</a></li>
<li id="_sidebar_3.6"><a href="#sec-Constant-expression-evaluation"><span class="spec-secid">3.6</span>Constant expression evaluation</a></li>
<li id="_sidebar_3.7"><a href="#sec-Score-evaluation"><span class="spec-secid">3.7</span>Score evaluation</a></li>
<li id="_sidebar_3.8"><a href="#sec-Query-execution"><span class="spec-secid">3.8</span>Query execution</a></li>
</ol>
</li>
<li id="_sidebar_4"><a href="#sec-Data-types"><span class="spec-secid">4</span>Data types</a>
<input hidden class="toggle" type="checkbox" id="_toggle_4" /><label for="_toggle_4"></label>
<ol>
<li id="_sidebar_4.1"><a href="#sec-Null"><span class="spec-secid">4.1</span>Null</a></li>
<li id="_sidebar_4.2"><a href="#sec-Boolean"><span class="spec-secid">4.2</span>Boolean</a></li>
<li id="_sidebar_4.3"><a href="#sec-Number"><span class="spec-secid">4.3</span>Number</a></li>
<li id="_sidebar_4.4"><a href="#sec-String"><span class="spec-secid">4.4</span>String</a></li>
<li id="_sidebar_4.5"><a href="#sec-Array"><span class="spec-secid">4.5</span>Array</a></li>
<li id="_sidebar_4.6"><a href="#sec-Object"><span class="spec-secid">4.6</span>Object</a></li>
<li id="_sidebar_4.7"><a href="#sec-Pair"><span class="spec-secid">4.7</span>Pair</a></li>
<li id="_sidebar_4.8"><a href="#sec-Range"><span class="spec-secid">4.8</span>Range</a></li>
<li id="_sidebar_4.9"><a href="#sec-Datetime"><span class="spec-secid">4.9</span>Datetime</a></li>
</ol>
</li>
<li id="_sidebar_5"><a href="#sec-Equality-and-comparison"><span class="spec-secid">5</span>Equality and comparison</a>
<input hidden class="toggle" type="checkbox" id="_toggle_5" /><label for="_toggle_5"></label>
<ol>
<li id="_sidebar_5.1"><a href="#sec-Equality"><span class="spec-secid">5.1</span>Equality</a></li>
<li id="_sidebar_5.2"><a href="#sec-Partial-comparison"><span class="spec-secid">5.2</span>Partial comparison</a></li>
<li id="_sidebar_5.3"><a href="#sec-Total-comparison"><span class="spec-secid">5.3</span>Total comparison</a></li>
</ol>
</li>
<li id="_sidebar_6"><a href="#sec-Simple-expressions"><span class="spec-secid">6</span>Simple expressions</a>
<input hidden class="toggle" type="checkbox" id="_toggle_6" /><label for="_toggle_6"></label>
<ol>
<li id="_sidebar_6.1"><a href="#sec-This-expression"><span class="spec-secid">6.1</span>This expression</a></li>
<li id="_sidebar_6.2"><a href="#sec-This-attribute-expression"><span class="spec-secid">6.2</span>This attribute expression</a></li>
<li id="_sidebar_6.3"><a href="#sec-Everything-expression"><span class="spec-secid">6.3</span>Everything expression</a></li>
<li id="_sidebar_6.4"><a href="#sec-Parent-expression"><span class="spec-secid">6.4</span>Parent expression</a></li>
<li id="_sidebar_6.5"><a href="#sec-Function-call-expression"><span class="spec-secid">6.5</span>Function call expression</a></li>
</ol>
</li>
<li id="_sidebar_7"><a href="#sec-Compound-expressions"><span class="spec-secid">7</span>Compound expressions</a>
<input hidden class="toggle" type="checkbox" id="_toggle_7" /><label for="_toggle_7"></label>
<ol>
<li id="_sidebar_7.1"><a href="#sec-Parenthesis-expression"><span class="spec-secid">7.1</span>Parenthesis expression</a></li>
<li id="_sidebar_7.2"><a href="#sec-Attribute-access-expression"><span class="spec-secid">7.2</span>Attribute access expression</a></li>
<li id="_sidebar_7.3"><a href="#sec-Element-access-expression"><span class="spec-secid">7.3</span>Element access expression</a></li>
<li id="_sidebar_7.4"><a href="#sec-Slice-expression"><span class="spec-secid">7.4</span>Slice expression</a></li>
<li id="_sidebar_7.5"><a href="#sec-Filter-expression"><span class="spec-secid">7.5</span>Filter expression</a></li>
<li id="_sidebar_7.6"><a href="#sec-Projection-expression"><span class="spec-secid">7.6</span>Projection expression</a></li>
<li id="_sidebar_7.7"><a href="#sec-Pipe-function-call-expression"><span class="spec-secid">7.7</span>Pipe function call expression</a></li>
<li id="_sidebar_7.8"><a href="#sec-Disambiguating-square-backet-expressions"><span class="spec-secid">7.8</span>Disambiguating square backet expressions</a></li>
</ol>
</li>
<li id="_sidebar_8"><a href="#sec-Operators"><span class="spec-secid">8</span>Operators</a>
<input hidden class="toggle" type="checkbox" id="_toggle_8" /><label for="_toggle_8"></label>
<ol>
<li id="_sidebar_8.1"><a href="#sec-And-operator"><span class="spec-secid">8.1</span>And operator</a></li>
<li id="_sidebar_8.2"><a href="#sec-Or-operator"><span class="spec-secid">8.2</span>Or operator</a></li>
<li id="_sidebar_8.3"><a href="#sec-Not-operator"><span class="spec-secid">8.3</span>Not operator</a></li>
<li id="_sidebar_8.4"><a href="#sec-Equality-operators"><span class="spec-secid">8.4</span>Equality operators</a></li>
<li id="_sidebar_8.5"><a href="#sec-Comparison-operators"><span class="spec-secid">8.5</span>Comparison operators</a></li>
<li id="_sidebar_8.6"><a href="#sec-In-operator"><span class="spec-secid">8.6</span>In operator</a></li>
<li id="_sidebar_8.7"><a href="#sec-Match-operator"><span class="spec-secid">8.7</span>Match operator</a></li>
<li id="_sidebar_8.8"><a href="#sec-Asc-operator"><span class="spec-secid">8.8</span>Asc operator</a></li>
<li id="_sidebar_8.9"><a href="#sec-Desc-operator"><span class="spec-secid">8.9</span>Desc operator</a></li>
<li id="_sidebar_8.10"><a href="#sec-Unary-plus-operator"><span class="spec-secid">8.10</span>Unary plus operator</a></li>
<li id="_sidebar_8.11"><a href="#sec-Unary-minus-operator"><span class="spec-secid">8.11</span>Unary minus operator</a></li>
<li id="_sidebar_8.12"><a href="#sec-Binary-plus-operator"><span class="spec-secid">8.12</span>Binary plus operator</a></li>
<li id="_sidebar_8.13"><a href="#sec-Binary-minus-operator"><span class="spec-secid">8.13</span>Binary minus operator</a></li>
<li id="_sidebar_8.14"><a href="#sec-Binary-star-operator"><span class="spec-secid">8.14</span>Binary star operator</a></li>
<li id="_sidebar_8.15"><a href="#sec-Binary-slash-operator"><span class="spec-secid">8.15</span>Binary slash operator</a></li>
<li id="_sidebar_8.16"><a href="#sec-Binary-percent-operator"><span class="spec-secid">8.16</span>Binary percent operator</a></li>
<li id="_sidebar_8.17"><a href="#sec-Binary-double-star-operator"><span class="spec-secid">8.17</span>Binary double star operator</a></li>
<li id="_sidebar_8.18"><a href="#sec-Dereference-operator"><span class="spec-secid">8.18</span>Dereference operator</a></li>
</ol>
</li>
<li id="_sidebar_9"><a href="#sec-Precedence-and-associativity"><span class="spec-secid">9</span>Precedence and associativity</a></li>
<li id="_sidebar_10"><a href="#sec-Functions"><span class="spec-secid">10</span>Functions</a></li>
<li id="_sidebar_11"><a href="#sec-Namespaces"><span class="spec-secid">11</span>Namespaces</a>
<input hidden class="toggle" type="checkbox" id="_toggle_11" /><label for="_toggle_11"></label>
<ol>
<li id="_sidebar_11.1"><a href="#sec-Global-namespace"><span class="spec-secid">11.1</span>Global namespace</a>
<input hidden class="toggle" type="checkbox" id="_toggle_11.1" /><label for="_toggle_11.1"></label>
<ol>
<li id="_sidebar_11.1.1"><a href="#sec-global-coalesce-"><span class="spec-secid">11.1.1</span>global::coalesce()</a></li>
<li id="_sidebar_11.1.2"><a href="#sec-global-count-"><span class="spec-secid">11.1.2</span>global::count()</a></li>
<li id="_sidebar_11.1.3"><a href="#sec-global-dateTime-"><span class="spec-secid">11.1.3</span>global::dateTime()</a></li>
<li id="_sidebar_11.1.4"><a href="#sec-global-defined-"><span class="spec-secid">11.1.4</span>global::defined()</a></li>
<li id="_sidebar_11.1.5"><a href="#sec-global-length-"><span class="spec-secid">11.1.5</span>global::length()</a></li>
<li id="_sidebar_11.1.6"><a href="#sec-global-references-"><span class="spec-secid">11.1.6</span>global::references()</a></li>
<li id="_sidebar_11.1.7"><a href="#sec-global-round-"><span class="spec-secid">11.1.7</span>global::round()</a></li>
<li id="_sidebar_11.1.8"><a href="#sec-global-select-"><span class="spec-secid">11.1.8</span>global::select()</a></li>
<li id="_sidebar_11.1.9"><a href="#sec-global-string-"><span class="spec-secid">11.1.9</span>global::string()</a></li>
<li id="_sidebar_11.1.10"><a href="#sec-global-boost-"><span class="spec-secid">11.1.10</span>global::boost()</a></li>
<li id="_sidebar_11.1.11"><a href="#sec-global-lower-"><span class="spec-secid">11.1.11</span>global::lower()</a></li>
<li id="_sidebar_11.1.12"><a href="#sec-global-upper-"><span class="spec-secid">11.1.12</span>global::upper()</a></li>
</ol>
</li>
</ol>
</li>
<li id="_sidebar_12"><a href="#sec-Pipe-functions"><span class="spec-secid">12</span>Pipe functions</a>
<input hidden class="toggle" type="checkbox" id="_toggle_12" /><label for="_toggle_12"></label>
<ol>
<li id="_sidebar_12.1"><a href="#sec-global-order-"><span class="spec-secid">12.1</span>global::order()</a></li>
<li id="_sidebar_12.2"><a href="#sec-global-score-"><span class="spec-secid">12.2</span>global::score()</a></li>
</ol>
</li>
<li id="_sidebar_13"><a href="#sec-Vendor-functions"><span class="spec-secid">13</span>Vendor functions</a>
<input hidden class="toggle" type="checkbox" id="_toggle_13" /><label for="_toggle_13"></label>
<ol>
<li id="_sidebar_13.1"><a href="#sec-global-identity-"><span class="spec-secid">13.1</span>global::identity()</a></li>
<li id="_sidebar_13.2"><a href="#sec-global-path-"><span class="spec-secid">13.2</span>global::path()</a></li>
</ol>
</li>
<li id="_sidebar_14"><a href="#sec-Extensions"><span class="spec-secid">14</span>Extensions</a>
<input hidden class="toggle" type="checkbox" id="_toggle_14" /><label for="_toggle_14"></label>
<ol>
<li id="_sidebar_14.1"><a href="#sec-Portable-Text-Extension"><span class="spec-secid">14.1</span>Portable Text Extension</a>
<input hidden class="toggle" type="checkbox" id="_toggle_14.1" /><label for="_toggle_14.1"></label>
<ol>
<li id="_sidebar_14.1.1"><a href="#sec-pt-type"><span class="spec-secid">14.1.1</span>pt type</a></li>
<li id="_sidebar_14.1.2"><a href="#sec-global-pt-"><span class="spec-secid">14.1.2</span>global::pt()</a></li>
<li id="_sidebar_14.1.3"><a href="#sec-pt-text-"><span class="spec-secid">14.1.3</span>pt::text()</a></li>
</ol>
</li>
<li id="_sidebar_14.2"><a href="#sec-Geography-Extension"><span class="spec-secid">14.2</span>Geography Extension</a>
<input hidden class="toggle" type="checkbox" id="_toggle_14.2" /><label for="_toggle_14.2"></label>
<ol>
<li id="_sidebar_14.2.1"><a href="#sec-geo-type"><span class="spec-secid">14.2.1</span>geo type</a></li>
<li id="_sidebar_14.2.2"><a href="#sec-global-geo-"><span class="spec-secid">14.2.2</span>global::geo()</a></li>
<li id="_sidebar_14.2.3"><a href="#sec-geo-contains-"><span class="spec-secid">14.2.3</span>geo::contains()</a></li>
<li id="_sidebar_14.2.4"><a href="#sec-geo-intersects-"><span class="spec-secid">14.2.4</span>geo::intersects()</a></li>
<li id="_sidebar_14.2.5"><a href="#sec-geo-distance-"><span class="spec-secid">14.2.5</span>geo::distance()</a></li>
</ol>
</li>
</ol>
</li>
<li id="_sidebar_index"><a href="#index"><span class="spec-secid">¬ß</span>Index</a></li>
</ol>
</div>
</div>
</body>
</html>
