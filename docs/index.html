<!DOCTYPE html>
<!-- Built with spec-md https://spec-md.com -->
<html>
<head><meta charset="utf-8">
<title>GROQ</title>
<style>body {
  color: #333333;
  font: 13pt/18pt Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  margin: 6rem auto 3rem;
  max-width: 780px;
}


/* Links */

a {
  color: #3B5998;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}


/* Section headers */

h1, h2, h3, h4, h5, h6, h7, h8 {
  font-weight: bold;
  margin: 3em 0 1em;
  position: relative;
}

h1 {
  font-size: 1.5em;
  margin: 6em 0 3em;
}

h2 {
  font-size: 1.5em;
  margin-top: 5em;
}

h3, h4 {
  font-size: 1.25em;
}

h5, h6 {
  font-size: 1em;
}

section.subsec > h6 {
  margin-top: 2em;
}

section.subsec > h6 > a {
  color: #333333;
}

section .spec-secid {
  margin-right: 1ex;
  position: absolute;
  right: 100%;
  text-align: right;
  white-space: nowrap;
}

footer {
  font-size: 75%;
  opacity: 0.5;
  text-align: center;
  margin-top: 12rem;
}


/* Table of contents */

.spec-toc {
  margin: 1rem 0 3rem;
}

.spec-toc .title {
  content: 'Contents';
  display: block;
  font-weight: bold;
  margin: 5em 0 1em;
}

.spec-toc .spec-secid {
  margin-right: 1ex;
}

.spec-toc ol {
  list-style: none;
  padding-left: 0;
}

.spec-toc ol ol {
  list-style: none;
  padding-left: 2ex;
}

.spec-toc li {
  position: relative;
  padding: 5px 0 0 30px;
  margin: -5px 0 0 -30px;
}

.spec-toc a {
  color: #333333;
}

.spec-toc a:hover {
  text-decoration: none;
}

.spec-toc a .spec-secid {
  color: #3B5998;
}

.spec-toc a:hover .spec-secid {
  text-decoration: underline;
}

.spec-toc .toggle {
  display: none;
}

.spec-toc .toggle + label {
  cursor: pointer;
  left: 10px;
  opacity: 1;
  padding: 3px 5px 3px 6px;
  position: absolute;
  top: 8px;
  transform: rotate(0deg);
  transition: all 0.18s ease-in-out;
}

.spec-toc .toggle + label:after {
  border-color: transparent transparent transparent #bbc;
  border-style: solid;
  border-width: 6px 0 6px 7px;
  content: ' ';
  display: block;
  height: 0;
  width: 0;
}

.spec-toc .toggle:checked + label {
  transform: rotate(90deg);
}

.spec-toc li:not(:hover) > .toggle:checked + label {
  opacity: 0;
}

.spec-toc .toggle:not(:checked) ~ ol {
  max-height: 0;
  overflow: hidden;
}


/* Sidebar */

.spec-sidebar-toggle {
  display: none;
}

.spec-sidebar-toggle + label {
  position: fixed;
  right: 0;
  top: 0;
  padding: 10px 15px;
  font-size: 30px;
  color: rgba(0,0,0,0.7);
  z-index: 2;
  cursor: pointer;
  user-select: none;
  -moz-user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
}

.spec-sidebar {
  display: none;
  position: fixed;
  right: 0;
  top: 0;
  width: 320px;
  font-size: 80%;
  overflow-y: scroll;
  height: 100%;
  padding: 0 0 5rem 30px;
  box-sizing: border-box;
  background: #f0f0f0;
}

.spec-sidebar-toggle:checked ~ .spec-sidebar {
  display: block;
  box-shadow:
    -1px 0 rgba(0,0,0,0.12),
    -4px 0 8px -2px rgba(0,0,0,0.05);
}

.spec-sidebar .viewing > a:after {
  color: #8b9;
  content: '\2022';
  margin-left: 1ex;
}

@media (min-width: 1240px) {
  .spec-sidebar-toggle + label {
    display: none;
  }

  .spec-sidebar {
    display: block;
    box-shadow:
      inset 1px 0 rgba(0,0,0,0.05),
      inset 4px 0 8px -2px rgba(0,0,0,0.08) !important;
  }

  body {
    padding-right: 300px;
  }
}


/* Notes */

.spec-note {
  background: #FEFEF3;
  border-left: solid 4px #F4E925;
  margin: 1em -1em;
  min-width: 416px;
  padding: 1ex 1em 1ex calc(1em - 4px);
  width: -moz-fit-content;
  width: -webkit-fit-content;
  width: fit-content;
}

.spec-note > a:first-child {
  color: #6C6613;
  display: block;
  font: italic 11pt/18pt Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  opacity: 0.6;
  user-select: none;
}


/* Todos */

.spec-todo {
  color: #666666;
  margin: 1em 0 1em 5em;
  min-height: 1em;
}

.spec-todo::before {
  content: 'todo';
  display: block;
  float: left;
  margin-left: -5em;
  text-transform: uppercase;
}

/* Index table */

.spec-index ol {
  list-style-type: none;
  margin: 0 0 0 2rem;
  padding: 0;
  column-width: 210px;
  column-gap: 2rem;
}

.spec-index ol li {
  width: min-content;
}

/* Code */

code {
  background: #FAFAFA;
  font-family: Consolas, Monaco, monospace;
  font-size: 85%;
  font-weight: inherit;
  margin: -2px -1px;
  padding: 3px 3px;
  white-space: pre;
}

pre code {
  background: none;
  font-weight: inherit;
  margin: 0;
  padding: 0;
}

pre {
  background: #FAFAFA;
  border-left: solid 4px #E9E9E9;
  margin: 1em -1em;
  min-width: 40ch;
  padding: 1ex 1em 1ex calc(1em - 4px);
  width: -moz-fit-content;
  width: -webkit-fit-content;
  width: fit-content;
}

.spec-example {
  background: #FAFAFF;
  border-left: solid 4px #BBBBFF;
}

.spec-counter-example {
  background: #FFFAFA;
  border-left: solid 4px #FFBBBB;
}

.spec-example > a,
.spec-counter-example > a {
  display: block;
  font: italic 11pt/18pt Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  opacity: 0.6;
  user-select: none;
}

.spec-counter-example > a {
  color: #98593b;
}


/* Tables */

table {
  border-collapse: collapse;
}

th {
  background-color: #F9F9F9;
}

td, th {
  border: 1px solid #D0D0D0;
  padding: 0.4em;
  vertical-align: baseline;
}


/* Edits */

ins {
  background-color: rgba(0, 200, 30, 0.08);
  text-decoration: none;
}

del {
  background-color: rgba(200, 0, 0, 0.08);
}

.spec-added, .spec-removed {
  border-left: 4px solid;
  margin-left: -18px;
  padding-left: 14px;
}

.spec-added {
  border-color: #396;
}

.spec-removed {
  border-color: #933;
  text-decoration: line-through;
}


/* Values */

.spec-keyword {
  font-weight: bold;
}

.spec-string {
  font-family: Consolas, Monaco, monospace;
  font-size: 85%;
  white-space: pre;
}

var {
  font-style: italic;
}

*[data-name] {
  transition: 0.15s background ease-out;
  border-radius: 2px;
  padding: 0 3px;
  margin: 0 -3px;
}


/* Grammar semantics, algorithms and calls */

.spec-semantic,
.spec-algo {
  margin: 1rem 0 1rem 2rem;
}

.spec-semantic > .spec-rhs {
  display: inline-block;
  margin-left: 1ex;
}

.spec-semantic > .spec-nt::after,
.spec-algo > .spec-call:first-child::after {
  content: ':';
  font-style: normal;
  font-weight: bold;
  margin-left: 1ex;
}

.spec-semantic ol, .spec-semantic ol ol ol ol,
.spec-algo ol, .spec-algo ol ol ol ol {
  list-style-type: decimal;
}

.spec-semantic ol ol, .spec-semantic ol ol ol ol ol,
.spec-algo ol ol, .spec-algo ol ol ol ol ol {
  list-style-type: lower-alpha;
}

.spec-semantic ol ol ol, .spec-semantic ol ol ol ol ol ol,
.spec-algo ol ol ol, .spec-algo ol ol ol ol ol ol {
  list-style-type: lower-roman;
}

.spec-call > a {
  color: inherit;
}


/* Grammar productions */

.spec-production {
  margin: 1rem 0 1rem 2rem;
}

.spec-production > .spec-nt::after {
  content: ':';
  font-style: normal;
  font-weight: bold;
  margin: 0 1ex;
}

.spec-semantic.d2 > .spec-nt::after,
.spec-production.d2 > .spec-nt::after {
  content: '::';
}

.spec-semantic.d3 > .spec-nt::after,
.spec-production.d3 > .spec-nt::after {
  content: ':::';
}

.spec-rhs {
  margin-left: 2rem;
}

.spec-oneof {
  display: inline;
}

.spec-oneof::before {
  content: 'one of';
  font-style: normal;
  font-weight: bold;
}

.spec-oneof > table {
  margin-left: 2rem;
}

.spec-oneof .spec-rhs {
  border: none;
  margin: 0;
  padding: 0 0.5em;
  vertical-align: baseline;
}

.spec-rhs .spec-constrained:not(:first-child),
.spec-rhs .spec-quantified:not(:first-child),
.spec-rhs .spec-nt:not(:first-child),
.spec-rhs .spec-t:not(:first-child),
.spec-rhs .spec-rx:not(:first-child),
.spec-rhs .spec-prose:not(:first-child),
.spec-rhs .spec-empty:not(:first-child),
.spec-rhs .spec-lookahead:not(:first-child) {
  margin-left: 1ex;
}

.spec-condition {
  font-size: 85%;
}

.spec-condition::before {
  content: '[if '
}

.spec-condition.not::before {
  content: '[if not '
}

.spec-condition::after {
  content: ']'
}

.spec-empty,
.spec-prose {
  color: #666666;
}

.spec-nt {
  font-style: italic;
}

.spec-nt > a {
  color: inherit;
}

.spec-quantifiers,
.spec-params {
  font-size: 65%;
  font-style: normal;
  vertical-align: sub;
}

.spec-quantifier.list {
  color: #3348D3;
}

.spec-quantifier.optional {
  color: #83238E;
}

.spec-params,
.spec-condition {
  color: #1C7758;
}

.spec-params::before {
  content: '[';
}

.spec-params::after {
  content: ']';
}

.spec-quantifier:not(:last-child)::after,
.spec-param:not(:last-child)::after {
  color: #666666;
  content: ', ';
}

.spec-param.conditional::before {
  content: '?';
}

.spec-param.negated::before {
  content: '!';
}

.spec-t, .spec-rx {
  color: #333333;
  font-family: monospace;
  font-weight: bold;
}

.spec-butnot::before {
  color: #666666;
  content: 'but not';
  font-family: Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  font-weight: normal;
  margin-right: 1ex;
}

.spec-butnot > *:not(:first-child)::before {
  color: #666666;
  content: 'or';
  font-family: Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  font-weight: normal;
  margin-right: 1ex;
}

.spec-rhs .spec-oneof::before,
.spec-rhs .spec-butnot::before {
  margin-left: 1ex;
}

.spec-lookahead > * {
  margin: 0 !important;
}

.spec-lookahead > *:not(:first-child)::before {
  color: #666666;
  content: ', ';
  font-family: Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  font-style: normal;
  font-weight: normal;
}

.spec-lookahead::before {
  color: #666666;
  content: '[lookahead = ';
  font-family: Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  font-style: normal;
  font-weight: normal;
}

.spec-lookahead.not::before {
  content: '[lookahead \2260  ';
}

.spec-lookahead.set::before {
  content: '[lookahead \2208  {';
  margin-right: 0;
}

.spec-lookahead.set.not::before {
  content: '[lookahead \2209  {';
}

.spec-lookahead.ntset::before {
  content: '[lookahead \2208  ';
  margin-right: 0;
}

.spec-lookahead.ntset.not::before {
  content: '[lookahead \2209  ';
}

.spec-lookahead::after {
  color: #666666;
  content: ']';
}

.spec-lookahead.set::after {
  content: '}]';
}
</style>
<style>/* Copied from node_modules/prismjs/themes/prism.css */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	background: none;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #a67f59;
	background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
</style>
<script>(function (){
var styleSheet = document.getElementsByTagName('style')[0].sheet;
var ruleIndex;

function removeHighlight() {
  if (ruleIndex) {
    styleSheet.deleteRule(ruleIndex);
    ruleIndex = void 0;
  }
}

function highlightKeyword(name) {
  removeHighlight();
  ruleIndex = styleSheet.insertRule(
    '*[data-name="' + name + '"] { background: #FBF8D0; }',
    styleSheet.cssRules.length
  );
}

document.documentElement.addEventListener('mouseover', function (event) {
  var nameAttribute = event.target.attributes['data-name'];
  if (nameAttribute) {
    highlightKeyword(nameAttribute.value);
  }
});

document.documentElement.addEventListener('mouseout', removeHighlight);
})()</script>
</head>
<body><article>
<header>
<h1>GROQ</h1>
<section id="intro">
<p><em>Current Working Draft</em></p>
<p>This is the specification for GROQ (<strong>G</strong>raph-<strong>R</strong>elational <strong>O</strong>bject <strong>Q</strong>ueries), a query language and execution engine made at Sanity, Inc, for filtering and projecting JSON documents. The work started in 2015. The development of this open standard started in 2019.</p>
<p>GROQ is authored by <a href="https://twitter.com/purefiction">Alexander Staubo</a> and <a href="https://twitter.com/svale">Simen Svale Skogsrud</a>. Additional follow up work by <a href="https://twitter.com/erikgrinaker">Erik Grinaker</a> and <a href="https://twitter.com/judofyr">Magnus Holm</a>.</p>
<p>This specification should be considered <em>work in progress</em> until the first release.</p>
<section id="sec-Copyright-notice" class="subsec">
<h6><a href="#sec-Copyright-notice" title="link to this subsection">Copyright notice</a></h6>
<p>Copyright Â© 2015&ndash;present, Sanity, Inc.</p>
<p>As of July 9, 2010, the following persons or entities have made this Specification available under the Open Web Foundation Final Specification Agreement (OWFa 1.0), which is available at <a href="http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0">openwebfoundation.org</a>.</p>
<ul>
<li>Sanity, Inc.</li>
</ul>
<p>You can review the signed copies of the Open Web Foundation Final Specification Agreement Version 1.0 for this specification at <a href="https://github.com/sanity-io/GROQ">github.com/sanity&#8208;io/GROQ</a>, which may also include additional parties to those listed above.</p>
<p>Your use of this Specification may be subject to other third party rights. THIS SPECIFICATION IS PROVIDED &ldquo;AS IS.&rdquo; The contributors expressly disclaim any warranties (express, implied, or otherwise), including implied warranties of merchantability, non&#8208;infringement, fitness for a particular purpose, or title, related to the Specification. The entire risk as to implementing or otherwise using the Specification is assumed by the Specification implementer and user. IN NO EVENT WILL ANY PARTY BE LIABLE TO ANY OTHER PARTY FOR LOST PROFITS OR ANY FORM OF INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES OF ANY CHARACTER FROM ANY CAUSES OF ACTION OF ANY KIND WITH RESPECT TO THIS SPECIFICATION OR ITS GOVERNING AGREEMENT, WHETHER BASED ON BREACH OF CONTRACT, TORT (INCLUDING NEGLIGENCE), OR OTHERWISE, AND WHETHER OR NOT THE OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
</section>
<section id="sec-Conformance" class="subsec">
<h6><a href="#sec-Conformance" title="link to this subsection">Conformance</a></h6>
<p>A conforming implementation of GROQ must fulfill all normative requirements. Conformance requirements are described in this document via both descriptive assertions and key words with clearly defined meanings.</p>
<p>The key words &ldquo;MUST&rdquo;, &ldquo;MUST NOT&rdquo;, &ldquo;REQUIRED&rdquo;, &ldquo;SHALL&rdquo;, &ldquo;SHALL NOT&rdquo;, &ldquo;SHOULD&rdquo;, &ldquo;SHOULD NOT&rdquo;, &ldquo;RECOMMENDED&rdquo;, &ldquo;MAY&rdquo;, and &ldquo;OPTIONAL&rdquo; in the normative portions of this document are to be interpreted as described in <a href="https://tools.ietf.org/html/rfc2119">IETF RFC 2119</a>. These key words may appear in lowercase and still retain their meaning unless explicitly declared as non&#8208;normative.</p>
<p>A conforming implementation of GROQ may provide additional functionality, but must not where explicitly disallowed or would otherwise result in non&#8208;conformance.</p>
</section>
<section id="sec-Conforming-Algorithms" class="subsec">
<h6><a href="#sec-Conforming-Algorithms" title="link to this subsection">Conforming Algorithms</a></h6>
<p>Algorithm steps phrased in imperative grammar (e.g. &ldquo;Return the result&rdquo;) are to be interpreted with the same level of requirement as the algorithm it is contained within. Any algorithm referenced within an algorithm step (e.g. &ldquo;Let completedResult be the result of calling CompleteValue()&rdquo;) is to be interpreted as having at least the same level of requirement as the algorithm containing that step.</p>
<p>Conformance requirements expressed as algorithms can be fulfilled by an implementation of this specification in any way as long as the perceived result is equivalent. Algorithms described in this document are written to be easy to understand. Implementers are encouraged to include equivalent but optimized implementations.</p>
</section>
</section>
<nav class="spec-toc">
<div class="title">Contents</div>
<ol>
<li><a href="#sec-undefined.Overview"><span class="spec-secid">1</span>Overview</a></li>
<li><a href="#sec-Syntax"><span class="spec-secid">2</span>Syntax</a>
<input hidden class="toggle" type="checkbox" checked id="_toggle_2" /><label for="_toggle_2"></label>
<ol>
<li><a href="#sec-JSON-Superset"><span class="spec-secid">2.1</span>JSON Superset</a></li>
<li><a href="#sec-White-Space"><span class="spec-secid">2.2</span>White Space</a></li>
<li><a href="#sec-Comments"><span class="spec-secid">2.3</span>Comments</a></li>
<li><a href="#sec-Identifier"><span class="spec-secid">2.4</span>Identifier</a></li>
<li><a href="#sec-Digits"><span class="spec-secid">2.5</span>Digits</a></li>
<li><a href="#sec-Expression"><span class="spec-secid">2.6</span>Expression</a></li>
</ol>
</li>
<li><a href="#sec-Execution"><span class="spec-secid">3</span>Execution</a>
<input hidden class="toggle" type="checkbox" checked id="_toggle_3" /><label for="_toggle_3"></label>
<ol>
<li><a href="#sec-Execution.Overview"><span class="spec-secid">3.1</span>Overview</a></li>
<li><a href="#sec-Query-context"><span class="spec-secid">3.2</span>Query context</a></li>
<li><a href="#sec-Scope"><span class="spec-secid">3.3</span>Scope</a></li>
<li><a href="#sec-Expression-validation"><span class="spec-secid">3.4</span>Expression validation</a></li>
<li><a href="#sec-Expression-evaluation"><span class="spec-secid">3.5</span>Expression evaluation</a></li>
<li><a href="#sec-Query-execution"><span class="spec-secid">3.6</span>Query execution</a></li>
</ol>
</li>
<li><a href="#sec-Data-types"><span class="spec-secid">4</span>Data types</a>
<input hidden class="toggle" type="checkbox" checked id="_toggle_4" /><label for="_toggle_4"></label>
<ol>
<li><a href="#sec-Null"><span class="spec-secid">4.1</span>Null</a></li>
<li><a href="#sec-Boolean"><span class="spec-secid">4.2</span>Boolean</a></li>
<li><a href="#sec-Number"><span class="spec-secid">4.3</span>Number</a></li>
<li><a href="#sec-String"><span class="spec-secid">4.4</span>String</a></li>
<li><a href="#sec-Array"><span class="spec-secid">4.5</span>Array</a></li>
<li><a href="#sec-Object"><span class="spec-secid">4.6</span>Object</a></li>
<li><a href="#sec-Pair"><span class="spec-secid">4.7</span>Pair</a></li>
<li><a href="#sec-Range"><span class="spec-secid">4.8</span>Range</a></li>
<li><a href="#sec-Datetime"><span class="spec-secid">4.9</span>Datetime</a></li>
</ol>
</li>
<li><a href="#sec-Equality-and-comparison"><span class="spec-secid">5</span>Equality and comparison</a>
<input hidden class="toggle" type="checkbox" checked id="_toggle_5" /><label for="_toggle_5"></label>
<ol>
<li><a href="#sec-Equality"><span class="spec-secid">5.1</span>Equality</a></li>
<li><a href="#sec-Partial-comparison"><span class="spec-secid">5.2</span>Partial comparison</a></li>
<li><a href="#sec-Total-comparison"><span class="spec-secid">5.3</span>Total comparison</a></li>
</ol>
</li>
<li><a href="#sec-Simple-expressions"><span class="spec-secid">6</span>Simple expressions</a>
<input hidden class="toggle" type="checkbox" checked id="_toggle_6" /><label for="_toggle_6"></label>
<ol>
<li><a href="#sec-This-expression"><span class="spec-secid">6.1</span>This expression</a></li>
<li><a href="#sec-This-attribute-expression"><span class="spec-secid">6.2</span>This attribute expression</a></li>
<li><a href="#sec-Everything-expression"><span class="spec-secid">6.3</span>Everything expression</a></li>
<li><a href="#sec-Parent-expression"><span class="spec-secid">6.4</span>Parent expression</a></li>
<li><a href="#sec-Function-call-expression"><span class="spec-secid">6.5</span>Function call expression</a></li>
</ol>
</li>
<li><a href="#sec-Compound-expressions"><span class="spec-secid">7</span>Compound expressions</a>
<input hidden class="toggle" type="checkbox" checked id="_toggle_7" /><label for="_toggle_7"></label>
<ol>
<li><a href="#sec-Parenthesis-expression"><span class="spec-secid">7.1</span>Parenthesis expression</a></li>
<li><a href="#sec-Attribute-access-expression"><span class="spec-secid">7.2</span>Attribute access expression</a></li>
<li><a href="#sec-Element-access-expression"><span class="spec-secid">7.3</span>Element access expression</a></li>
<li><a href="#sec-Slice-expression"><span class="spec-secid">7.4</span>Slice expression</a></li>
<li><a href="#sec-Filter-expression"><span class="spec-secid">7.5</span>Filter expression</a></li>
<li><a href="#sec-Projection-expression"><span class="spec-secid">7.6</span>Projection expression</a></li>
<li><a href="#sec-Pipe-function-call-expression"><span class="spec-secid">7.7</span>Pipe function call expression</a></li>
</ol>
</li>
<li><a href="#sec-Operators"><span class="spec-secid">8</span>Operators</a>
<input hidden class="toggle" type="checkbox" checked id="_toggle_8" /><label for="_toggle_8"></label>
<ol>
<li><a href="#sec-And-operator"><span class="spec-secid">8.1</span>And operator</a></li>
<li><a href="#sec-Or-operator"><span class="spec-secid">8.2</span>Or operator</a></li>
<li><a href="#sec-Not-operator"><span class="spec-secid">8.3</span>Not operator</a></li>
<li><a href="#sec-Equality-operators"><span class="spec-secid">8.4</span>Equality operators</a></li>
<li><a href="#sec-Comparison-operators"><span class="spec-secid">8.5</span>Comparison operators</a></li>
<li><a href="#sec-In-operator"><span class="spec-secid">8.6</span>In operator</a></li>
<li><a href="#sec-Match-operator"><span class="spec-secid">8.7</span>Match operator</a></li>
<li><a href="#sec-Asc-operator"><span class="spec-secid">8.8</span>Asc operator</a></li>
<li><a href="#sec-Desc-operator"><span class="spec-secid">8.9</span>Desc operator</a></li>
<li><a href="#sec-Unary-plus-operator"><span class="spec-secid">8.10</span>Unary plus operator</a></li>
<li><a href="#sec-Unary-minus-operator"><span class="spec-secid">8.11</span>Unary minus operator</a></li>
<li><a href="#sec-Binary-plus-operator"><span class="spec-secid">8.12</span>Binary plus operator</a></li>
<li><a href="#sec-Binary-minus-operator"><span class="spec-secid">8.13</span>Binary minus operator</a></li>
<li><a href="#sec-Binary-star-operator"><span class="spec-secid">8.14</span>Binary star operator</a></li>
<li><a href="#sec-Binary-slash-operator"><span class="spec-secid">8.15</span>Binary slash operator</a></li>
<li><a href="#sec-Binary-percent-operator"><span class="spec-secid">8.16</span>Binary percent operator</a></li>
<li><a href="#sec-Binary-double-star-operator"><span class="spec-secid">8.17</span>Binary double star operator</a></li>
<li><a href="#sec-Dereference-operator"><span class="spec-secid">8.18</span>Dereference operator</a></li>
</ol>
</li>
<li><a href="#sec-Precedence-and-associativity"><span class="spec-secid">9</span>Precedence and associativity</a></li>
<li><a href="#sec-Functions"><span class="spec-secid">10</span>Functions</a>
<input hidden class="toggle" type="checkbox" checked id="_toggle_10" /><label for="_toggle_10"></label>
<ol>
<li><a href="#sec-coalesce"><span class="spec-secid">10.1</span>coalesce</a></li>
<li><a href="#sec-count"><span class="spec-secid">10.2</span>count</a></li>
<li><a href="#sec-dateTime"><span class="spec-secid">10.3</span>dateTime</a></li>
<li><a href="#sec-defined"><span class="spec-secid">10.4</span>defined</a></li>
<li><a href="#sec-length"><span class="spec-secid">10.5</span>length</a></li>
<li><a href="#sec-references"><span class="spec-secid">10.6</span>references</a></li>
<li><a href="#sec-round"><span class="spec-secid">10.7</span>round</a></li>
<li><a href="#sec-select"><span class="spec-secid">10.8</span>select</a></li>
<li><a href="#sec-string"><span class="spec-secid">10.9</span>string</a></li>
</ol>
</li>
<li><a href="#sec-Pipe-functions"><span class="spec-secid">11</span>Pipe functions</a>
<input hidden class="toggle" type="checkbox" checked id="_toggle_11" /><label for="_toggle_11"></label>
<ol>
<li><a href="#sec-order"><span class="spec-secid">11.1</span>order</a></li>
</ol>
</li>
<li><a href="#sec-Vendor-functions"><span class="spec-secid">12</span>Vendor functions</a>
<input hidden class="toggle" type="checkbox" checked id="_toggle_12" /><label for="_toggle_12"></label>
<ol>
<li><a href="#sec-identity-"><span class="spec-secid">12.1</span>identity()</a></li>
</ol>
</li>
<li><a href="#index"><span class="spec-secid">Â§</span>Index</a></li>
</ol>
</nav>
</header>
<section id="sec-undefined.Overview" secid="1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-undefined.Overview">1</a></span>Overview</h2>
<p>GROQ (Graph&#8208;Relational Object Queries) is a declarative language designed to query collections of largely schema&#8208;less JSON documents. Its primary design goals are expressive filtering, joining of several documents into a single response, and shaping the response to fit the client application.</p>
<p>The idea behind GROQ is to be able to describe exactly what information your application needs, potentially joining together information from several sets of documents, then stitching together a very specific response with only the exact fields you need.</p>
<p>A query in GROQ typically starts withÂ <code>*</code>. This asterisk represents every document in your dataset. It is typically followed by aÂ <var data-name="filter">filter</var>Â in brackets. The <var data-name="filter">filter</var> take <var data-name="terms">terms</var>, <var data-name="operators">operators</var> and <var data-name="functions">functions</var>. A <var data-name="projection">projection</var><em> </em>is wrapped in curly braces and describe the data as we want it returned. </p>
<p>Given these JSON documents:</p>
<pre><code><span class="token punctuation">{</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Peter"</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Gamora"</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Drax"</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Groot"</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span> <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Rocket"</span><span class="token punctuation">}</span>
</code></pre>
<p>The following query:</p>
<pre><code>*[id &gt; 2]{name}
</code></pre>
<p>Will result in the following JSON document:</p>
<pre><code><span class="token punctuation">[</span>
  <span class="token punctuation">{</span> <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Drax"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Groot"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Rocket"</span><span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre>
</section>
<section id="sec-Syntax" secid="2">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Syntax">2</a></span>Syntax</h2>
<p>A GROQ query is a string consisting of Unicode characters. The encoding of the query string is implementation&#8208;defined, but UTF&#8208;8 is the preferred choice. A query consist of a single <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>, with <span class="spec-nt"><a href="#WhiteSpace" data-name="WhiteSpace">WhiteSpace</a></span> and <span class="spec-nt"><a href="#Comment" data-name="Comment">Comment</a></span> allowed anywhere with no effect on the interpretation.</p>
<div class="spec-production" id="SourceCharacter">
<span class="spec-nt"><a href="#SourceCharacter" data-name="SourceCharacter">SourceCharacter</a></span><div class="spec-rhs"><span class="spec-prose">any Unicode character</span></div>
</div>
<section id="sec-JSON-Superset" secid="2.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-JSON-Superset">2.1</a></span>JSON Superset</h3>
<p>GROQ&rsquo;s syntax is a superset of JSON, so any valid JSON value is a valid GROQ expression (that simply returns the given value). Below are a few examples of JSON values:</p>
<pre><code>&quot;Hi! ðŸ‘‹&quot;
</code></pre>
<pre><code><span class="token punctuation">[</span><span class="token string">"An"</span><span class="token punctuation">,</span> <span class="token string">"array"</span><span class="token punctuation">,</span> <span class="token string">"of"</span><span class="token punctuation">,</span> <span class="token string">"strings"</span><span class="token punctuation">]</span>
</code></pre>
<pre><code><span class="token punctuation">{</span>
  <span class="token property">"array"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"string"</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token null keyword">null</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">"boolean"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token property">"number"</span><span class="token operator">:</span> <span class="token number">3.14</span><span class="token punctuation">,</span>
  <span class="token property">"null"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>
  <span class="token property">"object"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token property">"key"</span><span class="token operator">:</span> <span class="token string">"value"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"string"</span><span class="token operator">:</span> <span class="token string">"Hi! ðŸ‘‹"</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
<section id="sec-White-Space" secid="2.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-White-Space">2.2</a></span>White Space</h3>
<p>Whitespace is not significant in GROQ, except for acting as a token separator and comment terminator. Any sequence of the following characters is considered whitespace.</p>
<div class="spec-production" id="WhiteSpace">
<span class="spec-nt"><a href="#WhiteSpace" data-name="WhiteSpace">WhiteSpace</a></span><div class="spec-rhs"><span class="spec-prose">Tab U+0009</span></div>
<div class="spec-rhs"><span class="spec-prose">Newline U+000A</span></div>
<div class="spec-rhs"><span class="spec-prose">Vertical tab U+000B</span></div>
<div class="spec-rhs"><span class="spec-prose">Form feed U+000C</span></div>
<div class="spec-rhs"><span class="spec-prose">Carriage return U+000D</span></div>
<div class="spec-rhs"><span class="spec-prose">Space U+0020</span></div>
<div class="spec-rhs"><span class="spec-prose">Next line U+0085</span></div>
<div class="spec-rhs"><span class="spec-prose">Non-breaking space U+00A0</span></div>
</div>
<p>Whitespace inside a string literal is interpreted as&#8208;is.</p>
</section>
<section id="sec-Comments" secid="2.3">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Comments">2.3</a></span>Comments</h3>
<div class="spec-production" id="Comment">
<span class="spec-nt"><a href="#Comment" data-name="Comment">Comment</a></span><div class="spec-rhs"><span class="spec-rx">//</span><span class="spec-quantified"><span class="spec-nt"><a href="#CommentChar" data-name="CommentChar">CommentChar</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span><span class="spec-quantifier optional">opt</span></span></span></div>
</div>
<div class="spec-production" id="CommentChar">
<span class="spec-nt"><a href="#CommentChar" data-name="CommentChar">CommentChar</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#SourceCharacter" data-name="SourceCharacter">SourceCharacter</a></span><span class="spec-butnot"><span class="spec-prose">Newline U+000A</span></span></span></div>
</div>
<p>Comments serve as query documentation, and are ignored by the parser. They start with <code>//</code> and run to the end of the line:</p>
<pre><code>{ 
  // Comments can be on a separate line 
  &quot;key&quot;: &quot;value&quot; // Or at the end of a line 
}
</code></pre>
<p>Comments cannot start inside a string literal.</p>
<pre><code>{ 
  &quot;key // This isn&#x27;t a comment&quot;: &quot;value&quot;
}
</code></pre>
</section>
<section id="sec-Identifier" secid="2.4">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Identifier">2.4</a></span>Identifier</h3>
<p>Identifiers are used to name entities such as parameters, attributes and functions. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter.</p>
<div class="spec-production" id="Identifier">
<span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span><div class="spec-rhs"><span class="spec-rx">/[A-Za-z_][A-Za-z_0-9]*/</span></div>
</div>
</section>
<section id="sec-Digits" secid="2.5">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Digits">2.5</a></span>Digits</h3>
<p>GROQ uses decimal digits (0&#8208;9) and hexadecimal digits (0&#8208;9, a&#8208;f) in various places.</p>
<div class="spec-production" id="Digit">
<span class="spec-nt"><a href="#Digit" data-name="Digit">Digit</a></span><div class="spec-oneof"><table>
<tr>
<td class="spec-rhs"><span class="spec-t">0</span></td><td class="spec-rhs"><span class="spec-t">1</span></td><td class="spec-rhs"><span class="spec-t">2</span></td><td class="spec-rhs"><span class="spec-t">3</span></td><td class="spec-rhs"><span class="spec-t">4</span></td><td class="spec-rhs"><span class="spec-t">5</span></td><td class="spec-rhs"><span class="spec-t">6</span></td><td class="spec-rhs"><span class="spec-t">7</span></td><td class="spec-rhs"><span class="spec-t">8</span></td><td class="spec-rhs"><span class="spec-t">9</span></td></tr>
</table></div>
</div>
<div class="spec-production" id="HexDigit">
<span class="spec-nt"><a href="#HexDigit" data-name="HexDigit">HexDigit</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Digit" data-name="Digit">Digit</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#HexDigit" data-name="HexDigit">HexDigit</a></span></div>
</div>
<div class="spec-production" id="HexLetter">
<span class="spec-nt"><a href="#HexLetter" data-name="HexLetter">HexLetter</a></span><div class="spec-oneof"><table>
<tr>
<td class="spec-rhs"><span class="spec-t">a</span></td><td class="spec-rhs"><span class="spec-t">A</span></td><td class="spec-rhs"><span class="spec-t">b</span></td><td class="spec-rhs"><span class="spec-t">B</span></td><td class="spec-rhs"><span class="spec-t">c</span></td><td class="spec-rhs"><span class="spec-t">C</span></td><td class="spec-rhs"><span class="spec-t">d</span></td><td class="spec-rhs"><span class="spec-t">D</span></td><td class="spec-rhs"><span class="spec-t">e</span></td><td class="spec-rhs"><span class="spec-t">E</span></td><td class="spec-rhs"><span class="spec-t">f</span></td><td class="spec-rhs"><span class="spec-t">F</span></td></tr>
</table></div>
</div>
</section>
<section id="sec-Expression" secid="2.6">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Expression">2.6</a></span>Expression</h3>
<p>An <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> is either a literal (e.g. <code>15</code>), a simple expression (e.g. <code>@</code>), or a compound expression (e.g. <code>*[name == &quot;Michael&quot;]</code>) or an operator call (e.g. <code>name == &quot;Michael&quot;</code>). The syntax and semantics of the different expressions are documented in their respective sections.</p>
<div class="spec-production" id="Expression">
<span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Literal" data-name="Literal">Literal</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#SimpleExpression" data-name="SimpleExpression">SimpleExpression</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#CompoundExpression" data-name="CompoundExpression">CompoundExpression</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#OperatorCall" data-name="OperatorCall">OperatorCall</a></span></div>
</div>
<div class="spec-production" id="Literal">
<span class="spec-nt"><a href="#Literal" data-name="Literal">Literal</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Null" data-name="Null">Null</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Boolean" data-name="Boolean">Boolean</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Number" data-name="Number">Number</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#String" data-name="String">String</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Array" data-name="Array">Array</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Object" data-name="Object">Object</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Pair" data-name="Pair">Pair</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Range" data-name="Range">Range</a></span></div>
</div>
<div class="spec-production" id="SimpleExpression">
<span class="spec-nt"><a href="#SimpleExpression" data-name="SimpleExpression">SimpleExpression</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#This" data-name="This">This</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#ThisAttribute" data-name="ThisAttribute">ThisAttribute</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Everything" data-name="Everything">Everything</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Parent" data-name="Parent">Parent</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#FuncCall" data-name="FuncCall">FuncCall</a></span></div>
</div>
<div class="spec-production" id="CompoundExpression">
<span class="spec-nt"><a href="#CompoundExpression" data-name="CompoundExpression">CompoundExpression</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Parenthesis" data-name="Parenthesis">Parenthesis</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#AttributeAccess" data-name="AttributeAccess">AttributeAccess</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#ElementAccess" data-name="ElementAccess">ElementAccess</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Slice" data-name="Slice">Slice</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Filter" data-name="Filter">Filter</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Projection" data-name="Projection">Projection</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#PipeFuncCall" data-name="PipeFuncCall">PipeFuncCall</a></span></div>
</div>
<div class="spec-production" id="OperatorCall">
<span class="spec-nt"><a href="#OperatorCall" data-name="OperatorCall">OperatorCall</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#And" data-name="And">And</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Or" data-name="Or">Or</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Not" data-name="Not">Not</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Equality" data-name="Equality">Equality</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Comparison" data-name="Comparison">Comparison</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#In" data-name="In">In</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Match" data-name="Match">Match</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Asc" data-name="Asc">Asc</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Desc" data-name="Desc">Desc</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#UnaryPlus" data-name="UnaryPlus">UnaryPlus</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#UnaryMinus" data-name="UnaryMinus">UnaryMinus</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Plus" data-name="Plus">Plus</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Minus" data-name="Minus">Minus</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Star" data-name="Star">Star</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Slash" data-name="Slash">Slash</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Percent" data-name="Percent">Percent</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#StarStar" data-name="StarStar">StarStar</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Dereference" data-name="Dereference">Dereference</a></span></div>
</div>
</section>
</section>
<section id="sec-Execution" secid="3">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Execution">3</a></span>Execution</h2>
<section id="sec-Execution.Overview" secid="3.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Execution.Overview">3.1</a></span>Overview</h3>
<div id="note-26e83" class="spec-note">
<a href="#note-26e83">Note</a>
The following sub&#8208;section is a non&#8208;normative overview of the execution model. See the rest of the section for the exact semantics.</div>
<p>A GROQ query is executed inside a query context, which contains the dataset and parameters, and returns a result. Typically the result is serialized to JSON. During the execution of a query different parts of the query are evaluated in different scopes. Each scope has a <em>this </em>value and can be nested. Simple attributes like <code>name</code> always refers to an attribute on the <em>this </em>value.</p>
<pre><code>*[_type == &quot;person&quot;]{name, friends[country == &quot;NO&quot;]}
</code></pre>
<p>In the preceding example we have several scopes:</p>
<ul>
<li>The first filter (<code>[_type == &quot;person&quot;]</code>) creates a new scope for every document in the dataset. An equivalent scope is created inside the projection (<code>{name, â€¦}</code>).</li>
<li>The country filter (<code>[country == &quot;NO&quot;]</code>) creates a new scope for each element in the <code>friends</code> array.</li>
</ul>
<p>The parent expression (<code>^</code>) let&rsquo;s you refer to parent scopes, and this enables what is typically solved with joins in many databases.</p>
<pre><code>*[_type == &quot;person&quot;]{
  id,
  name,
  &quot;children&quot;: *[_type == &quot;person&quot; &amp;&amp; parentId == ^.id]
}
</code></pre>
<p>While executing the inner filter (<code>[_type == &quot;person&quot; &amp;&amp; parentId == ^.id]</code>) the expression <code>^.id</code> returns the <code>id</code> attribute of the parent scope&rsquo;s <em>this</em> value. The parent scope is here the scope created by the projection (<code>{id, name, â€¦}</code>).</p>
<p>It&rsquo;s possible for a query to be <em>invalid</em>. This can happen when you e.g. use an unknown function or call a function with incorrect number of arguments.</p>
</section>
<section id="sec-Query-context" secid="3.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Query-context">3.2</a></span>Query context</h3>
<p>A query context consists of:</p>
<ul>
<li>the dataset</li>
<li>parameter values (map from <var data-name="string">string</var> to <var data-name="value">value</var>)</li>
</ul>
</section>
<section id="sec-Scope" secid="3.3">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Scope">3.3</a></span>Scope</h3>
<p>A scope consists of:</p>
<ul>
<li>a this value</li>
<li>an optional parent scope</li>
<li>a query context</li>
</ul>
<p>A root scope can be constructed from a query context, and a nested scope can be constructed from an existing scope.</p>
<div class="spec-algo" id="NewNestedScope()">
<span class="spec-call"><a href="#NewNestedScope()" data-name="NewNestedScope">NewNestedScope</a>(<var data-name="value">value</var>, <var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="newScope">newScope</var> be a new scope.</li>
<li>Set the this value of <var data-name="newScope">newScope</var> to <var data-name="value">value</var>.</li>
<li>Set the parent scope of <var data-name="newScope">newScope</var> to <var data-name="scope">scope</var>.</li>
<li>Set the query context of <var data-name="newScope">newScope</var> to the query context of <var data-name="scope">scope</var>.</li>
<li>Return <var data-name="newScope">newScope</var>.</li>
</ol>
</div>
<div class="spec-algo" id="NewRootScope()">
<span class="spec-call"><a href="#NewRootScope()" data-name="NewRootScope">NewRootScope</a>(<var data-name="context">context</var>)</span><ol>
<li>Let <var data-name="newScope">newScope</var> be a new scope.</li>
<li>Set the this value of <var data-name="newScope">newScope</var> to <span class="spec-keyword">null</span>.</li>
<li>Set the parent scope of <var data-name="newScope">newScope</var> to <span class="spec-keyword">null</span>.</li>
<li>Set the query context of <var data-name="newScope">newScope</var> to <var data-name="context">context</var>.</li>
<li>Return <var data-name="newScope">newScope</var>.</li>
</ol>
</div>
</section>
<section id="sec-Expression-validation" secid="3.4">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Expression-validation">3.4</a></span>Expression validation</h3>
<p>An expression can be validated. This will only check that it&rsquo;s on a valid form, and will not execute anything. If an expression type does not have an explicitly defined validator in this specifiction, it has an implicit validator which runs <span class="spec-nt"><span data-name="Validate">Validate</span></span> on all its child expressions.</p>
<div class="spec-algo" id="Validate()">
<span class="spec-call"><a href="#Validate()" data-name="Validate">Validate</a>(<var data-name="expr">expr</var>)</span><ol>
<li>Let <var data-name="validator">validator</var> be the validator of <var data-name="expr">expr</var>.</li>
<li>Execute the <var data-name="validator">validator</var>.</li>
</ol>
</div>
</section>
<section id="sec-Expression-evaluation" secid="3.5">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Expression-evaluation">3.5</a></span>Expression evaluation</h3>
<p>An expression is evaluated in a scope. You must successfully validate an expression before you attempt to evaluate it. <a href="undefined"></a>Every expression type has their own evaluator function in their respective section in this specification (e.g. the evaluator of <span class="spec-nt"><span data-name="ParenthesisExpression">ParenthesisExpression</span></span> is <span class="spec-call"><a href="#EvaluateParenthesis()" data-name="EvaluateParenthesis">EvaluateParenthesis</a>()</span>).</p>
<div class="spec-algo" id="Evaluate()">
<span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="expr">expr</var>, <var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="evaluator">evaluator</var> be the evaluator of <var data-name="expr">expr</var>.</li>
<li>Return the result of <span class="spec-call"><span data-name="evaluator">evaluator</span>(<var data-name="scope">scope</var>)</span>.</li>
</ol>
</div>
</section>
<section id="sec-Query-execution" secid="3.6">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Query-execution">3.6</a></span>Query execution</h3>
<p>To execute a query you must first construct a query context, and then evaluate the query expression inside a root scope.</p>
<div class="spec-algo" id="ExecuteQuery()">
<span class="spec-call"><a href="#ExecuteQuery()" data-name="ExecuteQuery">ExecuteQuery</a>(<var data-name="query">query</var>, <var data-name="context">context</var>)</span><ol>
<li>Let <var data-name="scope">scope</var> be the result of <span class="spec-call"><a href="#NewRootScope()" data-name="NewRootScope">NewRootScope</a>(<var data-name="context">context</var>)</span>.</li>
<li>Let <var data-name="expr">expr</var> be the expression of <var data-name="query">query</var>.</li>
<li>Let <var data-name="result">result</var> be the result of <span class="spec-call"><span data-name="Evalute">Evalute</span>(<var data-name="expr">expr</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
</section>
</section>
<section id="sec-Data-types" secid="4">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Data-types">4</a></span>Data types</h2>
<section id="sec-Null" secid="4.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Null">4.1</a></span>Null</h3>
<p>An unknown value, expressed as <span class="spec-keyword">null</span>. This follows the SQL definition of null, which differs from the typical definition of &ldquo;no value&rdquo; in programming languages, and implies among other things that <code>1 + null</code> yields <span class="spec-keyword">null</span> (1 plus an unknown number yields an unknown number).</p>
<div class="spec-production" id="Null">
<span class="spec-nt"><a href="#Null" data-name="Null">Null</a></span><div class="spec-rhs"><span class="spec-t">null</span></div>
</div>
</section>
<section id="sec-Boolean" secid="4.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Boolean">4.2</a></span>Boolean</h3>
<p>Logical truth values, i.e. <span class="spec-keyword">true</span> and <span class="spec-keyword">false</span>.</p>
<div class="spec-production" id="Boolean">
<span class="spec-nt"><a href="#Boolean" data-name="Boolean">Boolean</a></span><div class="spec-rhs"><span class="spec-t">true</span></div>
<div class="spec-rhs"><span class="spec-t">false</span></div>
</div>
</section>
<section id="sec-Number" secid="4.3">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Number">4.3</a></span>Number</h3>
<p>Signed 64&#8208;bit double&#8208;precision floating point numbers, e.g. <code>3.14</code>, following the <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">IEEE 754 standard</a>. These have a magnitude of roughly 10â»Â³â°â· to 10Â³â°â¸, and can represent 15 significant figures with exact precision &ndash; beyond this, significant figures are rounded to 53&#8208;bit precision. The special IEEE 754 values of <span class="spec-nt"><span data-name="Infinity">Infinity</span></span> and <span class="spec-nt"><span data-name="NaN">NaN</span></span> are not supported, and are coerced to <span class="spec-keyword">null</span>.</p>
<div class="spec-production" id="Number">
<span class="spec-nt"><a href="#Number" data-name="Number">Number</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Integer" data-name="Integer">Integer</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Decimal" data-name="Decimal">Decimal</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#ScientificNotation" data-name="ScientificNotation">ScientificNotation</a></span></div>
</div>
<div class="spec-production" id="Sign">
<span class="spec-nt"><a href="#Sign" data-name="Sign">Sign</a></span><div class="spec-oneof"><table>
<tr>
<td class="spec-rhs"><span class="spec-t">+</span></td><td class="spec-rhs"><span class="spec-t">-</span></td></tr>
</table></div>
</div>
<div class="spec-production" id="Integer">
<span class="spec-nt"><a href="#Integer" data-name="Integer">Integer</a></span><div class="spec-rhs"><span class="spec-quantified"><span class="spec-nt"><a href="#Sign" data-name="Sign">Sign</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Digit" data-name="Digit">Digit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span></div>
</div>
<div class="spec-production" id="Decimal">
<span class="spec-nt"><a href="#Decimal" data-name="Decimal">Decimal</a></span><div class="spec-rhs"><span class="spec-quantified"><span class="spec-nt"><a href="#Sign" data-name="Sign">Sign</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Digit" data-name="Digit">Digit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-nt"><a href="#Fractional" data-name="Fractional">Fractional</a></span></div>
</div>
<div class="spec-production" id="ScientificNotation">
<span class="spec-nt"><a href="#ScientificNotation" data-name="ScientificNotation">ScientificNotation</a></span><div class="spec-rhs"><span class="spec-quantified"><span class="spec-nt"><a href="#Sign" data-name="Sign">Sign</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Digit" data-name="Digit">Digit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Fractional" data-name="Fractional">Fractional</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-nt"><a href="#ExponentMarker" data-name="ExponentMarker">ExponentMarker</a></span><span class="spec-quantified"><span class="spec-nt"><a href="#Sign" data-name="Sign">Sign</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-nt"><a href="#Digit" data-name="Digit">Digit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span></div>
</div>
<div class="spec-production" id="Fractional">
<span class="spec-nt"><a href="#Fractional" data-name="Fractional">Fractional</a></span><div class="spec-rhs"><span class="spec-t">.</span><span class="spec-quantified"><span class="spec-nt"><a href="#Digit" data-name="Digit">Digit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span></div>
</div>
<div class="spec-production" id="ExponentMarker">
<span class="spec-nt"><a href="#ExponentMarker" data-name="ExponentMarker">ExponentMarker</a></span><div class="spec-oneof"><table>
<tr>
<td class="spec-rhs"><span class="spec-t">e</span></td><td class="spec-rhs"><span class="spec-t">E</span></td></tr>
</table></div>
</div>
</section>
<section id="sec-String" secid="4.4">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-String">4.4</a></span>String</h3>
<p>A string stores an UTF&#8208;8 encoded list of characters.</p>
<p>The syntax of a string literal is a subset of JSON with the following extensions:</p>
<ul>
<li>Any control characters (including newlines) are allowed to appear inside a string.</li>
<li>Extended support for refering to Unicode characters above 16&#8208;bit: <code>&quot;\u{1F600}&quot;</code>.</li>
</ul>
<div class="spec-production" id="String">
<span class="spec-nt"><a href="#String" data-name="String">String</a></span><div class="spec-rhs"><span class="spec-t">&quot;</span><span class="spec-quantified"><span class="spec-nt"><a href="#DoubleStringCharacter" data-name="DoubleStringCharacter">DoubleStringCharacter</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span><span class="spec-quantifier optional">opt</span></span></span><span class="spec-t">&quot;</span></div>
<div class="spec-rhs"><span class="spec-t">&#x27;</span><span class="spec-quantified"><span class="spec-nt"><a href="#SingleStringCharacter" data-name="SingleStringCharacter">SingleStringCharacter</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span><span class="spec-quantifier optional">opt</span></span></span><span class="spec-t">&#x27;</span></div>
</div>
<div class="spec-production" id="DoubleStringCharacter">
<span class="spec-nt"><a href="#DoubleStringCharacter" data-name="DoubleStringCharacter">DoubleStringCharacter</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#SourceCharacter" data-name="SourceCharacter">SourceCharacter</a></span><span class="spec-butnot"><span class="spec-t">&quot;</span><span class="spec-t">\</span></span></span></div>
<div class="spec-rhs"><span class="spec-t">\</span><span class="spec-nt"><a href="#EscapeSequence" data-name="EscapeSequence">EscapeSequence</a></span></div>
</div>
<div class="spec-production" id="SingleStringCharacter">
<span class="spec-nt"><a href="#SingleStringCharacter" data-name="SingleStringCharacter">SingleStringCharacter</a></span><div class="spec-rhs"><span class="spec-constrained"><span class="spec-nt"><a href="#SourceCharacter" data-name="SourceCharacter">SourceCharacter</a></span><span class="spec-butnot"><span class="spec-t">&#x27;</span><span class="spec-t">\</span></span></span></div>
<div class="spec-rhs"><span class="spec-t">\</span><span class="spec-nt"><a href="#EscapeSequence" data-name="EscapeSequence">EscapeSequence</a></span></div>
</div>
<div class="spec-production" id="EscapeSequence">
<span class="spec-nt"><a href="#EscapeSequence" data-name="EscapeSequence">EscapeSequence</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#SingleEscapeSequence" data-name="SingleEscapeSequence">SingleEscapeSequence</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#UnicodeEscapeSequence" data-name="UnicodeEscapeSequence">UnicodeEscapeSequence</a></span></div>
</div>
<div class="spec-production" id="SingleEscapeSequence">
<span class="spec-nt"><a href="#SingleEscapeSequence" data-name="SingleEscapeSequence">SingleEscapeSequence</a></span><div class="spec-oneof"><table>
<tr>
<td class="spec-rhs"><span class="spec-t">&#x27;</span></td><td class="spec-rhs"><span class="spec-t">&quot;</span></td><td class="spec-rhs"><span class="spec-t">\</span></td><td class="spec-rhs"><span class="spec-t">/</span></td><td class="spec-rhs"><span class="spec-t">b</span></td><td class="spec-rhs"><span class="spec-t">f</span></td><td class="spec-rhs"><span class="spec-t">n</span></td><td class="spec-rhs"><span class="spec-t">r</span></td><td class="spec-rhs"><span class="spec-t">t</span></td></tr>
</table></div>
</div>
<div class="spec-production" id="UnicodeEscapeSequence">
<span class="spec-nt"><a href="#UnicodeEscapeSequence" data-name="UnicodeEscapeSequence">UnicodeEscapeSequence</a></span><div class="spec-rhs"><span class="spec-t">u</span><span class="spec-nt"><a href="#HexDigit" data-name="HexDigit">HexDigit</a></span><span class="spec-nt"><a href="#HexDigit" data-name="HexDigit">HexDigit</a></span><span class="spec-nt"><a href="#HexDigit" data-name="HexDigit">HexDigit</a></span><span class="spec-nt"><a href="#HexDigit" data-name="HexDigit">HexDigit</a></span></div>
<div class="spec-rhs"><span class="spec-t">u{</span><span class="spec-quantified"><span class="spec-nt"><a href="#HexDigit" data-name="HexDigit">HexDigit</a></span><span class="spec-quantifiers"><span class="spec-quantifier list">list</span></span></span><span class="spec-t">}</span></div>
</div>
<p>Escape sequences are interpreted as follows:</p>
<ul>
<li><code>\&#x27;</code> represents U+0027.</li>
<li><code>\&quot;</code> represents U+0022.</li>
<li><code>\\</code> represents U+005C.</li>
<li><code>\/</code> represents U+002F.</li>
<li><code>\b</code> represents U+0008.</li>
<li><code>\f</code> represents U+000C.</li>
<li><code>\n</code> represents U+000A.</li>
<li><code>\r</code> represents U+000D.</li>
<li><code>\t</code> represents U+0009.</li>
<li><code>\uXXXX</code> represents the Unicode code point U+XXXX.</li>
<li><code>\uXXXX\uYYYY</code>, where XXXX is a high surrogate (W1, 0xD800&ndash;0xDBFF) and YYYY is a low surrogate (W2, 0xDC00&ndash;0xDFFF) is interpreted as a UTF&#8208;16 surrogate pair and encoded into a single code point.</li>
</ul>
<p>It&rsquo;s a syntactical error when a Unicode escape sequence represents an invalid Unicode code point.</p>
</section>
<section id="sec-Array" secid="4.5">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Array">4.5</a></span>Array</h3>
<p>An ordered collection of values, e.g. <code>[1, 2, 3]</code>. Can contain any combination of other types, including other arrays and mixed types. An element inside an array literal can be preceeded by <code>...</code> which causes it to be flattened into the array.</p>
<div class="spec-production" id="Array">
<span class="spec-nt"><a href="#Array" data-name="Array">Array</a></span><div class="spec-rhs"><span class="spec-t">[</span><span class="spec-quantified"><span class="spec-nt"><a href="#ArrayElements" data-name="ArrayElements">ArrayElements</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-t">,</span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-t">]</span></div>
</div>
<div class="spec-production" id="ArrayElements">
<span class="spec-nt"><a href="#ArrayElements" data-name="ArrayElements">ArrayElements</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#ArrayElement" data-name="ArrayElement">ArrayElement</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#ArrayElements" data-name="ArrayElements">ArrayElements</a></span><span class="spec-t">,</span><span class="spec-nt"><a href="#ArrayElement" data-name="ArrayElement">ArrayElement</a></span></div>
</div>
<div class="spec-production" id="ArrayElement">
<span class="spec-nt"><a href="#ArrayElement" data-name="ArrayElement">ArrayElement</a></span><div class="spec-rhs"><span class="spec-quantified"><span class="spec-t">...</span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateArray()">
<span class="spec-call"><a href="#EvaluateArray()" data-name="EvaluateArray">EvaluateArray</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="result">result</var> be a new empty array.</li>
<li>For each <span class="spec-nt"><a href="#ArrayElement" data-name="ArrayElement">ArrayElement</a></span>:<ol>
<li>Let <var data-name="elementNode">elementNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> of the <span class="spec-nt"><a href="#ArrayElement" data-name="ArrayElement">ArrayElement</a></span>.</li>
<li>Let <var data-name="element">element</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="elementNode">elementNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If the <span class="spec-nt"><a href="#ArrayElement" data-name="ArrayElement">ArrayElement</a></span> contains <span class="spec-t">...</span>:<ol>
<li>If <var data-name="element">element</var> is an array:<ol>
<li>Concatenate <var data-name="element">element</var> to <var data-name="result">result</var>.</li>
</ol>
</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Append <var data-name="element">element</var> to <var data-name="result">result</var>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
</section>
<section id="sec-Object" secid="4.6">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Object">4.6</a></span>Object</h3>
<p>An unordered collection of key/value pairs (referred to as attributes) with unique keys, e.g. <code>{&quot;a&quot;: 1, &quot;b&quot;: 2}</code>. Keys must be strings, while values can be any combination of other types, including other objects. If duplicate keys are specified, the last key is used.</p>
<p>The values of an object literal can use the full power of expressions:</p>
<pre><code>*[_type == &quot;rect&quot;]{&quot;area&quot;: width * height}
</code></pre>
<div id="note-bb598" class="spec-note">
<a href="#note-bb598">Note</a>
A <span class="spec-nt"><a href="#Projection" data-name="Projection">Projection</a></span> expression is just an expression with an object literal to the right of it.</div>
<p>Object literal supports syntactical sugar when the attribute name and value is equivalent:</p>
<pre><code>// These two are equivalent
*[_type == &quot;person&quot;]{name}
*[_type == &quot;person&quot;]{&quot;name&quot;: name}
</code></pre>
<div class="spec-production" id="Object">
<span class="spec-nt"><a href="#Object" data-name="Object">Object</a></span><div class="spec-rhs"><span class="spec-t">{</span><span class="spec-quantified"><span class="spec-nt"><a href="#ObjectAttributes" data-name="ObjectAttributes">ObjectAttributes</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-quantified"><span class="spec-t">,</span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-t">}</span></div>
</div>
<div class="spec-production" id="ObjectAttributes">
<span class="spec-nt"><a href="#ObjectAttributes" data-name="ObjectAttributes">ObjectAttributes</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#ObjectAttributes" data-name="ObjectAttributes">ObjectAttributes</a></span><span class="spec-t">,</span><span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span></div>
</div>
<div class="spec-production" id="ObjectAttribute">
<span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#String" data-name="String">String</a></span><span class="spec-t">:</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
<div class="spec-rhs"><span class="spec-t">...</span><span class="spec-quantified"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span></div>
</div>
<div class="spec-algo" id="EvaluateObject()">
<span class="spec-call"><a href="#EvaluateObject()" data-name="EvaluateObject">EvaluateObject</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="result">result</var> be a new empty object.</li>
<li>For each <span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span>:<ol>
<li>If the <span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span> contains <code>...</code>:<ol>
<li>If the <span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span> constains an <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>:<ol>
<li>Let <var data-name="baseNode">baseNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
</ol>
</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Let <var data-name="base">base</var> be the this value of <var data-name="scope">scope</var>.</li>
</ol>
</li>
<li>For each <var data-name="name">name</var> and <var data-name="value">value</var> of <var data-name="base">base</var>:<ol>
<li>Set the attribute <var data-name="name">name</var> to <var data-name="value">value</var> in <var data-name="result">result</var>.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Let <var data-name="valueNode">valueNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> of the <span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span>.</li>
</ol>
</li>
<li>Let <var data-name="value">value</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="valueNode">valueNode</var>, <var data-name="scope">scope</var>)</span>.<ol>
<li>If the <span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span> contains a <span class="spec-nt"><a href="#String" data-name="String">String</a></span>:<ol>
<li>Let <var data-name="name">name</var> be the string value of the <span class="spec-nt"><a href="#String" data-name="String">String</a></span>.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Let <var data-name="name">name</var> be the result of <span class="spec-call"><a href="#DetermineName()" data-name="DetermineName">DetermineName</a>(<var data-name="valueNode">valueNode</var>)</span>.</li>
</ol>
</li>
<li>Set the attribute <var data-name="name">name</var> to <var data-name="value">value</var> in <var data-name="result">result</var>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
<div class="spec-algo" id="DetermineName()">
<span class="spec-call"><a href="#DetermineName()" data-name="DetermineName">DetermineName</a>(<var data-name="node">node</var>)</span><ol>
<li>If <var data-name="node">node</var> is an <span class="spec-nt"><a href="#ThisAttribute" data-name="ThisAttribute">ThisAttribute</a></span>:<ol>
<li>Return the string value of the <span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span> of <var data-name="node">node</var>.</li>
</ol>
</li>
<li>If <var data-name="node">node</var> is a <span class="spec-nt"><a href="#Projection" data-name="Projection">Projection</a></span>, <span class="spec-nt"><a href="#ElementAccess" data-name="ElementAccess">ElementAccess</a></span>, <span class="spec-nt"><a href="#Slice" data-name="Slice">Slice</a></span>, or <span class="spec-nt"><a href="#Filter" data-name="Filter">Filter</a></span>:<ol>
<li>Let <var data-name="base">base</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> of <var data-name="expr">expr</var>.</li>
<li>Return the result of <span class="spec-call"><a href="#DetermineName()" data-name="DetermineName">DetermineName</a>(<var data-name="base">base</var>)</span>.</li>
</ol>
</li>
</ol>
</div>
<div class="spec-algo" id="ValidateObject()">
<span class="spec-call"><a href="#ValidateObject()" data-name="ValidateObject">ValidateObject</a>()</span><ol>
<li>For each <span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span>:<ol>
<li>If the <span class="spec-nt"><a href="#ObjectAttribute" data-name="ObjectAttribute">ObjectAttribute</a></span> does not contain a <span class="spec-nt"><a href="#String" data-name="String">String</a></span>:<ol>
<li>Let <var data-name="expr">expr</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
</ol>
</li>
<li>Execute <span class="spec-call"><a href="#ValidateObjectAttribute()" data-name="ValidateObjectAttribute">ValidateObjectAttribute</a>(<var data-name="expr">expr</var>)</span>.</li>
</ol>
</li>
</ol>
</div>
<div class="spec-algo" id="ValidateObjectAttribute()">
<span class="spec-call"><a href="#ValidateObjectAttribute()" data-name="ValidateObjectAttribute">ValidateObjectAttribute</a>(<var data-name="expr">expr</var>)</span><ol>
<li>If <var data-name="node">node</var> is an <span class="spec-nt"><a href="#ThisAttribute" data-name="ThisAttribute">ThisAttribute</a></span>:<ol>
<li>Stop.</li>
</ol>
</li>
<li>If <var data-name="node">node</var> is a <span class="spec-nt"><a href="#Projection" data-name="Projection">Projection</a></span>, <span class="spec-nt"><a href="#ElementAccess" data-name="ElementAccess">ElementAccess</a></span>, <span class="spec-nt"><a href="#Slice" data-name="Slice">Slice</a></span>, or <span class="spec-nt"><a href="#Filter" data-name="Filter">Filter</a></span>:<ol>
<li>Let <var data-name="base">base</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> of <var data-name="expr">expr</var>.</li>
<li>Execute <span class="spec-call"><a href="#ValidateObjectAttribute()" data-name="ValidateObjectAttribute">ValidateObjectAttribute</a>(<var data-name="base">base</var>)</span>.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Report an error.</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-Pair" secid="4.7">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Pair">4.7</a></span>Pair</h3>
<p>A pair of values, e.g. <code>&quot;a&quot; =&gt; 1</code>. Pairs can contain any combination of other types, including other pairs, and are mainly used internally with e.g. projection conditionals and<code>select()</code>.</p>
<p>In serialized JSON, pairs are represented as a string on the form <code>fst =&gt; snd</code> where <code>fst</code> and <code>snd</code> are the serialized JSON for the first and the second expression.</p>
<div class="spec-production" id="Pair">
<span class="spec-nt"><a href="#Pair" data-name="Pair">Pair</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">=&gt;</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluatePair()">
<span class="spec-call"><a href="#EvaluatePair()" data-name="EvaluatePair">EvaluatePair</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="firstNode">firstNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="secondNode">secondNode</var> be the second <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="result">result</var> be a new pair.</li>
<li>Set the first value of <var data-name="result">result</var> to the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="firstNode">firstNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Set the second value of <var data-name="result">result</var> to the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="secondNode">secondNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
</section>
<section id="sec-Range" secid="4.8">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Range">4.8</a></span>Range</h3>
<p>An interval containing all values that are ordered between the start and end values. The starting value is always included, while the end may be either included or excluded. A right&#8208;inclusive range is expressed as two values separated by <code>..</code>, e.g. <code>1..3</code>, while a right&#8208;exclusive range is separated by <code>...</code>, e.g. <code>1...3</code>.</p>
<p>Ranges can have endpoints of any comparable data type, but both endpoints must be of the same type (except integers and floats which can be used interchangeably). Ranges with incompatible or invalid endpoints types will yield <code>null</code>.</p>
<p>Ranges are mainly used internally, e.g. with the <code>in</code> operator and array slice access operator. The endpoints may have context&#8208;dependant semantics, e.g. in array slices the range <code>[2..-1]</code> will cover the range from the third array element to the last element, while the same range is considered empty when used with <code>in</code>. For more details, see the documentation for the relevant operators.</p>
<p>In serialized JSON, ranges are represented as a string on the form <code>start..end</code> (for inclusive ranges) and <code>start...end</code> (for exclusive ranges) where <code>start</code> and <code>end</code> are the serialized JSON for the start and the end expression.</p>
<div class="spec-production" id="Range">
<span class="spec-nt"><a href="#Range" data-name="Range">Range</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#InclusiveRange" data-name="InclusiveRange">InclusiveRange</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#ExclusiveRange" data-name="ExclusiveRange">ExclusiveRange</a></span></div>
</div>
<div class="spec-production" id="InclusiveRange">
<span class="spec-nt"><a href="#InclusiveRange" data-name="InclusiveRange">InclusiveRange</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">..</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-production" id="ExclusiveRange">
<span class="spec-nt"><a href="#ExclusiveRange" data-name="ExclusiveRange">ExclusiveRange</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">...</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateRange()">
<span class="spec-call"><a href="#EvaluateRange()" data-name="EvaluateRange">EvaluateRange</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="startNode">startNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="endNode">endNode</var> be the second <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="start">start</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="startNode">startNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="end">end</var> be the result of <span class="spec-call"><span data-name="Evalaute">Evalaute</span>(<var data-name="endNode">endNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <span class="spec-call"><a href="#PartialCompare()" data-name="PartialCompare">PartialCompare</a>(<var data-name="start">start</var>, <var data-name="end">end</var>)</span> is <span class="spec-keyword">null</span>:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>Let <var data-name="result">result</var> be a new range.</li>
<li>Set the start value of <var data-name="result">result</var> to <var data-name="start">start</var>.</li>
<li>Set the end value of <var data-name="result">result</var> to <var data-name="end">end</var>.</li>
<li>Mark the range as inclusive or exclusive.</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
</section>
<section id="sec-Datetime" secid="4.9">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Datetime">4.9</a></span>Datetime</h3>
<p>A datetime is a combination of a Gregorian&#8208;calendar date and a time in a specific time zone. Datetimes support date/time arithmetic. Only valid date/time combinations can be represented.</p>
<p>Datetimes cannot be constructed from literals, but must be constructed with the <code>dateTime()</code> function.</p>
<p>In serialized JSON, datetimes are represented as a string with using <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> timestamp format, e.g. <code>2006-01-02T15:04:05Z07:00</code>. </p>
</section>
</section>
<section id="sec-Equality-and-comparison" secid="5">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Equality-and-comparison">5</a></span>Equality and comparison</h2>
<p>GROQ provides trivial equality and comparison between numbers, strings and booleans. Other types are considered inequal or incomparable to each other. Incomparability between values are represented by operators returning <span class="spec-keyword">null</span> (e.g. <code>2 &gt; &quot;1&quot;</code> is <span class="spec-keyword">null</span>).</p>
<section id="sec-Equality" secid="5.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Equality">5.1</a></span>Equality</h3>
<p>Simple values such as numbers, strings, booleans and <span class="spec-keyword">null</span> are equal when they contain the same data. All other values are considered inequal to each other (e.g. <code>[] != []</code>).</p>
<div id="note-07354" class="spec-note">
<a href="#note-07354">Note</a>
In GROQ <code>1 == null</code> returns <code>false</code> (which is different from e.g. SQL). </div>
<div class="spec-algo" id="Equal()">
<span class="spec-call"><a href="#Equal()" data-name="Equal">Equal</a>(<var data-name="a">a</var>, <var data-name="b">b</var>)</span><ol>
<li>If both <var data-name="a">a</var> and <var data-name="b">b</var> is <span class="spec-keyword">null</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>Let <var data-name="cmp">cmp</var> be the result of <span class="spec-call"><a href="#PartialCompare()" data-name="PartialCompare">PartialCompare</a>(<var data-name="a">a</var>, <var data-name="b">b</var>)</span>.</li>
<li>If <var data-name="cmp">cmp</var> is <span class="spec-nt"><span data-name="Equal">Equal</span></span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-Partial-comparison" secid="5.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Partial-comparison">5.2</a></span>Partial comparison</h3>
<p>A partial comparison between two values return either <span class="spec-nt"><span data-name="Greater">Greater</span></span>, <span class="spec-nt"><span data-name="Equal">Equal</span></span>, <span class="spec-nt"><span data-name="Less">Less</span></span> or <span class="spec-keyword">null</span>. <span class="spec-keyword">null</span> represents that the values are incomparable to each other. This is used by the comparison operators (&lt;, &le;, &gt;, &ge;).</p>
<div class="spec-algo" id="PartialCompare()">
<span class="spec-call"><a href="#PartialCompare()" data-name="PartialCompare">PartialCompare</a>(<var data-name="a">a</var>, <var data-name="b">b</var>)</span><ol>
<li>If the type of <var data-name="a">a</var> is different from the type of <var data-name="b">b</var>:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>If <var data-name="a">a</var> is a number:<ol>
<li>If a &lt; b:<ol>
<li>Return <span class="spec-nt"><span data-name="Less">Less</span></span>.</li>
</ol>
</li>
<li>If a &gt; b:<ol>
<li>Return <span class="spec-nt"><span data-name="Greater">Greater</span></span>.</li>
</ol>
</li>
<li>If a = b:<ol>
<li>Return <span class="spec-nt"><span data-name="Equal">Equal</span></span>.</li>
</ol>
</li>
</ol>
</li>
<li>If <var data-name="a">a</var> is a datetime, consider the datetimes as absolute points in time in the UTC time zone:<ol>
<li>If a &lt; b:<ol>
<li>Return <span class="spec-nt"><span data-name="Less">Less</span></span>.</li>
</ol>
</li>
<li>If a &gt; b:<ol>
<li>Return <span class="spec-nt"><span data-name="Greater">Greater</span></span>.</li>
</ol>
</li>
<li>If a = b:<ol>
<li>Return <span class="spec-nt"><span data-name="Equal">Equal</span></span>.</li>
</ol>
</li>
</ol>
</li>
<li>If <var data-name="a">a</var> is a string:<ol>
<li>For each Unicode code point (<var data-name="aCodePoint">aCodePoint</var>, <var data-name="bCodePoint">bCodePoint</var>) in <var data-name="a">a</var> and <var data-name="b">b</var>:<ol>
<li>If <var data-name="aCodePoint">aCodePoint</var> &lt; <var data-name="bCodePoint">bCodePoint</var>:<ol>
<li>Return <span class="spec-nt"><span data-name="Less">Less</span></span>.</li>
</ol>
</li>
</ol>
</li>
<li>If <var data-name="aCodePoint">aCodePoint</var> &gt; <var data-name="bCodePoint">bCodePoint</var>:<ol>
<li>Return <span class="spec-nt"><span data-name="Greater">Greater</span></span>.</li>
</ol>
</li>
<li>If <var data-name="a">a</var> is shorter than <var data-name="b">b</var>:<ol>
<li>Return <span class="spec-nt"><span data-name="Less">Less</span></span>.</li>
</ol>
</li>
<li>If <var data-name="a">a</var> is longer than <var data-name="b">b</var>:<ol>
<li>Return <span class="spec-nt"><span data-name="Greater">Greater</span></span>.</li>
</ol>
</li>
<li>Return <span class="spec-nt"><span data-name="Equal">Equal</span></span>.</li>
</ol>
</li>
<li>If <var data-name="a">a</var> is a boolean:<ol>
<li>Return the comparison between <var data-name="a">a</var> and <var data-name="b">b</var> with <span class="spec-keyword">false</span> &lt; <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Total-comparison" secid="5.3">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Total-comparison">5.3</a></span>Total comparison</h3>
<p>A total comparison between two values return either <span class="spec-nt"><span data-name="Greater">Greater</span></span>, <span class="spec-nt"><span data-name="Equal">Equal</span></span> or <span class="spec-nt"><span data-name="Less">Less</span></span>. It provides a consistent ordering of values of different types (for string, numbers and boolean) and considers all other types to be equal to each other. This is used by the <span class="spec-call"><a href="#order()" data-name="order">order</a>()</span> function.</p>
<div class="spec-algo" id="TypeOrder()">
<span class="spec-call"><a href="#TypeOrder()" data-name="TypeOrder">TypeOrder</a>(<var data-name="val">val</var>)</span><ol>
<li>If <var data-name="val">val</var> is datetime:<ol>
<li>Return 1.</li>
</ol>
</li>
<li>If <var data-name="val">val</var> is number:<ol>
<li>Return 2.</li>
</ol>
</li>
<li>If <var data-name="val">val</var> is a string:<ol>
<li>Return 3.</li>
</ol>
</li>
<li>If <var data-name="val">val</var> is a boolean:<ol>
<li>Return 4.</li>
</ol>
</li>
<li>Return 5.</li>
</ol>
</div>
<div class="spec-algo" id="TotalCompare()">
<span class="spec-call"><a href="#TotalCompare()" data-name="TotalCompare">TotalCompare</a>(<var data-name="a">a</var>, <var data-name="b">b</var>)</span><ol>
<li>Let <var data-name="aTypeOrder">aTypeOrder</var> be the result of <span class="spec-call"><a href="#TypeOrder()" data-name="TypeOrder">TypeOrder</a>(<var data-name="a">a</var>)</span>.</li>
<li>Let <var data-name="bTypeOrder">bTypeOrder</var> be the result of <span class="spec-call"><a href="#TypeOrder()" data-name="TypeOrder">TypeOrder</a>(<var data-name="b">b</var>)</span>.</li>
<li>If <var data-name="aTypeOrder">aTypeOrder</var> != <var data-name="bTypeOrder">bTypeOrder</var>:<ol>
<li>Return the result of <span class="spec-call"><a href="#PartialCompare()" data-name="PartialCompare">PartialCompare</a>(<var data-name="aTypeOrder">aTypeOrder</var>, <var data-name="bTypeOrder">bTypeOrder</var>)</span>.</li>
</ol>
</li>
<li>Let <var data-name="result">result</var> be the result of <span class="spec-call"><a href="#PartialCompare()" data-name="PartialCompare">PartialCompare</a>(<var data-name="a">a</var>, <var data-name="b">b</var>)</span>.</li>
<li>If <var data-name="result">result</var> is <span class="spec-keyword">null</span>:<ol>
<li>Return <span class="spec-nt"><span data-name="Equal">Equal</span></span>.</li>
</ol>
</li>
<li>Otherwise:</li>
<li>Return <var data-name="result">result</var>. </li>
</ol>
</div>
</section>
</section>
<section id="sec-Simple-expressions" secid="6">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Simple-expressions">6</a></span>Simple expressions</h2>
<section id="sec-This-expression" secid="6.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-This-expression">6.1</a></span>This expression</h3>
<p>A this expression returns the this value of the current scope.</p>
<pre><code>*[_id == &quot;doc&quot;][0].numbers[@ &gt;= 10]
                           ~
</code></pre>
<div class="spec-production" id="This">
<span class="spec-nt"><a href="#This" data-name="This">This</a></span><div class="spec-rhs"><span class="spec-t">@</span></div>
</div>
<div class="spec-algo" id="EvaluateThis()">
<span class="spec-call"><a href="#EvaluateThis()" data-name="EvaluateThis">EvaluateThis</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Return the this value of <var data-name="scope">scope</var>.</li>
</ol>
</div>
</section>
<section id="sec-This-attribute-expression" secid="6.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-This-attribute-expression">6.2</a></span>This attribute expression</h3>
<p>A <em>this attribute expression </em>returns an attribute from the this value of the current scope.</p>
<pre><code>*[_id == &quot;document&quot;][name == &quot;Michael Bluth&quot;]
  ~~~                ~~~~
</code></pre>
<div class="spec-production" id="ThisAttribute">
<span class="spec-nt"><a href="#ThisAttribute" data-name="ThisAttribute">ThisAttribute</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span></div>
</div>
<div class="spec-algo" id="EvaluateThisAttribute()">
<span class="spec-call"><a href="#EvaluateThisAttribute()" data-name="EvaluateThisAttribute">EvaluateThisAttribute</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="base">base</var> be the this value of <var data-name="scope">scope</var>.</li>
<li>Let <var data-name="name">name</var> be the string value of the <span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span>.</li>
<li>If <var data-name="base">base</var> is not an object, return <span class="spec-keyword">null</span>.</li>
<li>If <var data-name="base">base</var> does not contain an attribute <var data-name="name">name</var>, return <span class="spec-keyword">null</span>.</li>
<li>Return the value of the attribute <var data-name="name">name</var> in <var data-name="base">base</var>.</li>
</ol>
</div>
</section>
<section id="sec-Everything-expression" secid="6.3">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Everything-expression">6.3</a></span>Everything expression</h3>
<p>An everything expression returns the full dataset.</p>
<pre><code>*[_type == &quot;person&quot;]
~
</code></pre>
<div class="spec-production" id="Everything">
<span class="spec-nt"><a href="#Everything" data-name="Everything">Everything</a></span><div class="spec-rhs"><span class="spec-t">*</span></div>
</div>
<div class="spec-algo" id="EvaluateEverything()">
<span class="spec-call"><a href="#EvaluateEverything()" data-name="EvaluateEverything">EvaluateEverything</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="context">context</var> be the query context of <var data-name="scope">scope</var>.</li>
<li>Return the dataset of <var data-name="context">context</var>.</li>
</ol>
</div>
</section>
<section id="sec-Parent-expression" secid="6.4">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Parent-expression">6.4</a></span>Parent expression</h3>
<p>A parent expression returns a this value for an upper scope.</p>
<pre><code>// Find all people who have a cool friend
*[_type == &quot;person&quot; &amp;&amp; *[_id == ^.friend._ref][0].isCool]
                                ~
</code></pre>
<div class="spec-production" id="Parent">
<span class="spec-nt"><a href="#Parent" data-name="Parent">Parent</a></span><div class="spec-rhs"><span class="spec-t">^</span></div>
<div class="spec-rhs"><span class="spec-t">^.</span><span class="spec-nt"><a href="#Parent" data-name="Parent">Parent</a></span></div>
</div>
<div class="spec-algo" id="EvaluateParent()">
<span class="spec-call"><a href="#EvaluateParent()" data-name="EvaluateParent">EvaluateParent</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="level">level</var> be the number of <code>^</code> in the parent expression.</li>
<li>Let <var data-name="currentScope">currentScope</var> be <var data-name="scope">scope</var>.</li>
<li>While <var data-name="level">level</var> is greater than zero:<ol>
<li>Set <var data-name="currentScope">currentScope</var> to the parent of <var data-name="currentScope">currentScope</var>. </li>
<li>If <var data-name="currentScope">currentScope</var> is now <span class="spec-keyword">null</span>, return <span class="spec-keyword">null</span>.</li>
<li>Decrease <var data-name="level">level</var> by one.</li>
</ol>
</li>
<li>Return the this value of <var data-name="currentScope">currentScope</var>.</li>
</ol>
</div>
</section>
<section id="sec-Function-call-expression" secid="6.5">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Function-call-expression">6.5</a></span>Function call expression</h3>
<p>GROQ comes with a set of built&#8208;in functions which provides additional features. See the <a href="#sec-Functions">&ldquo;Functions&rdquo;</a> for available functions.</p>
<pre><code>*{&quot;score&quot;: round(score, 2)}
           ~~~~~~~~~~~~~~~
</code></pre>
<div class="spec-production" id="FuncCall">
<span class="spec-nt"><a href="#FuncCall" data-name="FuncCall">FuncCall</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span><span class="spec-t">(</span><span class="spec-nt"><a href="#FuncCallArgs" data-name="FuncCallArgs">FuncCallArgs</a></span><span class="spec-t">)</span></div>
</div>
<div class="spec-production" id="FuncCallArgs">
<span class="spec-nt"><a href="#FuncCallArgs" data-name="FuncCallArgs">FuncCallArgs</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#FuncCallArgs" data-name="FuncCallArgs">FuncCallArgs</a></span><span class="spec-t">,</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateFuncCall()">
<span class="spec-call"><a href="#EvaluateFuncCall()" data-name="EvaluateFuncCall">EvaluateFuncCall</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="name">name</var> be the string value of the <span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span>.</li>
<li>Let <var data-name="args">args</var> be an empty array.</li>
<li>For each <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> in <span class="spec-nt"><a href="#FuncCallArgs" data-name="FuncCallArgs">FuncCallArgs</a></span>:<ol>
<li>Let <var data-name="argumentNode">argumentNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Append <var data-name="argumentNode">argumentNode</var> to <var data-name="args">args</var>.</li>
</ol>
</li>
<li>Let <var data-name="func">func</var> be the function defined under the name <var data-name="name">name</var>.</li>
<li>Return the result of <span class="spec-call"><span data-name="func">func</span>(<var data-name="args">args</var>, <var data-name="scope">scope</var>)</span>.</li>
</ol>
</div>
<div class="spec-algo" id="ValidateFuncCall()">
<span class="spec-call"><a href="#ValidateFuncCall()" data-name="ValidateFuncCall">ValidateFuncCall</a>()</span><ol>
<li>Let <var data-name="name">name</var> be the string value of the <span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span>.</li>
<li>If there is no function named <var data-name="name">name</var>:<ol>
<li>Stop and report an error.</li>
</ol>
</li>
<li>Let <var data-name="args">args</var> be an array of the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>s in <span class="spec-nt"><a href="#FuncCallArgs" data-name="FuncCallArgs">FuncCallArgs</a></span>.</li>
<li>Let <var data-name="validator">validator</var> be the validator for the function under the name <var data-name="name">name</var>.</li>
<li>Execute <span class="spec-call"><span data-name="validator">validator</span>(<var data-name="args">args</var>)</span>.</li>
</ol>
</div>
</section>
</section>
<section id="sec-Compound-expressions" secid="7">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Compound-expressions">7</a></span>Compound expressions</h2>
<section id="sec-Parenthesis-expression" secid="7.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Parenthesis-expression">7.1</a></span>Parenthesis expression</h3>
<p>A parenthesis expression allows you to add parenthesis around another expression to control precedence of operators.</p>
<pre><code>(1 + 2) * 3
~~~~~~~
</code></pre>
<div class="spec-production" id="Parenthesis">
<span class="spec-nt"><a href="#Parenthesis" data-name="Parenthesis">Parenthesis</a></span><div class="spec-rhs"><span class="spec-t">(</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">)</span></div>
</div>
<div class="spec-algo" id="EvaluateParenthesis()">
<span class="spec-call"><a href="#EvaluateParenthesis()" data-name="EvaluateParenthesis">EvaluateParenthesis</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="innerNode">innerNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="result">result</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="innerNode">innerNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
</section>
<section id="sec-Attribute-access-expression" secid="7.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Attribute-access-expression">7.2</a></span>Attribute access expression</h3>
<p>An attribute access expression returns an attribute of an object.</p>
<pre><code>person.name
      ~~~~~
      
person[&quot;Full Name&quot;]
      ~~~~~~~~~~~~~
</code></pre>
<div class="spec-production" id="AttributeAccess">
<span class="spec-nt"><a href="#AttributeAccess" data-name="AttributeAccess">AttributeAccess</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">.</span><span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span></div>
<div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">[</span><span class="spec-nt"><a href="#String" data-name="String">String</a></span><span class="spec-t">]</span></div>
</div>
<div id="note-0e2d4" class="spec-note">
<a href="#note-0e2d4">Note</a>
This expression is syntactially a subset of a filter expression.</div>
<div class="spec-algo" id="EvaluateAttributeAccess()">
<span class="spec-call"><a href="#EvaluateAttributeAccess()" data-name="EvaluateAttributeAccess">EvaluateAttributeAccess</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="baseNode">baseNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is not an object, return <span class="spec-keyword">null</span>.</li>
<li>Let <var data-name="name">name</var> be the string value of <span class="spec-nt"><a href="#String" data-name="String">String</a></span> or <span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span>.</li>
<li>If <var data-name="base">base</var> does not contain an attribute <var data-name="name">name</var>, return <span class="spec-keyword">null</span>.</li>
<li>Return the value of the attribute <var data-name="name">name</var> in <var data-name="base">base</var>.</li>
</ol>
</div>
</section>
<section id="sec-Element-access-expression" secid="7.3">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Element-access-expression">7.3</a></span>Element access expression</h3>
<p>An element access expression returns an element stored in an array. The array is 0&#8208;indexed and a negative index accesses the array from the end (i.e. an index of -1 returns the last element; -2 refers to the second last element).</p>
<div class="spec-production" id="ElementAccess">
<span class="spec-nt"><a href="#ElementAccess" data-name="ElementAccess">ElementAccess</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">[</span><span class="spec-nt"><a href="#Integer" data-name="Integer">Integer</a></span><span class="spec-t">]</span></div>
</div>
<div id="note-0e2d4b" class="spec-note">
<a href="#note-0e2d4b">Note</a>
This expression is syntactially a subset of a filter expression.</div>
<div class="spec-algo" id="EvaluateElementAccess()">
<span class="spec-call"><a href="#EvaluateElementAccess()" data-name="EvaluateElementAccess">EvaluateElementAccess</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="baseNode">baseNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is not an array, return <span class="spec-keyword">null</span>.</li>
<li>Let <var data-name="idx">idx</var> be the number value of <span class="spec-nt"><a href="#Integer" data-name="Integer">Integer</a></span>.</li>
<li>If <var data-name="idx">idx</var> is negative, add the length of <var data-name="base">base</var> to <var data-name="idx">idx</var>.</li>
<li>If <var data-name="idx">idx</var> is still negative, return <span class="spec-keyword">null</span>.</li>
<li>If <var data-name="idx">idx</var> is equal to or greater than the length of <var data-name="base">base</var>, return <span class="spec-keyword">null</span>.</li>
<li>Return the value stored at position <var data-name="idx">idx</var> in <var data-name="base">base</var>.</li>
</ol>
</div>
</section>
<section id="sec-Slice-expression" secid="7.4">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Slice-expression">7.4</a></span>Slice expression</h3>
<p>A slice expression returns a slice of an array.</p>
<pre><code>people[0..10]
      ~~~~~~~
</code></pre>
<div class="spec-production" id="Slice">
<span class="spec-nt"><a href="#Slice" data-name="Slice">Slice</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">[</span><span class="spec-nt"><a href="#Range" data-name="Range">Range</a></span><span class="spec-t">]</span></div>
</div>
<div id="note-31a61" class="spec-note">
<a href="#note-31a61">Note</a>
This expression is syntactically a subset of a filter expression.</div>
<div class="spec-algo" id="EvaluateSlice()">
<span class="spec-call"><a href="#EvaluateSlice()" data-name="EvaluateSlice">EvaluateSlice</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="baseNode">baseNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is not an array, return <span class="spec-keyword">null</span>.</li>
<li>Process the left index:<ol>
<li>Let <var data-name="leftNode">leftNode</var> be the left value of the <span class="spec-nt"><a href="#Range" data-name="Range">Range</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="left">left</var> is not a number, return <span class="spec-keyword">null</span>.</li>
<li>If <var data-name="left">left</var> is negative, add the length of <var data-name="base">base</var> to <var data-name="left">left</var>.</li>
<li>Clamp <var data-name="left">left</var> between 0 and (the length of <var data-name="base">base</var> minus 1).</li>
</ol>
</li>
<li>Process the right index:<ol>
<li>Let <var data-name="rightNode">rightNode</var> be the right value of the <span class="spec-nt"><a href="#Range" data-name="Range">Range</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="right">right</var> is not a number, return <span class="spec-keyword">null</span>.</li>
<li>If <var data-name="right">right</var> is negative, add the length of <var data-name="base">base</var> to <var data-name="right">right</var>.</li>
<li>If the <span class="spec-nt"><a href="#Range" data-name="Range">Range</a></span> is exclusive, subtract one from <var data-name="right">right</var>.</li>
<li>Clamp <var data-name="right">right</var> between 0 and (the length of <var data-name="base">base</var> minus 1).</li>
</ol>
</li>
<li>Let <var data-name="result">result</var> be an array containing the elements of <var data-name="base">base</var> from position <var data-name="left">left</var> up to and including position <var data-name="right">right</var>.</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
</section>
<section id="sec-Filter-expression" secid="7.5">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Filter-expression">7.5</a></span>Filter expression</h3>
<p>A filter expression filters an array using another expression. </p>
<pre><code>*[_type == &quot;person&quot;]
 ~~~~~~~~~~~~~~~~~~~
</code></pre>
<div class="spec-production" id="Filter">
<span class="spec-nt"><a href="#Filter" data-name="Filter">Filter</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">[</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">]</span></div>
</div>
<div id="note-783b9" class="spec-note">
<a href="#note-783b9">Note</a>
If the second Expression is a string/integer/range literal, this is parsed as an attribute access/element access/slice expression instead.</div>
<div class="spec-algo" id="EvaluateFilter()">
<span class="spec-call"><a href="#EvaluateFilter()" data-name="EvaluateFilter">EvaluateFilter</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="baseNode">baseNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is not an array, return <var data-name="base">base</var>.</li>
<li>Let <var data-name="filterNode">filterNode</var> be the second <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="result">result</var> be a new empty array.</li>
<li>For each element <var data-name="value">value</var> in <var data-name="baseValue">baseValue</var>:<ol>
<li>Let <var data-name="elementScope">elementScope</var> be the result of <span class="spec-call"><a href="#NewNestedScope()" data-name="NewNestedScope">NewNestedScope</a>(<var data-name="value">value</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="matched">matched</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="filterNode">filterNode</var>, <var data-name="elementScope">elementScope</var>)</span>.</li>
<li>If <var data-name="matched">matched</var> is <span class="spec-keyword">true</span>, append <var data-name="value">value</var> to <var data-name="result">result</var>.</li>
</ol>
</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
</section>
<section id="sec-Projection-expression" secid="7.6">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Projection-expression">7.6</a></span>Projection expression</h3>
<p>A projection expression iterates over an array and creates new objects for each element. </p>
<pre><code>*[_type == &quot;person&quot;]{name, &quot;isLegal&quot;: age &gt;= 18}
                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<div class="spec-production" id="Projection">
<span class="spec-nt"><a href="#Projection" data-name="Projection">Projection</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-quantified"><span class="spec-t">|</span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span><span class="spec-nt"><a href="#Object" data-name="Object">Object</a></span></div>
</div>
<div class="spec-algo" id="EvaluateProjection()">
<span class="spec-call"><a href="#EvaluateProjection()" data-name="EvaluateProjection">EvaluateProjection</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="baseNode">baseNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="objNode">objNode</var> be the <span class="spec-nt"><a href="#Object" data-name="Object">Object</a></span>.</li>
<li>If <var data-name="base">base</var> is not an array:<ol>
<li>Let <var data-name="elementScope">elementScope</var> be the result of <span class="spec-call"><a href="#NewNestedScope()" data-name="NewNestedScope">NewNestedScope</a>(<var data-name="base">base</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="result">result</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="objNode">objNode</var>, <var data-name="elementScope">elementScope</var>)</span>.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Let <var data-name="result">result</var> be a new empty array.</li>
<li>For each element <var data-name="value">value</var> in <var data-name="base">base</var>:<ol>
<li>Let <var data-name="elementScope">elementScope</var> be the result of <span class="spec-call"><a href="#NewNestedScope()" data-name="NewNestedScope">NewNestedScope</a>(<var data-name="value">value</var>, <var data-name="scope">scope</var>)</span>.</li>
</ol>
</li>
<li>Let <var data-name="newValue">newValue</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="objNode">objNode</var>, <var data-name="elementScope">elementScope</var>)</span>.<ol>
<li>Append <var data-name="newValue">newValue</var> to <var data-name="result">result</var>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
</section>
<section id="sec-Pipe-function-call-expression" secid="7.7">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Pipe-function-call-expression">7.7</a></span>Pipe function call expression</h3>
<p>GROQ comes with a set of built&#8208;in pipe functions which provides additional features. Pipe functions always accepts an array on the left&#8208;hand side and returns another array, and the syntax is optimized for being able to chain it together with other compund expressions. See the <a href="#sec-Pipe-functions">&ldquo;Pipe functions&rdquo;</a> for available functions.</p>
<pre><code>*[_type == &quot;person&quot;] | order(name) | {age}
                     ~~~~~~~~~~~~~
</code></pre>
<div class="spec-production" id="PipeFuncCall">
<span class="spec-nt"><a href="#PipeFuncCall" data-name="PipeFuncCall">PipeFuncCall</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">|</span><span class="spec-nt"><a href="#FuncCall" data-name="FuncCall">FuncCall</a></span></div>
</div>
<div class="spec-algo" id="EvaluatePipeFuncCall()">
<span class="spec-call"><a href="#EvaluatePipeFuncCall()" data-name="EvaluatePipeFuncCall">EvaluatePipeFuncCall</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="baseNode">baseNode</var> be the first Expression.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is not an array:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>Let <var data-name="name">name</var> be the string value of the <span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span> of the <span class="spec-nt"><a href="#FuncCall" data-name="FuncCall">FuncCall</a></span>.</li>
<li>Let <var data-name="args">args</var> be an empty array.</li>
<li>For each <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> in the <span class="spec-nt"><a href="#FuncCallArgs" data-name="FuncCallArgs">FuncCallArgs</a></span> of the <span class="spec-nt"><a href="#FuncCall" data-name="FuncCall">FuncCall</a></span>.<ol>
<li>Let <var data-name="argumentNode">argumentNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Append <var data-name="argumentNode">argumentNode</var> to <var data-name="args">args</var>.</li>
</ol>
</li>
<li>Let <var data-name="func">func</var> be the pipe function defined under the name <var data-name="name">name</var>.</li>
<li>Return the result of <span class="spec-call"><span data-name="func">func</span>(<var data-name="base">base</var>, <var data-name="args">args</var>, <var data-name="scope">scope</var>)</span>.</li>
</ol>
</div>
<div class="spec-algo" id="ValidatePipeFuncCall()">
<span class="spec-call"><a href="#ValidatePipeFuncCall()" data-name="ValidatePipeFuncCall">ValidatePipeFuncCall</a>()</span><ol>
<li>Let <var data-name="base">base</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Execute <span class="spec-call"><a href="#Validate()" data-name="Validate">Validate</a>(<var data-name="base">base</var>)</span>.</li>
<li>Let <var data-name="name">name</var> be the string value of the <span class="spec-nt"><a href="#Identifier" data-name="Identifier">Identifier</a></span> of the <span class="spec-nt"><a href="#FuncCall" data-name="FuncCall">FuncCall</a></span>.</li>
<li>If there is no pipe function named <var data-name="name">name</var>:<ol>
<li>Stop and report an error.</li>
</ol>
</li>
<li>Let <var data-name="args">args</var> be an array of the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>s in the <span class="spec-nt"><a href="#FuncCallArgs" data-name="FuncCallArgs">FuncCallArgs</a></span> of the <span class="spec-nt"><a href="#FuncCall" data-name="FuncCall">FuncCall</a></span>.</li>
<li>Let <var data-name="validator">validator</var> be the validator for the pipe function under the name <var data-name="name">name</var>.</li>
<li>Execute <span class="spec-call"><span data-name="validator">validator</span>(<var data-name="args">args</var>)</span>.</li>
</ol>
</div>
</section>
</section>
<section id="sec-Operators" secid="8">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Operators">8</a></span>Operators</h2>
<section id="sec-And-operator" secid="8.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-And-operator">8.1</a></span>And operator</h3>
<div class="spec-production" id="And">
<span class="spec-nt"><a href="#And" data-name="And">And</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">&amp;&amp;</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateAnd()">
<span class="spec-call"><a href="#EvaluateAnd()" data-name="EvaluateAnd">EvaluateAnd</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="left">left</var> or <var data-name="right">right</var> is <span class="spec-keyword">false</span>:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>If <var data-name="left">left</var> or <var data-name="right">right</var> is not a boolean:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</div>
</section>
<section id="sec-Or-operator" secid="8.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Or-operator">8.2</a></span>Or operator</h3>
<div class="spec-production" id="Or">
<span class="spec-nt"><a href="#Or" data-name="Or">Or</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">||</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateOr()">
<span class="spec-call"><a href="#EvaluateOr()" data-name="EvaluateOr">EvaluateOr</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="left">left</var> or <var data-name="right">right</var> is <span class="spec-keyword">true</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>If <var data-name="left">left</var> or <var data-name="right">right</var> is not a boolean:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</div>
</section>
<section id="sec-Not-operator" secid="8.3">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Not-operator">8.3</a></span>Not operator</h3>
<div class="spec-production" id="Not">
<span class="spec-nt"><a href="#Not" data-name="Not">Not</a></span><div class="spec-rhs"><span class="spec-t">!</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateNot()">
<span class="spec-call"><a href="#EvaluateNot()" data-name="EvaluateNot">EvaluateNot</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="valueNode">valueNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="value">value</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="valueNode">valueNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="value">value</var> is <span class="spec-keyword">false</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>If <var data-name="value">value</var> is <span class="spec-keyword">true</span>:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Equality-operators" secid="8.4">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Equality-operators">8.4</a></span>Equality operators</h3>
<div class="spec-production" id="Equality">
<span class="spec-nt"><a href="#Equality" data-name="Equality">Equality</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-nt"><a href="#EqualityOperator" data-name="EqualityOperator">EqualityOperator</a></span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-production" id="EqualityOperator">
<span class="spec-nt"><a href="#EqualityOperator" data-name="EqualityOperator">EqualityOperator</a></span><div class="spec-oneof"><table>
<tr>
<td class="spec-rhs"><span class="spec-t">==</span></td><td class="spec-rhs"><span class="spec-t">,</span></td><td class="spec-rhs"><span class="spec-t">!=</span></td></tr>
</table></div>
</div>
<div class="spec-algo" id="EvaluateEquality()">
<span class="spec-call"><a href="#EvaluateEquality()" data-name="EvaluateEquality">EvaluateEquality</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="result">result</var> be the result of <span class="spec-call"><a href="#Equal()" data-name="Equal">Equal</a>(<var data-name="left">left</var>, <var data-name="right">right</var>)</span>.</li>
<li>If the operator is <code>!=</code>:<ol>
<li>If <var data-name="result">result</var> is <span class="spec-keyword">true</span>:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>If <var data-name="result">result</var> is <span class="spec-keyword">false</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
</section>
<section id="sec-Comparison-operators" secid="8.5">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Comparison-operators">8.5</a></span>Comparison operators</h3>
<div class="spec-production" id="Comparison">
<span class="spec-nt"><a href="#Comparison" data-name="Comparison">Comparison</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-nt"><a href="#ComparisonOperator" data-name="ComparisonOperator">ComparisonOperator</a></span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-production" id="ComparisonOperator">
<span class="spec-nt"><a href="#ComparisonOperator" data-name="ComparisonOperator">ComparisonOperator</a></span><div class="spec-oneof"><table>
<tr>
<td class="spec-rhs"><span class="spec-t">&lt;</span></td><td class="spec-rhs"><span class="spec-t">,</span></td><td class="spec-rhs"><span class="spec-t">&lt;=</span></td><td class="spec-rhs"><span class="spec-t">,</span></td><td class="spec-rhs"><span class="spec-t">&gt;</span></td><td class="spec-rhs"><span class="spec-t">,</span></td><td class="spec-rhs"><span class="spec-t">&gt;=</span></td></tr>
</table></div>
</div>
<div class="spec-algo" id="EvaluateComparison()">
<span class="spec-call"><a href="#EvaluateComparison()" data-name="EvaluateComparison">EvaluateComparison</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="cmp">cmp</var> be the result of <span class="spec-call"><a href="#PartialCompare()" data-name="PartialCompare">PartialCompare</a>(<var data-name="left">left</var>, <var data-name="right">right</var>)</span>.</li>
<li>If <var data-name="cmp">cmp</var> is <span class="spec-keyword">null</span>:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>If <var data-name="cmp">cmp</var> is <span class="spec-nt"><span data-name="Less">Less</span></span> and the operator is <span class="spec-t">&lt;</span> or <span class="spec-t">&lt;=</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>If <var data-name="cmp">cmp</var> is <span class="spec-nt"><span data-name="Greater">Greater</span></span> and the operator is <span class="spec-t">&gt;</span> or <span class="spec-t">&gt;=</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>If <var data-name="cmp">cmp</var> is <span class="spec-nt"><span data-name="Equal">Equal</span></span> and the operator is <span class="spec-t">&lt;=</span> or <span class="spec-t">&gt;=</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</div>
</section>
<section id="sec-In-operator" secid="8.6">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-In-operator">8.6</a></span>In operator</h3>
<div class="spec-production" id="In">
<span class="spec-nt"><a href="#In" data-name="In">In</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">in</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateIn()">
<span class="spec-call"><a href="#EvaluateIn()" data-name="EvaluateIn">EvaluateIn</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="right">right</var> is an array:<ol>
<li>For each <var data-name="value">value</var> in <var data-name="right">right</var>:<ol>
<li>If <span class="spec-call"><a href="#Equal()" data-name="Equal">Equal</a>(<var data-name="left">left</var>, <var data-name="value">value</var>)</span> is <span class="spec-keyword">true</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>If <var data-name="right">right</var> is a range:<ol>
<li>Let <var data-name="lower">lower</var> be the start value of <var data-name="right">right</var>.</li>
<li>Let <var data-name="upper">upper</var> be the end value of <var data-name="right">right</var>.</li>
<li>Let <var data-name="leftCmp">leftCmp</var> be the result of <span class="spec-call"><a href="#PartialCompare()" data-name="PartialCompare">PartialCompare</a>(<var data-name="left">left</var>, <var data-name="lower">lower</var>)</span>.</li>
<li>Let <var data-name="rightCmp">rightCmp</var> be the result of <span class="spec-call"><a href="#PartialCompare()" data-name="PartialCompare">PartialCompare</a>(<var data-name="left">left</var>, <var data-name="upper">upper</var>)</span>.</li>
<li>If <var data-name="leftCmp">leftCmp</var> or <var data-name="rightCmp">rightCmp</var> is <span class="spec-keyword">null</span>:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>If <var data-name="leftCmp">leftCmp</var> is <span class="spec-nt"><span data-name="Less">Less</span></span>:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>If <var data-name="rightCmp">rightCmp</var> is <span class="spec-nt"><span data-name="Greater">Greater</span></span>:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>If the <var data-name="right">right</var> range is exclusive and <var data-name="rightCmp">rightCmp</var> is <span class="spec-nt"><span data-name="Equal">Equal</span></span>:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Match-operator" secid="8.7">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Match-operator">8.7</a></span>Match operator</h3>
<p>The match operator is defined in terms of <em>patterns</em> and <em>tokens</em>: It returns true when any of patterns matches all of the tokens. The exact way of tokenizing text and interpreting patterns is left as an implementation detail.</p>
<div class="spec-production" id="Match">
<span class="spec-nt"><a href="#Match" data-name="Match">Match</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">match</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateMatch()">
<span class="spec-call"><a href="#EvaluateMatch()" data-name="EvaluateMatch">EvaluateMatch</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="tokens">tokens</var> be an empty array.</li>
<li>If <var data-name="left">left</var> is a string:<ol>
<li>Concatenate <span class="spec-call"><a href="#MatchTokenize()" data-name="MatchTokenize">MatchTokenize</a>(<var data-name="left">left</var>)</span> to <var data-name="tokens">tokens</var>.</li>
</ol>
</li>
<li>If <var data-name="left">left</var> is an array:<ol>
<li>For each <var data-name="value">value</var> in <var data-name="left">left</var>:<ol>
<li>If <var data-name="value">value</var> is a string:<ol>
<li>Concatenate <span class="spec-call"><a href="#MatchTokenize()" data-name="MatchTokenize">MatchTokenize</a>(<var data-name="value">value</var>)</span> to <var data-name="tokens">tokens</var>.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>Let <var data-name="patterns">patterns</var> be an empty array. </li>
<li>If <var data-name="right">right</var> is a string:<ol>
<li>Append <span class="spec-call"><a href="#MatchAnalyzePattern()" data-name="MatchAnalyzePattern">MatchAnalyzePattern</a>(<var data-name="right">right</var>)</span> to <var data-name="patterns">patterns</var>.</li>
</ol>
</li>
<li>If <var data-name="right">right</var> is an array:<ol>
<li>For each <var data-name="value">value</var> in <var data-name="right">right</var>:<ol>
<li>If <var data-name="value">value</var> is a string:<ol>
<li>Append <span class="spec-call"><a href="#MatchAnalyzePattern()" data-name="MatchAnalyzePattern">MatchAnalyzePattern</a>(<var data-name="value">value</var>)</span> to <var data-name="patterns">patterns</var>.</li>
</ol>
</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
</ol>
</li>
<li>If <var data-name="patterns">patterns</var> is empty:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>For each <var data-name="pattern">pattern</var> in <var data-name="patterns">patterns</var>:<ol>
<li>If <var data-name="pattern">pattern</var> does not matches <var data-name="tokens">tokens</var>:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</div>
<div class="spec-algo" id="MatchTokenize()">
<span class="spec-call"><a href="#MatchTokenize()" data-name="MatchTokenize">MatchTokenize</a>(<var data-name="value">value</var>)</span><ol>
<li>Return an array of tokens. </li>
</ol>
</div>
<div class="spec-algo" id="MatchAnalyzePattern()">
<span class="spec-call"><a href="#MatchAnalyzePattern()" data-name="MatchAnalyzePattern">MatchAnalyzePattern</a>(<var data-name="value">value</var>)</span><ol>
<li>Return a pattern for the given string.</li>
</ol>
</div>
</section>
<section id="sec-Asc-operator" secid="8.8">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Asc-operator">8.8</a></span>Asc operator</h3>
<p>The asc operator is used by the <span class="spec-call"><a href="#order()" data-name="order">order</a>()</span> function to signal that you want ascending sorting. Evaluating it in any other context is not allowed.</p>
<div class="spec-production" id="Asc">
<span class="spec-nt"><a href="#Asc" data-name="Asc">Asc</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">asc</span></div>
</div>
<div class="spec-algo" id="ValidateAsc()">
<span class="spec-call"><a href="#ValidateAsc()" data-name="ValidateAsc">ValidateAsc</a>()</span><ol>
<li>Report an error.</li>
</ol>
</div>
</section>
<section id="sec-Desc-operator" secid="8.9">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Desc-operator">8.9</a></span>Desc operator</h3>
<p>The desc operator is used by the <span class="spec-call"><a href="#order()" data-name="order">order</a>()</span> function to signal that you want descending sorting. Evaluating it in any other context is not allowed.</p>
<div class="spec-production" id="Desc">
<span class="spec-nt"><a href="#Desc" data-name="Desc">Desc</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">desc</span></div>
</div>
<div class="spec-algo" id="ValidateDesc()">
<span class="spec-call"><a href="#ValidateDesc()" data-name="ValidateDesc">ValidateDesc</a>()</span><ol>
<li>Report an error.</li>
</ol>
</div>
</section>
<section id="sec-Unary-plus-operator" secid="8.10">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Unary-plus-operator">8.10</a></span>Unary plus operator</h3>
<div class="spec-production" id="UnaryPlus">
<span class="spec-nt"><a href="#UnaryPlus" data-name="UnaryPlus">UnaryPlus</a></span><div class="spec-rhs"><span class="spec-t">+</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateUnaryPlus()">
<span class="spec-call"><a href="#EvaluateUnaryPlus()" data-name="EvaluateUnaryPlus">EvaluateUnaryPlus</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="valueNode">valueNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="value">value</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="valueNode">valueNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="value">value</var> is a number:<ol>
<li>Return <var data-name="value">value</var>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Unary-minus-operator" secid="8.11">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Unary-minus-operator">8.11</a></span>Unary minus operator</h3>
<div class="spec-production" id="UnaryMinus">
<span class="spec-nt"><a href="#UnaryMinus" data-name="UnaryMinus">UnaryMinus</a></span><div class="spec-rhs"><span class="spec-t">-</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateUnaryMinus()">
<span class="spec-call"><a href="#EvaluateUnaryMinus()" data-name="EvaluateUnaryMinus">EvaluateUnaryMinus</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="valueNode">valueNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="value">value</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="valueNode">valueNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="value">value</var> is a number:<ol>
<li>Return <var data-name="value">value</var> with opposite sign.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Binary-plus-operator" secid="8.12">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Binary-plus-operator">8.12</a></span>Binary plus operator</h3>
<div class="spec-production" id="Plus">
<span class="spec-nt"><a href="#Plus" data-name="Plus">Plus</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">+</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluatePlus()">
<span class="spec-call"><a href="#EvaluatePlus()" data-name="EvaluatePlus">EvaluatePlus</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are strings:<ol>
<li>Return the string concatenation of <var data-name="left">left</var> and <var data-name="right">right</var>.</li>
</ol>
</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are numbers:<ol>
<li>Return the addition of <var data-name="left">left</var> and <var data-name="right">right</var>.</li>
</ol>
</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are arrays:<ol>
<li>Return the concatenation of <var data-name="left">left</var> and <var data-name="right">right</var>.</li>
</ol>
</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are objects:<ol>
<li>Return the merged object of <var data-name="left">left</var> and <var data-name="right">right</var>. For duplicate fields the value from <var data-name="right">right</var> takes precedence.</li>
</ol>
</li>
<li>If <var data-name="left">left</var> is a datetime and <var data-name="right">right</var> is a number:<ol>
<li>Return a new datetime that adds (or subtracts, if negative) <var data-name="right">right</var> as a number of seconds to <var data-name="left">left</var>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Binary-minus-operator" secid="8.13">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Binary-minus-operator">8.13</a></span>Binary minus operator</h3>
<div class="spec-production" id="Minus">
<span class="spec-nt"><a href="#Minus" data-name="Minus">Minus</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">-</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateMinus()">
<span class="spec-call"><a href="#EvaluateMinus()" data-name="EvaluateMinus">EvaluateMinus</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are numbers:<ol>
<li>Return the subtraction of <var data-name="left">left</var> from <var data-name="right">right</var>.</li>
</ol>
</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are datetimes:<ol>
<li>Return the difference, in seconds, between <var data-name="left">left</var> from <var data-name="right">right</var>.</li>
</ol>
</li>
<li>If <var data-name="left">left</var> is a datetime and <var data-name="right">right</var> is a number:<ol>
<li>Return a new datetime being <var data-name="left">left</var> minus <var data-name="right">right</var> as seconds.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Binary-star-operator" secid="8.14">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Binary-star-operator">8.14</a></span>Binary star operator</h3>
<div class="spec-production" id="Star">
<span class="spec-nt"><a href="#Star" data-name="Star">Star</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">*</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateStar()">
<span class="spec-call"><a href="#EvaluateStar()" data-name="EvaluateStar">EvaluateStar</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are numbers:<ol>
<li>Return the multiplication of <var data-name="left">left</var> and <var data-name="right">right</var>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Binary-slash-operator" secid="8.15">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Binary-slash-operator">8.15</a></span>Binary slash operator</h3>
<div class="spec-production" id="Slash">
<span class="spec-nt"><a href="#Slash" data-name="Slash">Slash</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">/</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateSlash()">
<span class="spec-call"><a href="#EvaluateSlash()" data-name="EvaluateSlash">EvaluateSlash</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are numbers:<ol>
<li>Return the division of <var data-name="left">left</var> by <var data-name="right">right</var>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Binary-percent-operator" secid="8.16">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Binary-percent-operator">8.16</a></span>Binary percent operator</h3>
<div class="spec-production" id="Percent">
<span class="spec-nt"><a href="#Percent" data-name="Percent">Percent</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">%</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluatePercent()">
<span class="spec-call"><a href="#EvaluatePercent()" data-name="EvaluatePercent">EvaluatePercent</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If both <var data-name="left">left</var> and <var data-name="right">right</var> are numbers:<ol>
<li>Return the remainder of <var data-name="left">left</var> after division by <var data-name="right">right</var>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Binary-double-star-operator" secid="8.17">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Binary-double-star-operator">8.17</a></span>Binary double star operator</h3>
<div class="spec-production" id="StarStar">
<span class="spec-nt"><a href="#StarStar" data-name="StarStar">StarStar</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">**</span><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span></div>
</div>
<div class="spec-algo" id="EvaluateStarStar()">
<span class="spec-call"><a href="#EvaluateStarStar()" data-name="EvaluateStarStar">EvaluateStarStar</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="leftNode">leftNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="left">left</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="leftNode">leftNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightNode">rightNode</var> be the last <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="right">right</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="rightNode">rightNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If both <var data-name="left">left</var> and right are numbers:<ol>
<li>Return the exponentiation of <var data-name="left">left</var> to the power of <var data-name="right">right</var>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-Dereference-operator" secid="8.18">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-Dereference-operator">8.18</a></span>Dereference operator</h3>
<div class="spec-production" id="Dereference">
<span class="spec-nt"><a href="#Dereference" data-name="Dereference">Dereference</a></span><div class="spec-rhs"><span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span><span class="spec-t">-&gt;</span><span class="spec-quantified"><span class="spec-nt"><a href="#String" data-name="String">String</a></span><span class="spec-quantifiers"><span class="spec-quantifier optional">opt</span></span></span></div>
</div>
<div class="spec-algo" id="EvaluateDereference()">
<span class="spec-call"><a href="#EvaluateDereference()" data-name="EvaluateDereference">EvaluateDereference</a>(<var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="valueNode">valueNode</var> be the <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span>.</li>
<li>Let <var data-name="value">value</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="valueNode">valueNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="value">value</var> is not an object:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>If <var data-name="value">value</var> does not have an attribute &ldquo;_ref&rdquo;:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>Let <var data-name="ref">ref</var> be the value of the attribute &ldquo;_ref&rdquo; in <var data-name="value">value</var>.</li>
<li>If <var data-name="ref">ref</var> is not a string:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>Let <var data-name="dataset">dataset</var> be the dataset of the query context of <var data-name="scope">scope</var>.</li>
<li>If <var data-name="dataset">dataset</var> is not an array:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>Let <var data-name="result">result</var> be <span class="spec-keyword">null</span>.</li>
<li>For each <var data-name="document">document</var> in <var data-name="dataset">dataset</var>:<ol>
<li>If <var data-name="document">document</var> is an object and has an attribute &ldquo;_id&rdquo;:<ol>
<li>Let <var data-name="id">id</var> be the value of the attribute &ldquo;_id&rdquo; in <var data-name="document">document</var>.</li>
</ol>
</li>
<li>If <span class="spec-call"><a href="#Equal()" data-name="Equal">Equal</a>(<var data-name="ref">ref</var>, <var data-name="id">id</var>)</span> is <span class="spec-keyword">true</span>:<ol>
<li>Set <var data-name="result">result</var> to <var data-name="document">document</var>.</li>
</ol>
</li>
<li>Stop the loop.</li>
</ol>
</li>
<li>If the dereference expression contains a <span class="spec-nt"><a href="#String" data-name="String">String</a></span>:<ol>
<li>Let <var data-name="name">name</var> be the string value of the <span class="spec-nt"><a href="#String" data-name="String">String</a></span>.</li>
<li>If <var data-name="result">result</var> is an object and contains an attribute <var data-name="name">name</var>:<ol>
<li>Return the <var data-name="value">value</var> of the attribute <var data-name="name">name</var> in <var data-name="result">result</var>.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <var data-name="result">result</var>.</li>
</ol>
</div>
</section>
</section>
<section id="sec-Precedence-and-associativity" secid="9">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Precedence-and-associativity">9</a></span>Precedence and associativity</h2>
<p>In this specification the various expressions and operators are defined in ambiguously in terms on precedence and associativity. The table below describes the precedence levels used to determine the correct unambiguous interpretation.</p>
<p>From highest to lowest:</p>
<ul>
<li>Level 11: <a href="#sec-Compound-expressions">Compound expressions</a>.</li>
<li>Level 10, prefix: <code>+</code>, <code>!</code>.</li>
<li>Level 9, right&#8208;assoative: <a href="#sec-Binary-double-star-operator"></a> <code>**</code>.</li>
<li>Level 8, prefix: <code>-</code>.</li>
<li>Level 7, left&#8208;associative: Multiplicatives (<code>*</code>, <code>/</code>, <code>%</code>).</li>
<li>Level 6, left&#8208;associative: Additives (<code>+</code>, <code>-</code>),</li>
<li>Level 5, non&#8208;associative: Ranges (<code>..</code>, <code>...</code>).</li>
<li>Level 4, non&#8208;associative: Comparisons (<code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>,<code>&lt;</code>, <code>&lt;=</code>, <code>in</code>, <code>match</code>).</li>
<li>Level 4, postfix: Ordering (<code>asc</code>, <code>desc</code>).</li>
<li>Level 3, left&#8208;associative: <code>&amp;&amp;</code>.</li>
<li>Level 2, left&#8208;associative: <code>||</code>.</li>
<li>Level 1, non&#8208;associative: <code>=&gt;</code>.</li>
</ul>
</section>
<section id="sec-Functions" secid="10">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Functions">10</a></span>Functions</h2>
<p>Functions provide additional functionalty to GROQ queries. They are invoked through a <a href="#sec-Function-call-expression">Function call expression</a>. Note that function arguments are not evaluated eagerly, and it&rsquo;s up to the function to decide which scope the arguments are evaluated it. As such, all functions below take an array of nodes.</p>
<p>An implementation may provide additional functions, but should be aware that this can cause problems when interopting with future versions of GROQ.</p>
<section id="sec-coalesce" secid="10.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-coalesce">10.1</a></span>coalesce</h3>
<p>The coalesce function returns the first value of the arguments which is not <span class="spec-keyword">null</span>.</p>
<div class="spec-algo" id="coalesce()">
<span class="spec-call"><a href="#coalesce()" data-name="coalesce">coalesce</a>(<var data-name="args">args</var>, <var data-name="scope">scope</var>)</span><ol>
<li>For each <var data-name="arg">arg</var> in <var data-name="args">args</var>:<ol>
<li>Let <var data-name="value">value</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="arg">arg</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="value">value</var> is not <span class="spec-keyword">null</span>:<ol>
<li>Return <var data-name="value">value</var>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
</section>
<section id="sec-count" secid="10.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-count">10.2</a></span>count</h3>
<p>The count function returns the length of an array.</p>
<div class="spec-algo" id="count()">
<span class="spec-call"><a href="#count()" data-name="count">count</a>(<var data-name="args">args</var>, <var data-name="scope">scope</var>)</span><ol>
<li>If the length of <var data-name="args">args</var> is not 1:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>Let <var data-name="baseNode">baseNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is an array:<ol>
<li>Return the length of <var data-name="base">base</var>.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
</ol>
</div>
<div class="spec-algo" id="countValidate()">
<span class="spec-call"><a href="#countValidate()" data-name="countValidate">countValidate</a>(<var data-name="args">args</var>)</span><ol>
<li>If the length of <var data-name="args">args</var> is not 1:<ol>
<li>Report an error.</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-dateTime" secid="10.3">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-dateTime">10.3</a></span>dateTime</h3>
<p>The <code>dateTime</code> function takes a string, returning a datetime value.</p>
<div class="spec-algo" id="dateTime()">
<span class="spec-call"><a href="#dateTime()" data-name="dateTime">dateTime</a>(<var data-name="args">args</var>, <var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="baseNode">baseNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is a string:<ol>
<li>Try to parse <var data-name="base">base</var> as a datetime using the <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> timestamp format.<ol>
<li>If the input is a valid datetime:<ol>
<li>Return the datetime.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
<div class="spec-algo" id="dateTimeValidate()">
<span class="spec-call"><a href="#dateTimeValidate()" data-name="dateTimeValidate">dateTimeValidate</a>(<var data-name="args">args</var>)</span><ol>
<li>If the length of <var data-name="args">args</var> is not 1:<ol>
<li>Report an error.</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-defined" secid="10.4">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-defined">10.4</a></span>defined</h3>
<p>The defined function checks if the argument is not <span class="spec-keyword">null</span>.</p>
<div class="spec-algo" id="defined()">
<span class="spec-call"><a href="#defined()" data-name="defined">defined</a>(<var data-name="args">args</var>, <var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="baseNode">baseNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is <span class="spec-keyword">null</span>:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
</ol>
</div>
<div class="spec-algo" id="definedValidate()">
<span class="spec-call"><a href="#definedValidate()" data-name="definedValidate">definedValidate</a>(<var data-name="args">args</var>)</span><ol>
<li>If the length of <var data-name="args">args</var> is not 1:<ol>
<li>Report an error.</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-length" secid="10.5">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-length">10.5</a></span>length</h3>
<p>The length function returns the length of a string or an array.</p>
<div class="spec-algo" id="length()">
<span class="spec-call"><a href="#length()" data-name="length">length</a>(<var data-name="args">args</var>, <var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="baseNode">baseNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="base">base</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="baseNode">baseNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="base">base</var> is a string:<ol>
<li>Return the length of <var data-name="base">base</var>.</li>
</ol>
</li>
<li>If <var data-name="base">base</var> is an array:<ol>
<li>Return the length of <var data-name="base">base</var>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</div>
<div class="spec-algo" id="lengthValidate()">
<span class="spec-call"><a href="#lengthValidate()" data-name="lengthValidate">lengthValidate</a>(<var data-name="args">args</var>)</span><ol>
<li>If the length of <var data-name="args">args</var> is not 1:<ol>
<li>Report an error.</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-references" secid="10.6">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-references">10.6</a></span>references</h3>
<p>The references function implicitly takes this value of the current scope and recursively checks whether it contains any references to the given document ID.</p>
<div class="spec-algo" id="references()">
<span class="spec-call"><a href="#references()" data-name="references">references</a>(<var data-name="args">args</var>, <var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="pathNode">pathNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="path">path</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="pathNode">pathNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="path">path</var> is not a string:<ol>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>Let <var data-name="base">base</var> be the this value of <var data-name="scope">scope</var>.</li>
<li>Return the result of <span class="spec-call"><a href="#HasReferenceTo()" data-name="HasReferenceTo">HasReferenceTo</a>(<var data-name="base">base</var>, <var data-name="path">path</var>)</span>.</li>
</ol>
</div>
<div class="spec-algo" id="HasReferenceTo()">
<span class="spec-call"><a href="#HasReferenceTo()" data-name="HasReferenceTo">HasReferenceTo</a>(<var data-name="base">base</var>, <var data-name="path">path</var>)</span><ol>
<li>If <var data-name="base">base</var> is an array:<ol>
<li>For each <var data-name="value">value</var> in <var data-name="base">base</var>:<ol>
<li>Let <var data-name="result">result</var> be the result of <span class="spec-call"><a href="#HasReferenceTo()" data-name="HasReferenceTo">HasReferenceTo</a>(<var data-name="value">value</var>, <var data-name="base">base</var>)</span>.</li>
</ol>
</li>
<li>If <var data-name="result">result</var> is <span class="spec-keyword">true</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</li>
<li>If <var data-name="base">base</var> is an object:<ol>
<li>If <var data-name="base">base</var> has an attribute &ldquo;_ref&rdquo;:<ol>
<li>Let <var data-name="ref">ref</var> be the value of the attribute &ldquo;_ref&rdquo; in <var data-name="base">base</var>.</li>
</ol>
</li>
<li>Return the result of <span class="spec-call"><a href="#Equal()" data-name="Equal">Equal</a>(<var data-name="ref">ref</var>, <var data-name="path">path</var>)</span>.</li>
<li>For each <var data-name="key">key</var> and <var data-name="value">value</var> in <var data-name="base">base</var>:<ol>
<li>Let <var data-name="result">result</var> be the result of <span class="spec-call"><a href="#HasReferenceTo()" data-name="HasReferenceTo">HasReferenceTo</a>(<var data-name="value">value</var>, <var data-name="base">base</var>)</span>.</li>
</ol>
</li>
<li>If <var data-name="result">result</var> is <span class="spec-keyword">true</span>:<ol>
<li>Return <span class="spec-keyword">true</span>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <span class="spec-keyword">false</span>.</li>
</ol>
</div>
<div class="spec-algo" id="referencesValidate()">
<span class="spec-call"><a href="#referencesValidate()" data-name="referencesValidate">referencesValidate</a>(<var data-name="args">args</var>)</span><ol>
<li>If the length of <var data-name="args">args</var> is not 1:<ol>
<li>Report an error.</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-round" secid="10.7">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-round">10.7</a></span>round</h3>
<p>The round function accepts a number and rounds it to a certain precision.</p>
<div class="spec-algo" id="round()">
<span class="spec-call"><a href="#round()" data-name="round">round</a>(<var data-name="args">args</var>, <var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="numNode">numNode</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="num">num</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="numNode">numNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="num">num</var> is not a number:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
<li>If the length of <var data-name="args">args</var> is 2:<ol>
<li>Let <var data-name="precNode">precNode</var> be the second element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="prec">prec</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="precNode">precNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="prec">prec</var> is not a number:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Let <var data-name="prec">prec</var> be 0.</li>
</ol>
</li>
<li>Return <var data-name="num">num</var> rounded to <var data-name="prec">prec</var> number of digits after the decimal point.</li>
</ol>
</div>
<div class="spec-algo" id="roundValidate()">
<span class="spec-call"><a href="#roundValidate()" data-name="roundValidate">roundValidate</a>(<var data-name="args">args</var>)</span><ol>
<li>If the length of <var data-name="args">args</var> is less than 1 or greater than 2:<ol>
<li>Report an error.</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-select" secid="10.8">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-select">10.8</a></span>select</h3>
<p>The select function chooses takes a variable number of arguments that are either pairs or any other type and iterates over them. When encountering a pair whose left&#8208;hand value evaluates to <span class="spec-keyword">true</span>, the right&#8208;hand value is returned immediately. When encountering a non&#8208;pair argument, that argument is returned immediately. Falls back to returning <span class="spec-keyword">null</span>.</p>
<div class="spec-algo" id="select()">
<span class="spec-call"><a href="#select()" data-name="select">select</a>(<var data-name="args">args</var>, <var data-name="scope">scope</var>)</span><ol>
<li>For each <var data-name="arg">arg</var> in <var data-name="args">args</var>:<ol>
<li>If <var data-name="arg">arg</var> is a <span class="spec-nt"><a href="#Pair" data-name="Pair">Pair</a></span>:<ol>
<li>Let <var data-name="condNode">condNode</var> be the first <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> of the <span class="spec-nt"><a href="#Pair" data-name="Pair">Pair</a></span>.</li>
</ol>
</li>
<li>Let <var data-name="resultNode">resultNode</var> be the second <span class="spec-nt"><a href="#Expression" data-name="Expression">Expression</a></span> of the <span class="spec-nt"><a href="#Pair" data-name="Pair">Pair</a></span>.<ol>
<li>Let <var data-name="cond">cond</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="condNode">condNode</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="cond">cond</var> is <span class="spec-keyword">true</span>:<ol>
<li>Return the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="resultNode">resultNode</var>, <var data-name="scope">scope</var>)</span>.</li>
</ol>
</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Return the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="arg">arg</var>, <var data-name="scope">scope</var>)</span>.</li>
</ol>
</li>
</ol>
</li>
</ol>
</div>
<div class="spec-algo" id="selectValidate()">
<span class="spec-call"><a href="#selectValidate()" data-name="selectValidate">selectValidate</a>(<var data-name="args">args</var>)</span><ol>
<li>Let <var data-name="seenDefault">seenDefault</var> be <span class="spec-keyword">false</span>.</li>
<li>For each <var data-name="arg">arg</var> in <var data-name="args">args</var>:<ol>
<li>If <var data-name="seenDefault">seenDefault</var> is <span class="spec-keyword">true</span>:<ol>
<li>Report an error.</li>
</ol>
</li>
<li>If <var data-name="arg">arg</var> is not a <span class="spec-nt"><a href="#Pair" data-name="Pair">Pair</a></span>:<ol>
<li>Set <var data-name="seenDefault">seenDefault</var> to <span class="spec-keyword">true</span>.</li>
</ol>
</li>
</ol>
</li>
</ol>
</div>
</section>
<section id="sec-string" secid="10.9">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-string">10.9</a></span>string</h3>
<p>The string function returns the string representation of scalar values or <span class="spec-keyword">null</span> for any other values.</p>
<div class="spec-algo" id="string()">
<span class="spec-call"><a href="#string()" data-name="string">string</a>(<var data-name="args">args</var>, <var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="node">node</var> be the first element of <var data-name="args">args</var>.</li>
<li>Let <var data-name="val">val</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="node">node</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>If <var data-name="val">val</var> is <span class="spec-keyword">true</span>:<ol>
<li>Return the string <code>&quot;true&quot;</code></li>
</ol>
</li>
<li>If <var data-name="val">val</var> is <span class="spec-keyword">false</span>:<ol>
<li>Return the string <code>&quot;false&quot;</code></li>
</ol>
</li>
<li>If <var data-name="val">val</var> is <span class="spec-keyword">null</span>:<ol>
<li>Return the string <code>&quot;null&quot;</code></li>
</ol>
</li>
<li>If <var data-name="val">val</var> is a string:<ol>
<li>Return <var data-name="val">val</var>.</li>
</ol>
</li>
<li>If <var data-name="val">val</var> is a number:<ol>
<li>Return a string representation of the number.</li>
</ol>
</li>
<li>Otherwise:<ol>
<li>Return <span class="spec-keyword">null</span>.</li>
</ol>
</li>
</ol>
</div>
<div class="spec-algo" id="stringValidate()">
<span class="spec-call"><a href="#stringValidate()" data-name="stringValidate">stringValidate</a>(<var data-name="args">args</var>)</span><ol>
<li>If the length of <var data-name="args">args</var> is not 1:<ol>
<li>Report an error.</li>
</ol>
</li>
</ol>
</div>
</section>
</section>
<section id="sec-Pipe-functions" secid="11">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Pipe-functions">11</a></span>Pipe functions</h2>
<p>Pipe functions provide additional functionalty to GROQ queries. They are invoked through a <a href="#sec-Pipe-function-call-expression">Pipe function call expression</a>. They differ from regular functions in that they always accept an array as input and returns another array (or <span class="spec-keyword">null</span>). As such, the syntax is optimized for chaining (the array it works on comes on the left&#8208;hand side instead of being an argument):</p>
<pre><code>*[_type == &quot;person&quot;] | order(name) | {age}
</code></pre>
<div id="note-88a44" class="spec-note">
<a href="#note-88a44">Note</a>
that function arguments are not evaluated eagerly, and it&rsquo;s up to the function to decide which scope the arguments are evaluated in. All definitions below take an array of nodes.</div>
<p>An implementation may provide additional pipe functions, but should be aware that this can cause problems when interopting with future versions of GROQ.</p>
<section id="sec-order" secid="11.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-order">11.1</a></span>order</h3>
<p>The order function sorts an array based on arbitrary expressions.</p>
<div class="spec-algo" id="order()">
<span class="spec-call"><a href="#order()" data-name="order">order</a>(<var data-name="base">base</var>, <var data-name="args">args</var>, <var data-name="scope">scope</var>)</span><ol>
<li>Let <var data-name="cmp">cmp</var> be a function which takes two arguments and returns either <span class="spec-nt"><span data-name="Less">Less</span></span>, <span class="spec-nt"><span data-name="Equal">Equal</span></span> or <span class="spec-nt"><span data-name="Greater">Greater</span></span>.</li>
<li>Define <span class="spec-call"><span data-name="cmp">cmp</span>(<var data-name="left">left</var>, <var data-name="right">right</var>)</span> as follows:<ol>
<li>Let <var data-name="leftScope">leftScope</var> be the result of <span class="spec-call"><a href="#NewNestedScope()" data-name="NewNestedScope">NewNestedScope</a>(<var data-name="left">left</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>Let <var data-name="rightScope">rightScope</var> be the result of <span class="spec-call"><a href="#NewNestedScope()" data-name="NewNestedScope">NewNestedScope</a>(<var data-name="right">right</var>, <var data-name="scope">scope</var>)</span>.</li>
<li>For each <var data-name="argNode">argNode</var> of <var data-name="args">args</var>:<ol>
<li>Let <var data-name="direction">direction</var> be <span class="spec-nt"><span data-name="Normal">Normal</span></span>.</li>
</ol>
</li>
<li>Let <var data-name="valueNode">valueNode</var> be <var data-name="argNode">argNode</var>.<ol>
<li>If <var data-name="valueNode">valueNode</var> is an <span class="spec-nt"><a href="#Asc" data-name="Asc">Asc</a></span> operator:<ol>
<li>Set <var data-name="valueNode">valueNode</var> to be the Expression of the <span class="spec-nt"><a href="#Asc" data-name="Asc">Asc</a></span> operator.</li>
</ol>
</li>
<li>Else if <var data-name="valueNode">valueNode</var> is a <span class="spec-nt"><a href="#Desc" data-name="Desc">Desc</a></span> operator:<ol>
<li>Set direction to <span class="spec-nt"><span data-name="Reverse">Reverse</span></span>.</li>
</ol>
</li>
<li>Set <var data-name="valueNode">valueNode</var> to be the Expression of the <span class="spec-nt"><a href="#Desc" data-name="Desc">Desc</a></span> operator.</li>
<li>Let <var data-name="leftValue">leftValue</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="valueNode">valueNode</var>, <var data-name="leftScope">leftScope</var>)</span>.</li>
<li>Let <var data-name="rightValue">rightValue</var> be the result of <span class="spec-call"><a href="#Evaluate()" data-name="Evaluate">Evaluate</a>(<var data-name="valueNode">valueNode</var>, <var data-name="rightScope">rightScope</var>)</span>.</li>
<li>Let <var data-name="order">order</var> be the result of <span class="spec-call"><a href="#TotalCompare()" data-name="TotalCompare">TotalCompare</a>(<var data-name="leftValue">leftValue</var>, <var data-name="rightValue">rightValue</var>)</span>.</li>
<li>If <var data-name="direction">direction</var> is <span class="spec-nt"><span data-name="Reverse">Reverse</span></span> and <var data-name="order">order</var> is <span class="spec-nt"><span data-name="Less">Less</span></span>:<ol>
<li>Set <var data-name="order">order</var> to <span class="spec-nt"><span data-name="Greater">Greater</span></span>.</li>
</ol>
</li>
<li>Else if <var data-name="direction">direction</var> is <span class="spec-nt"><span data-name="Reverse">Reverse</span></span> and <var data-name="order">order</var> is <span class="spec-nt"><span data-name="Greater">Greater</span></span>:<ol>
<li>Set <var data-name="order">order</var> to <span class="spec-nt"><span data-name="Less">Less</span></span>.</li>
</ol>
</li>
<li>If <var data-name="order">order</var> is not <span class="spec-nt"><span data-name="Equal">Equal</span></span>:<ol>
<li>Return <var data-name="order">order</var>.</li>
</ol>
</li>
</ol>
</li>
<li>Return <span class="spec-nt"><span data-name="Equal">Equal</span></span>.</li>
</ol>
</li>
<li>Return a sorted array using <var data-name="cmp">cmp</var> as the comparator function.</li>
</ol>
</div>
<div class="spec-algo" id="orderValidate()">
<span class="spec-call"><a href="#orderValidate()" data-name="orderValidate">orderValidate</a>(<var data-name="args">args</var>)</span><ol>
<li>If the length of <var data-name="args">args</var> is 0:<ol>
<li>Report an error.</li>
</ol>
</li>
</ol>
</div>
</section>
</section>
<section id="sec-Vendor-functions" secid="12">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-Vendor-functions">12</a></span>Vendor functions</h2>
<p>An implementation is free to introduce additional functions than what is presented in this specification, but this is problematic if a function with the same name is introduced in a future version. The following section defines optional <em>vendor functions</em> which are guaranteed to never be a regular function in a future specfication. There&rsquo;s also a short description of each vendor function so different implementations can attempt to be compatible with each other. The description is intentially brief and it&rsquo;s up to the vendor to define it completely.</p>
<section id="sec-identity-" secid="12.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-identity-">12.1</a></span>identity()</h3>
<p>The identity function should accept zero arguments and return a string which represents the identity of the client executing the query.</p>
</section>
</section>
<section id="index" secid="index" class="spec-index"><h1><span class="spec-secid" title="link to the index"><a href="#index">Â§</a></span>Index</h1><ol><li><a href="#And">And</a></li><li><a href="#Array">Array</a></li><li><a href="#ArrayElement">ArrayElement</a></li><li><a href="#ArrayElements">ArrayElements</a></li><li><a href="#Asc">Asc</a></li><li><a href="#AttributeAccess">AttributeAccess</a></li><li><a href="#Boolean">Boolean</a></li><li><a href="#Comment">Comment</a></li><li><a href="#CommentChar">CommentChar</a></li><li><a href="#Comparison">Comparison</a></li><li><a href="#ComparisonOperator">ComparisonOperator</a></li><li><a href="#CompoundExpression">CompoundExpression</a></li><li><a href="#Decimal">Decimal</a></li><li><a href="#Dereference">Dereference</a></li><li><a href="#Desc">Desc</a></li><li><a href="#DetermineName()">DetermineName</a></li><li><a href="#Digit">Digit</a></li><li><a href="#DoubleStringCharacter">DoubleStringCharacter</a></li><li><a href="#ElementAccess">ElementAccess</a></li><li><a href="#Equal()">Equal</a></li><li><a href="#Equality">Equality</a></li><li><a href="#EqualityOperator">EqualityOperator</a></li><li><a href="#EscapeSequence">EscapeSequence</a></li><li><a href="#Evaluate()">Evaluate</a></li><li><a href="#EvaluateAnd()">EvaluateAnd</a></li><li><a href="#EvaluateArray()">EvaluateArray</a></li><li><a href="#EvaluateAttributeAccess()">EvaluateAttributeAccess</a></li><li><a href="#EvaluateComparison()">EvaluateComparison</a></li><li><a href="#EvaluateDereference()">EvaluateDereference</a></li><li><a href="#EvaluateElementAccess()">EvaluateElementAccess</a></li><li><a href="#EvaluateEquality()">EvaluateEquality</a></li><li><a href="#EvaluateEverything()">EvaluateEverything</a></li><li><a href="#EvaluateFilter()">EvaluateFilter</a></li><li><a href="#EvaluateFuncCall()">EvaluateFuncCall</a></li><li><a href="#EvaluateIn()">EvaluateIn</a></li><li><a href="#EvaluateMatch()">EvaluateMatch</a></li><li><a href="#EvaluateMinus()">EvaluateMinus</a></li><li><a href="#EvaluateNot()">EvaluateNot</a></li><li><a href="#EvaluateObject()">EvaluateObject</a></li><li><a href="#EvaluateOr()">EvaluateOr</a></li><li><a href="#EvaluatePair()">EvaluatePair</a></li><li><a href="#EvaluateParent()">EvaluateParent</a></li><li><a href="#EvaluateParenthesis()">EvaluateParenthesis</a></li><li><a href="#EvaluatePercent()">EvaluatePercent</a></li><li><a href="#EvaluatePipeFuncCall()">EvaluatePipeFuncCall</a></li><li><a href="#EvaluatePlus()">EvaluatePlus</a></li><li><a href="#EvaluateProjection()">EvaluateProjection</a></li><li><a href="#EvaluateRange()">EvaluateRange</a></li><li><a href="#EvaluateSlash()">EvaluateSlash</a></li><li><a href="#EvaluateSlice()">EvaluateSlice</a></li><li><a href="#EvaluateStar()">EvaluateStar</a></li><li><a href="#EvaluateStarStar()">EvaluateStarStar</a></li><li><a href="#EvaluateThis()">EvaluateThis</a></li><li><a href="#EvaluateThisAttribute()">EvaluateThisAttribute</a></li><li><a href="#EvaluateUnaryMinus()">EvaluateUnaryMinus</a></li><li><a href="#EvaluateUnaryPlus()">EvaluateUnaryPlus</a></li><li><a href="#Everything">Everything</a></li><li><a href="#ExclusiveRange">ExclusiveRange</a></li><li><a href="#ExecuteQuery()">ExecuteQuery</a></li><li><a href="#ExponentMarker">ExponentMarker</a></li><li><a href="#Expression">Expression</a></li><li><a href="#Filter">Filter</a></li><li><a href="#Fractional">Fractional</a></li><li><a href="#FuncCall">FuncCall</a></li><li><a href="#FuncCallArgs">FuncCallArgs</a></li><li><a href="#HasReferenceTo()">HasReferenceTo</a></li><li><a href="#HexDigit">HexDigit</a></li><li><a href="#HexLetter">HexLetter</a></li><li><a href="#Identifier">Identifier</a></li><li><a href="#In">In</a></li><li><a href="#InclusiveRange">InclusiveRange</a></li><li><a href="#Integer">Integer</a></li><li><a href="#Literal">Literal</a></li><li><a href="#Match">Match</a></li><li><a href="#MatchAnalyzePattern()">MatchAnalyzePattern</a></li><li><a href="#MatchTokenize()">MatchTokenize</a></li><li><a href="#Minus">Minus</a></li><li><a href="#NewNestedScope()">NewNestedScope</a></li><li><a href="#NewRootScope()">NewRootScope</a></li><li><a href="#Not">Not</a></li><li><a href="#Null">Null</a></li><li><a href="#Number">Number</a></li><li><a href="#Object">Object</a></li><li><a href="#ObjectAttribute">ObjectAttribute</a></li><li><a href="#ObjectAttributes">ObjectAttributes</a></li><li><a href="#OperatorCall">OperatorCall</a></li><li><a href="#Or">Or</a></li><li><a href="#Pair">Pair</a></li><li><a href="#Parent">Parent</a></li><li><a href="#Parenthesis">Parenthesis</a></li><li><a href="#PartialCompare()">PartialCompare</a></li><li><a href="#Percent">Percent</a></li><li><a href="#PipeFuncCall">PipeFuncCall</a></li><li><a href="#Plus">Plus</a></li><li><a href="#Projection">Projection</a></li><li><a href="#Range">Range</a></li><li><a href="#ScientificNotation">ScientificNotation</a></li><li><a href="#Sign">Sign</a></li><li><a href="#SimpleExpression">SimpleExpression</a></li><li><a href="#SingleEscapeSequence">SingleEscapeSequence</a></li><li><a href="#SingleStringCharacter">SingleStringCharacter</a></li><li><a href="#Slash">Slash</a></li><li><a href="#Slice">Slice</a></li><li><a href="#SourceCharacter">SourceCharacter</a></li><li><a href="#Star">Star</a></li><li><a href="#StarStar">StarStar</a></li><li><a href="#String">String</a></li><li><a href="#This">This</a></li><li><a href="#ThisAttribute">ThisAttribute</a></li><li><a href="#TotalCompare()">TotalCompare</a></li><li><a href="#TypeOrder()">TypeOrder</a></li><li><a href="#UnaryMinus">UnaryMinus</a></li><li><a href="#UnaryPlus">UnaryPlus</a></li><li><a href="#UnicodeEscapeSequence">UnicodeEscapeSequence</a></li><li><a href="#Validate()">Validate</a></li><li><a href="#ValidateAsc()">ValidateAsc</a></li><li><a href="#ValidateDesc()">ValidateDesc</a></li><li><a href="#ValidateFuncCall()">ValidateFuncCall</a></li><li><a href="#ValidateObject()">ValidateObject</a></li><li><a href="#ValidateObjectAttribute()">ValidateObjectAttribute</a></li><li><a href="#ValidatePipeFuncCall()">ValidatePipeFuncCall</a></li><li><a href="#WhiteSpace">WhiteSpace</a></li><li><a href="#coalesce()">coalesce</a></li><li><a href="#count()">count</a></li><li><a href="#countValidate()">countValidate</a></li><li><a href="#dateTime()">dateTime</a></li><li><a href="#dateTimeValidate()">dateTimeValidate</a></li><li><a href="#defined()">defined</a></li><li><a href="#definedValidate()">definedValidate</a></li><li><a href="#length()">length</a></li><li><a href="#lengthValidate()">lengthValidate</a></li><li><a href="#order()">order</a></li><li><a href="#orderValidate()">orderValidate</a></li><li><a href="#references()">references</a></li><li><a href="#referencesValidate()">referencesValidate</a></li><li><a href="#round()">round</a></li><li><a href="#roundValidate()">roundValidate</a></li><li><a href="#select()">select</a></li><li><a href="#selectValidate()">selectValidate</a></li><li><a href="#string()">string</a></li><li><a href="#stringValidate()">stringValidate</a></li></ol></section></article>
<footer>
Written in <a href="https://spec-md.com" target="_blank">Spec Markdown</a>.</footer>
<input hidden class="spec-sidebar-toggle" type="checkbox" id="spec-sidebar-toggle" aria-hidden /><label for="spec-sidebar-toggle" aria-hidden>&#x2630;</label>
<div class="spec-sidebar" aria-hidden>
<div class="spec-toc">
<div class="title"><a href="#">GROQ</a></div>
<ol><li id="_sidebar_1"><a href="#sec-undefined.Overview"><span class="spec-secid">1</span>Overview</a></li>
<li id="_sidebar_2"><a href="#sec-Syntax"><span class="spec-secid">2</span>Syntax</a>
<input hidden class="toggle" type="checkbox" id="_sidebar_toggle_2" /><label for="_sidebar_toggle_2"></label>
<ol>
<li id="_sidebar_2.1"><a href="#sec-JSON-Superset"><span class="spec-secid">2.1</span>JSON Superset</a></li>
<li id="_sidebar_2.2"><a href="#sec-White-Space"><span class="spec-secid">2.2</span>White Space</a></li>
<li id="_sidebar_2.3"><a href="#sec-Comments"><span class="spec-secid">2.3</span>Comments</a></li>
<li id="_sidebar_2.4"><a href="#sec-Identifier"><span class="spec-secid">2.4</span>Identifier</a></li>
<li id="_sidebar_2.5"><a href="#sec-Digits"><span class="spec-secid">2.5</span>Digits</a></li>
<li id="_sidebar_2.6"><a href="#sec-Expression"><span class="spec-secid">2.6</span>Expression</a></li>
</ol>
</li>
<li id="_sidebar_3"><a href="#sec-Execution"><span class="spec-secid">3</span>Execution</a>
<input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3" /><label for="_sidebar_toggle_3"></label>
<ol>
<li id="_sidebar_3.1"><a href="#sec-Execution.Overview"><span class="spec-secid">3.1</span>Overview</a></li>
<li id="_sidebar_3.2"><a href="#sec-Query-context"><span class="spec-secid">3.2</span>Query context</a></li>
<li id="_sidebar_3.3"><a href="#sec-Scope"><span class="spec-secid">3.3</span>Scope</a></li>
<li id="_sidebar_3.4"><a href="#sec-Expression-validation"><span class="spec-secid">3.4</span>Expression validation</a></li>
<li id="_sidebar_3.5"><a href="#sec-Expression-evaluation"><span class="spec-secid">3.5</span>Expression evaluation</a></li>
<li id="_sidebar_3.6"><a href="#sec-Query-execution"><span class="spec-secid">3.6</span>Query execution</a></li>
</ol>
</li>
<li id="_sidebar_4"><a href="#sec-Data-types"><span class="spec-secid">4</span>Data types</a>
<input hidden class="toggle" type="checkbox" id="_sidebar_toggle_4" /><label for="_sidebar_toggle_4"></label>
<ol>
<li id="_sidebar_4.1"><a href="#sec-Null"><span class="spec-secid">4.1</span>Null</a></li>
<li id="_sidebar_4.2"><a href="#sec-Boolean"><span class="spec-secid">4.2</span>Boolean</a></li>
<li id="_sidebar_4.3"><a href="#sec-Number"><span class="spec-secid">4.3</span>Number</a></li>
<li id="_sidebar_4.4"><a href="#sec-String"><span class="spec-secid">4.4</span>String</a></li>
<li id="_sidebar_4.5"><a href="#sec-Array"><span class="spec-secid">4.5</span>Array</a></li>
<li id="_sidebar_4.6"><a href="#sec-Object"><span class="spec-secid">4.6</span>Object</a></li>
<li id="_sidebar_4.7"><a href="#sec-Pair"><span class="spec-secid">4.7</span>Pair</a></li>
<li id="_sidebar_4.8"><a href="#sec-Range"><span class="spec-secid">4.8</span>Range</a></li>
<li id="_sidebar_4.9"><a href="#sec-Datetime"><span class="spec-secid">4.9</span>Datetime</a></li>
</ol>
</li>
<li id="_sidebar_5"><a href="#sec-Equality-and-comparison"><span class="spec-secid">5</span>Equality and comparison</a>
<input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5" /><label for="_sidebar_toggle_5"></label>
<ol>
<li id="_sidebar_5.1"><a href="#sec-Equality"><span class="spec-secid">5.1</span>Equality</a></li>
<li id="_sidebar_5.2"><a href="#sec-Partial-comparison"><span class="spec-secid">5.2</span>Partial comparison</a></li>
<li id="_sidebar_5.3"><a href="#sec-Total-comparison"><span class="spec-secid">5.3</span>Total comparison</a></li>
</ol>
</li>
<li id="_sidebar_6"><a href="#sec-Simple-expressions"><span class="spec-secid">6</span>Simple expressions</a>
<input hidden class="toggle" type="checkbox" id="_sidebar_toggle_6" /><label for="_sidebar_toggle_6"></label>
<ol>
<li id="_sidebar_6.1"><a href="#sec-This-expression"><span class="spec-secid">6.1</span>This expression</a></li>
<li id="_sidebar_6.2"><a href="#sec-This-attribute-expression"><span class="spec-secid">6.2</span>This attribute expression</a></li>
<li id="_sidebar_6.3"><a href="#sec-Everything-expression"><span class="spec-secid">6.3</span>Everything expression</a></li>
<li id="_sidebar_6.4"><a href="#sec-Parent-expression"><span class="spec-secid">6.4</span>Parent expression</a></li>
<li id="_sidebar_6.5"><a href="#sec-Function-call-expression"><span class="spec-secid">6.5</span>Function call expression</a></li>
</ol>
</li>
<li id="_sidebar_7"><a href="#sec-Compound-expressions"><span class="spec-secid">7</span>Compound expressions</a>
<input hidden class="toggle" type="checkbox" id="_sidebar_toggle_7" /><label for="_sidebar_toggle_7"></label>
<ol>
<li id="_sidebar_7.1"><a href="#sec-Parenthesis-expression"><span class="spec-secid">7.1</span>Parenthesis expression</a></li>
<li id="_sidebar_7.2"><a href="#sec-Attribute-access-expression"><span class="spec-secid">7.2</span>Attribute access expression</a></li>
<li id="_sidebar_7.3"><a href="#sec-Element-access-expression"><span class="spec-secid">7.3</span>Element access expression</a></li>
<li id="_sidebar_7.4"><a href="#sec-Slice-expression"><span class="spec-secid">7.4</span>Slice expression</a></li>
<li id="_sidebar_7.5"><a href="#sec-Filter-expression"><span class="spec-secid">7.5</span>Filter expression</a></li>
<li id="_sidebar_7.6"><a href="#sec-Projection-expression"><span class="spec-secid">7.6</span>Projection expression</a></li>
<li id="_sidebar_7.7"><a href="#sec-Pipe-function-call-expression"><span class="spec-secid">7.7</span>Pipe function call expression</a></li>
</ol>
</li>
<li id="_sidebar_8"><a href="#sec-Operators"><span class="spec-secid">8</span>Operators</a>
<input hidden class="toggle" type="checkbox" id="_sidebar_toggle_8" /><label for="_sidebar_toggle_8"></label>
<ol>
<li id="_sidebar_8.1"><a href="#sec-And-operator"><span class="spec-secid">8.1</span>And operator</a></li>
<li id="_sidebar_8.2"><a href="#sec-Or-operator"><span class="spec-secid">8.2</span>Or operator</a></li>
<li id="_sidebar_8.3"><a href="#sec-Not-operator"><span class="spec-secid">8.3</span>Not operator</a></li>
<li id="_sidebar_8.4"><a href="#sec-Equality-operators"><span class="spec-secid">8.4</span>Equality operators</a></li>
<li id="_sidebar_8.5"><a href="#sec-Comparison-operators"><span class="spec-secid">8.5</span>Comparison operators</a></li>
<li id="_sidebar_8.6"><a href="#sec-In-operator"><span class="spec-secid">8.6</span>In operator</a></li>
<li id="_sidebar_8.7"><a href="#sec-Match-operator"><span class="spec-secid">8.7</span>Match operator</a></li>
<li id="_sidebar_8.8"><a href="#sec-Asc-operator"><span class="spec-secid">8.8</span>Asc operator</a></li>
<li id="_sidebar_8.9"><a href="#sec-Desc-operator"><span class="spec-secid">8.9</span>Desc operator</a></li>
<li id="_sidebar_8.10"><a href="#sec-Unary-plus-operator"><span class="spec-secid">8.10</span>Unary plus operator</a></li>
<li id="_sidebar_8.11"><a href="#sec-Unary-minus-operator"><span class="spec-secid">8.11</span>Unary minus operator</a></li>
<li id="_sidebar_8.12"><a href="#sec-Binary-plus-operator"><span class="spec-secid">8.12</span>Binary plus operator</a></li>
<li id="_sidebar_8.13"><a href="#sec-Binary-minus-operator"><span class="spec-secid">8.13</span>Binary minus operator</a></li>
<li id="_sidebar_8.14"><a href="#sec-Binary-star-operator"><span class="spec-secid">8.14</span>Binary star operator</a></li>
<li id="_sidebar_8.15"><a href="#sec-Binary-slash-operator"><span class="spec-secid">8.15</span>Binary slash operator</a></li>
<li id="_sidebar_8.16"><a href="#sec-Binary-percent-operator"><span class="spec-secid">8.16</span>Binary percent operator</a></li>
<li id="_sidebar_8.17"><a href="#sec-Binary-double-star-operator"><span class="spec-secid">8.17</span>Binary double star operator</a></li>
<li id="_sidebar_8.18"><a href="#sec-Dereference-operator"><span class="spec-secid">8.18</span>Dereference operator</a></li>
</ol>
</li>
<li id="_sidebar_9"><a href="#sec-Precedence-and-associativity"><span class="spec-secid">9</span>Precedence and associativity</a></li>
<li id="_sidebar_10"><a href="#sec-Functions"><span class="spec-secid">10</span>Functions</a>
<input hidden class="toggle" type="checkbox" id="_sidebar_toggle_10" /><label for="_sidebar_toggle_10"></label>
<ol>
<li id="_sidebar_10.1"><a href="#sec-coalesce"><span class="spec-secid">10.1</span>coalesce</a></li>
<li id="_sidebar_10.2"><a href="#sec-count"><span class="spec-secid">10.2</span>count</a></li>
<li id="_sidebar_10.3"><a href="#sec-dateTime"><span class="spec-secid">10.3</span>dateTime</a></li>
<li id="_sidebar_10.4"><a href="#sec-defined"><span class="spec-secid">10.4</span>defined</a></li>
<li id="_sidebar_10.5"><a href="#sec-length"><span class="spec-secid">10.5</span>length</a></li>
<li id="_sidebar_10.6"><a href="#sec-references"><span class="spec-secid">10.6</span>references</a></li>
<li id="_sidebar_10.7"><a href="#sec-round"><span class="spec-secid">10.7</span>round</a></li>
<li id="_sidebar_10.8"><a href="#sec-select"><span class="spec-secid">10.8</span>select</a></li>
<li id="_sidebar_10.9"><a href="#sec-string"><span class="spec-secid">10.9</span>string</a></li>
</ol>
</li>
<li id="_sidebar_11"><a href="#sec-Pipe-functions"><span class="spec-secid">11</span>Pipe functions</a>
<input hidden class="toggle" type="checkbox" id="_sidebar_toggle_11" /><label for="_sidebar_toggle_11"></label>
<ol>
<li id="_sidebar_11.1"><a href="#sec-order"><span class="spec-secid">11.1</span>order</a></li>
</ol>
</li>
<li id="_sidebar_12"><a href="#sec-Vendor-functions"><span class="spec-secid">12</span>Vendor functions</a>
<input hidden class="toggle" type="checkbox" id="_sidebar_toggle_12" /><label for="_sidebar_toggle_12"></label>
<ol>
<li id="_sidebar_12.1"><a href="#sec-identity-"><span class="spec-secid">12.1</span>identity()</a></li>
</ol>
</li>
<li id="_sidebar_index"><a href="#index"><span class="spec-secid">Â§</span>Index</a></li>
</ol>
</div>
<script>(function (){
var currentSection;
var numberedSections = [];

var sections = document.getElementsByTagName('section');
for (var i = 0; i < sections.length; i++) {
  if (sections[i].getAttribute('secid')) {
    numberedSections.push(sections[i]);
  }
}

var scrollPos = window.scrollY;
var pending = false;
window.addEventListener('scroll', function (e) {
  scrollPos = window.scrollY;
  if (!pending) {
    pending = true;
    window.requestAnimationFrame(function () {
      updateSectionFocus(scrollPos);
      pending = false;
    });
  }
});

function updateSectionFocus(pos) {
  var readLine = pos + document.documentElement.clientHeight / 4;

  var focusedSection;
  for (var n = numberedSections.length - 1; n >= 0; n--) {
    if (numberedSections[n].offsetTop < readLine) {
      focusedSection = numberedSections[n];
      break;
    }
  }

  var secid = focusedSection && focusedSection.getAttribute('secid');
  if (secid !== currentSection) {
    currentSection && fold(currentSection, false);
    secid && fold(secid, true);
    currentSection = secid;
  }
}

function fold(secid, check) {
  document.getElementById('_sidebar_' + secid).className = check ? 'viewing' : '';
  var sections = secid.split('.');
  while (sections.length) {
    var toggle = document.getElementById('_sidebar_toggle_' + sections.join('.'));
    if (toggle) {
      toggle.checked = check;
    }
    sections.pop();
  }
}

updateSectionFocus(window.scrollY);
})()</script>
</div>
</body>
</html>
